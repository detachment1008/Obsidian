> 更深入地讨论了第 2 章的分治法，给出了更多的例子；可以跳过证明部分

# 最大子数组问题

即在一个数组中，寻找一个子数组，使之首尾的差距最大(现实问题就是股票)

如果将其转换为变化的数组，就是求最大子数组问题

当然，必须要有负数才有意义，否则整个数组的和肯定是最大的

## 暴力求解方法

依次尝试每一个地方开始，然后再依次尝试每一个地方结束：$\Omega$($n^2$)

## 分治的策略

1. 分解：分解为两个小数组，然后这两个小数组依次求解最大子数组问题
2. 解决：最小的时候就解决了
3. 合并：有三种可能
	1. 在左数组的结果中
	2. 在右数组的结果中
	3. 在左数组和右数组中间交叉的结果中

### 合并伪代码

```
FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)
left_sum = -∞
sum = 0
for i=mid downto low
	sum = sum + A[i]
	if sum > left_sum
		left_sum = sum
		max_left = i
right_sum = -∞
sum = 0
for j=mid+1 to high
	sum = sum + A[j]
	if sum > right_sum
		right_sum = sum
		max_right = j
return (max_left, max_right, left_sum + right_sum)
```
- 依次找最大的，然后记录位置
- 返回起始位置，结束位置，最大值

时间花费是：$\theta$(n)

> 因为 mid 是一定包含的，可以让 i 从 mid - 1 开始(左)；最后计算总和时加上 mid 就行了

### 求解伪代码

```
FIND-MAXIMUM-SUBARRAY(A, low, high)
if low == high
	return (low, high, A[low])
else
	mid = [(low + high) / 2](向下取整)
	(left_low, left_high, left_sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)
	(right_low, right_high, right_sum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)
	(cross_low, cross_high, cross_sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)
	if left_sum >= right_sum and left_sum >= cross_sum
		return (left_low, left_high, left_sum)
	elseif right_sum >= left_sum and right_sum >= cross_sum
		return (right_low, right_high, right_sum)
	else
		return (cross_low, croww_high, cross_sum)
```

# 矩阵乘法的 Strassen 算法

矩阵乘法：第一个取行，第二个取列，然后逐元素相乘，最后求和

## 标准求法

```
SQUARE-MATRIX-MULTIPLY(A, B)
n = A.rows
let C be a new n*n matrix
for i=1 to n
	for j=1 to n
		Cij = 0
		for k=1 to n
			Cij = Cij + aik * bkj
```

它的运行时间为：$\theta$($n^3$)

## 分治算法