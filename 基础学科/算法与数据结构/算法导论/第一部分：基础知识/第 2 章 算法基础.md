> 给出了书中的第一批算法，解决的是对 n 个数进行排序的问题

# 插入排序

我们用伪代码表示给定算法，为了不关心软件工程的问题

## 方法

想象起扑克牌时，一张一张拿，然后拿到手后从右向左逐个比较，并插入其中

## 伪代码

```
INSERTION-SORT(A)
for j=2 to A.length
	key = A[j]
	// 开始插入
	i = j - 1
	while i>=1 and A[i] > key
		A[i+1] = A[i]
		i = i - 1
	A[i + 1] = key
```

## 循环不变式

循环不变式：已排序的式子，在上述伪代码中就是 A\[1\] .. A\[j - 1] 的序列

## 证明

- 初始化：循环的第一次开始之前，循环不变式成立(A\[1\] .. A\[j - 1])
- 保持：如果某次循环前它为真，那么下次循环前它依旧为真
- 终止：循环终止时，它可以提供给我们一个有用的性质

其实前两步，就已经证明了循环不变式为真了；但是终止时，是为了让我们用循环不等式证明正确性的

# 分析算法

## 初始有序

此时是最好情况，时间为：`an+b`，线性函数

## 初始倒序

此时是最坏情况，时间为：`an^2+bn+c`，二次函数

## 平均情况

与最坏情况大致一样差，也是一个二次函数

我们更加抽象的分析，只考虑增长量级，即插入排序：`O(n^2)`，读作：`theta n 平方`

## 选择算法

练习题：以下是个人伪代码

```
CHOOSE-SORT
for j=1 to A.length - 1
	val = A[j]
	for i=j+1 to A.length
		if A[i] < val
			val = A[i]
	a[j] = val
```

最好和最坏都是：O(n^2)

# 设计算法

上述的排序方法，采用了增量法；即部分有序，然后逐个增加

这里我们再考虑一种分治法，它的最坏情况运行时间比增量法要少很多

## 分治法

为了解决一个给定的问题，一次或多次的递归调用自身，以解决紧密相关的若干子问题

分治法的思想：将原问题分解为若干规模较小，但是类型于原问题的子问题，递归的求解这些子问题，最后合并这些子问题的解
- 一般难点在合并这些子问题

都有的三个步骤：
1. 分解：将原问题进行分解为规模较小的子问题
2. 解决：解决这些子问题(可以递归)
3. 合并：将这些子问题的解合并为原问题的解

## 归并排序

遵循的分治法的步骤：
1. 分解：分解待排序的 n 个元素的序列为 n/2 个元素的两个子序列
2. 解决：递归的解决这两个子序列(依次再分解)
3. 合并：将这两个排序好的序列合并，产生已排序的结果

关键：合并两个已排序的子序列

我们定一个函数：MERGE(A, p, q, r) 来完成合并
- A：数组
- p：数组下标
- q：数组下标
- r：数组下标
表明合并的两个子序列是 p-q 和 (q+1)-r；最后的合并结果是 p-r 的有序数组

### 合并方法

n = r - q + 1，就是待合并元素的总数

考虑有两落有序的扑克牌在桌子上，最小的牌在最上面；每次都拿这两落牌中最上面的最小的一张，直到一个牌堆空了，就将另一个牌堆放在手中的最后面即可

最差情况，我们也是只是一次放一张到手里罢了(没有最后的将一落牌都放在手里的过程)；所以合并的时间为：O(n)

### 合并伪代码

为了避免每次都必须检查牌堆是否为空，我们可以在每个牌堆下都放置一个哨兵牌，为最大值，标识着已经到了牌堆低

```
MERGE(A, p, q, r)
	n1 = p - q + 1
	n2 = r - q
	let L[1..n1+1] and R[1..n2+1] be new arrays
	for i=1 to n1
		L[i] = A[p + i - 1]
	for j=1 to n2
		R[j] = A[q + j]
	L[n1+1] = ∞
	R[n2+1] = ∞
	i = 1
	j = 1
	for k = p to r
		if L[i] <= R[j]
			A[k] = L[i]
			i = i + 1
		else
			A[k] = R[j]
			j = j + 1
```

### 归并排序(利用合并函数)

它的作用就是前两步：
1. 递归的调用自己进行分解
2. 直到某个规模，可以解决问题(这里指剩余只有一个元素)

```
MERGE-SORT(A, p, r)
if p < r
	q = [(p + r) / 2](向下取整)
	MERGE-SORT(A, p, q)
	MERGE-SORT(A, q+1, r)
	MERGE(A, p, q, r)
```

## 分析分治算法

设 T(n) 是解决规模为 n 的问题的运行时间

1. 如果问题足够小：O(1)
2. 分解为 a 个子问题，每个问题的规模是 1/b，则解决时间：a\*T(n/b)
3. 分解的时间：D(n)
4. 合并的时间：C(n)

总时间：T(n) = a\*T(n/b) + D(n) + C(n)
- 只考虑了分解一次，合并一次

可知：
- D(n) = O(1)
- a\*T(n/b) = 2T(n/2)
- C(n) = O(n)

即：2T(n/2) + O(n)

画一个树就可以知道，它的运行时间为：O(n\*lg(n))

# 其他

## 选择排序

## 二分查找

## 插入排序中使用二分查找

## 归并排序中对小数组使用插入排序

## 冒泡排序