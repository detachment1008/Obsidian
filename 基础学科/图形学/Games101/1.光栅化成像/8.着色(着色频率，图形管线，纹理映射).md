# 着色频率

有三种着色的频率：
1. 基于平面的着色：即对于每一个三角面片，我们都有一个法向量，基于它我们进行一次着色，然后将结果应用于整个三角面片
2. 基于顶点的着色：即我们先求出三角面片三个顶点的法线，然后我们对三个顶点进行着色，然后将结果插值应用于整个三角面片
3. 基于像素的着色：同样我们先求出三角面片的三个顶点的法线，然后我们在内部对每个像素插值，从而获取法向量，然后再对每个像素都进行着色

但是当模型足够复杂，即三角面片很小时，我们基于平面的着色效果也不差的，而且降低了开销

如何求顶点的法线？
1. 先求出它相接的所有三角面片的法向量
2. 然后求平均，就是这个顶点的法向量(也可以用三角形面积，做加权平均，效果会更好)

# 图形管线

它只能被称为实时渲染管线，对于其他的渲染方法，并不是这么做的

它其实就是表示的是一系列操作，即从一个 3D 的场景模型，到最后的一张图

管线：
1. 输入：空间中的点
2. 经过变换，变换到 2D 屏幕空间中的点，然后连成三角形
3. 通过光栅化，将三角形给离散为像素(如果不做SSAA这些操作时)
4. 着色，即获取每一个像素的颜色(先进行深度测试，再进行着色)
5. 输出：一个存储屏幕颜色的帧缓冲数组

当然，如果我使用 SSAA 等操作时，我们是将三角形离散为片元，然后着色也是对每一个片元来进行的操作，最后我们将片元组合，拼出一个帧缓冲数组

如果我们是基于顶点的着色，在变换前就可以进行着色了，如果要基于像素的着色，就只能在光栅化之后了

着色的操作都是在 shader 的 FragmentShader 中完成的，这部分是可编程的

## GPU

分为两种：
1. 独立显卡
2. 集成显卡(作为 CPU 的一部分)

可以把 GPU 理解为是一个高度并行化的 CPU

核的数量，可以理解为可以并行的数量。GPU 并行程度远超 CPU 几十倍。

# 纹理映射

对于不同物体，或同一物体不同的位置，它们的属性是不同的，即不吸收的能量比例是不同的，我们希望在每一个不同的位置，都定义它自己本身的属性，即不吸收能量的比例

3D 物体的表面，仍然是一个 2D 的图片，这个图片就是纹理。

当把纹理对应覆盖到 3D 物体的表面时，这个过程就是纹理映射

我们不管如何找到纹理和 3D 物体之间的映射关系，这是艺术家该做的事，在这里我们认为我们已经得到了这个映射关系。

3D 物体有一个坐标系，我们在纹理上也应该定义一个坐标系，以得到这个映射的关系。

我们定义横坐标为 $u$，纵坐标为 $v$，从而在纹理上定义一个 $uv$ 的坐标系

而且我们规定，纹理的 $uv$ 范围都在 \[0,1] 之间，无论它的宽高比，分辨率是多少

每一个三角形的顶点都对应一个 $uv$ 坐标，然后就可以通过纹理映射找到对应的属性了

纹理是可以被重复使用的，即一个场景上，可能不同物体，或同一物体的不同位置都用纹理的同一个地方，这是没问题的。(注意：在设计纹理的时候，最好左右上下在重复时都可以无缝衔接，这样如果重复使用效果比较好，比较平滑)

纹理和着色是同时应用的，着色会应用到对应纹理上的属性