# 插值

插值的工具：重心坐标

重心坐标：在三角形所在的平面内，任何一个点的坐标都可以表示成三角形这三个顶点坐标的线性组合

即：
1. $$(x,y)=\alpha A+\beta B +\gamma C$$
2. $$\alpha+\beta+\gamma=1$$

其中：
- $(x,y)$：是任意一个点的坐标
- $(\alpha,\beta,\gamma)$：是这个点对应的重心坐标

其实它就是两个数，另一个数可以由这两个数推出来

当 $(x,y)$ 在三角形内部时:
1. $\alpha >= 0$
2. $\beta >= 0$
3. $\gamma >= 0$

如果它在三角形内部，可以通过面积比来求出重心坐标：
1. $\alpha=\frac{A}{A+B+C}$
2. $\beta=\frac{B}{A+B+C}$
3. $\gamma=\frac{C}{A+B+C}$

$A,B,C$ 表示顶点相对的三角形的面积(非自己相接的三角形)

注意：如果我们有一个三维空间中的重心坐标，在经过投影到二维空间后，它的重心会改变，即这个点的重心坐标会变化。所以我们应该在三维空间中做重心插值，而不应该在投影后的二维空间中做插值

应该是找到这个像素点，然后找到它对应的三维空间中的位置，然后做重心插值获取属性，然后应用到这个像素点上(应用逆变换就可以了)

# 纹理应用(纹理描述漫反射)

当我们通过重心插值获取到像素的 $u,v$ 坐标后，就可以从纹理中获取对应的属性了

当我们使用 $u,v$ 从纹理中获取属性时，会有一些问题：

## 1. 纹理太小

可以理解为纹理的帧缓冲小，此时我们的 $u,v$ 转化为 $index$ 索引时，就对应的不是整数了，只能通过四舍五入等形式，将其转化为整数，然后取出对应的属性

所以此时，很多像素的 $u,v$ 都会被转化为同一个 $index$，从而导致结果不连续。(如：0.49被映射到了一个索引，0.5被映射到了另一个索引，但是它们在屏幕上是连续的)

一种解决办法：双线性插值代替四舍五入(指的是水平和竖直，其实是三次线性插值)

当我们获取纹理属性时，当它没有对应到 $texel$ 中心时，我们取周围的四个 $texel$ 然后做两次线性插值(水平和垂直)，从而得到这一点的属性

即为了区分当点不在纹理像素正中心时获取的属性

另一种解决办法：双三次插值

它是取周围的十六个像素做插值

总结，纹理太小导致多个像素映射到纹理的同一个纹理像素内

## 2. 纹理太大

一般出现在物体渐远的情况，此时由于透视投影，远处的物体会被缩小，所以对应的纹理图也就变大了

总结，纹理太大导致一个像素包含了纹理的多个纹理像素。如果简单的映射，就会导致用像素中心点的纹理映射像素代替了多个纹理像素。

即一个像素内信号频率过快，而采样频率过低造成的走样

一种解决办法：同之前的 SSAA ,在一个像素点内取多个采样点进行纹理映射

但是它非常慢

另一种解决办法：Mipmap

点查询和范围查询的问题。我们之前说的都是点查询，需要采样。但是这个是范围查询，不需要采样。

用 Mipmap 做范围查询的特点：
- 快速
- 近似
- 方形

Mipmap：即一张图生成一系列不同大小的图，且它可以在预处理阶段完成，不损耗额外性能。且只有额外的 $\frac{1}{3}$ 的存储量

当我们在 Mipmap 图上进行采样时，我们可以同时在目标像素的上面和右面也取一个像素，然后计算它在纹理图上的距离，然后取一半(取最大值)围成一个矩形，就是我们目标像素在 Mipmap 纹理图上的大小

然后我们判断这个矩形的边长是多大，从而去对应的 Mipmap 图上去寻找它的大小

我们认为原始纹理图像是第 0 层，然后每缩小一半，层数加 1；则设矩形的边长是 L，即占据 $texel$ 纹理像素的大小的边长是 L，应该去找的层数是：
$$D=Log_2{L}$$

层数每+1，像素的大小扩大一倍

但是此时还是有一个问题，即如果矩形的边长不是 2 的整数幂次方，即假如对应到了 1.8 层，该如何取值呢？
- 三线性插值

以 1.8 层为例，我们可以在第一层上做双线性插值，然后在第二层上做双线性插值，然后再在层与层之间再做一次插值即可

此时还是有一个问题：在远处，会模糊的过分了

解决办法：各向异性过滤(开销是原来的 3 倍了)
- 它生成图片时，不仅生成同时缩放宽高的图，还同时生成缩放宽，缩放高的图
- 这样它就可以对长条形的区域进行一个范围查询了
- 但是它只能解决一部分的问题，即如果像素是斜着对应到纹理图上就不可以了

其他解决办法：
- EWA 过滤

总结：其实有两方面。一个是纹理坐标(u,v)到纹理像素(tixel)的映射，一个是找到合适的纹理大小。

1. 纹理坐标到纹理像素的映射
- 直接选取最近的纹理像素(会导致变化非常明显，不平滑，即一个一个的小方块)
- 双线性插值，即在附近找四个最邻近的像素，然后水平和垂直进行线性插值得到四个纹理像素的插值平均的结果(会导致模糊，因为平均会造成纹理信号频率下降，从而导致损失细节)

2. 找到合适的纹理大小
- Mipmap：生成多级纹理，然后在两个相邻层都用上述方法找到对应的纹理像素，然后做一个简单的线性插值即可
- 各向异性过滤：它生成更多的纹理，效果比 Mipmap 好，开销比 Mipmap 大。Mipmap在判断像素大小时，是用一个固定的矩形大小判断的，这可能导致如果是矩形的话，它在短边那个方向就容纳的更多的纹理像素，从而被额外的平均了。而各向异性过滤就可以找到对应的矩形大小的纹理，从而获取更好的纹理像素平均值

再总结一下：
- 当纹理像素数小于物体像素时，一个纹理像素会被映射到多个物体像素，这个叫纹理放大，此时如果不做处理就会失真和模糊，所以需要我们的二次线性插值
- 当纹理像素数大于物体像素时，多个纹理像素会被映射到一个物体像素，这个叫纹理缩小，此时我们只能对这几个纹理像素做平均，再映射到这个物体像素。做法是Mipmap。当然难点是对哪些纹理像素做平均？正方形物体用Mipmap，矩形物体使用各向异性过滤。

# 高级纹理映射

纹理完全可以理解为一块数据，而非仅仅是图像。这样我们就可以用纹理表示更多的东西了。

## 环境贴图(纹理描述环境光)

我们之前描述环境光照，都用用一个定值 $I$ 去描述环境光的强度，但是我们可以用一个环境贴图去描述它。

比如在一个屋子内，环境贴图就记录了各个方向来的环境光的光强，我们用这个去做环境光进行渲染，就会得到一个映射了其他物体的渲染景象。

这里其实是一种假设，因为我们一般认为环境光来自无限远，即只用记录方向就可以获取环境光了

所以它是根据物体表面的法线，来从环境贴图中获取属性的。即将环境贴图变换为球形坐标系或立方体坐标系。

可以先记录为球形环境纹理，然后再展开。但是有一个问题，展开后，靠近极点的方向会发生一个扭曲。即本身我们在球形坐标系上较远的两个uv坐标，转换到展开的纹理取值时，就会很靠近了

我们可以在球形的外面再套一个立方体，然后把球形继续扩散到这个立方体上。但是它的缺点是不容易由方向计算对应的纹理数据

总结：环境贴图是记录环境光照信息的，相当于描述环境光。它的uv是动态计算出来的，而非提前记录好的。分为两种形式，球形的和立方体形的。球形的问题在于展uv的过程中，会导致极点部分失真。即极点附近纹理的密度会非常高，所以会被压缩，导致在极点附近出现失真的情况。而立方体形的环境贴图就没有这个影响，但是它相当于生成了 6 张贴图，每次动态获取 uv 的时候，需要先判断它属于哪一个贴图，过程有些繁琐。

## 凹凸贴图

即我们可以通过纹理定义一个物体表面的相对高度，即由基础高度向上或向下多少距离。

高度发生变换->法线发生变化->着色发生变化，所以我们看着就不一样了

所以凹凸贴图和法线贴图，实际上说的是一个事情，即我们也可以直接定义一个点的法线

好处：我们可以增加物体表面细节，但是不需要更改物体本身的几何结构

步骤：
- 对物体表面的法线，做一个扰动：即定义相对高度，然后重新计算法线

难点：如何计算法线如何变化的

一维情况下：
- 假设原始的法向量：$(0,1)$
- 找到这一个点的导数：可以用相邻两个点的高度差来计算它的导数
	- $c$：一个常数，用来调整凹凸贴图对它本身的影响
$$dp=c*[h(p+1)-h(p)]$$
- 我们设这个点的切线相邻是：$(1,dp)$
- 则这个点的法线向量就得到了：$(-dp,1).normalized()$

二维情况下：
- 假设原始法向量：$(0,0,1)$
- 确定这个点在 u,v 上的变化率：
$$\frac{dp}{du}=c1*[h(u+1)-h(u)]$$
$$\frac{dp}{dv}=c1*[h(v+1)-h(v)]$$
- 得到法线向量：
$$n=(-\frac{dp}{du},-\frac{dp}{dv},1).normalized()$$

但是现实中，该点的原始法向量可能不是 $(0,0,1)$，所以我们可以定义一个局部的坐标系，来使得它的法向量为 $(0,0,1)$，然后我们求出来新的法线向量，然后我们再重新映射回世界坐标系中即可

## 位移贴图

它相较于凹凸贴图，是一个更加现代化的做法。

首先，它们的定义是相同的，即在一个点定义它高度的偏移值。但是位移贴图会把实际的三角形面片真的做一个位置的移动。即它真的移动了顶点。

凹凸贴图实际上没有改变自己的几何，所以有两个缺陷：
1. 在边缘上，可以看到它原本的几何信息
2. 在阴影上，它也会用原本的几何信息做阴影

而在位移贴图上，上面的缺陷都可以被完美的解决。但是它要求模型本身的三角形面片足够细，即三角形顶点之间的间隔，比纹理的频率更加高才行。

Directx 有一个动态的曲面积分，它可以先由一个不细致的模型应用位移贴图，然后根据需要，再细分。

## 三维纹理

它定义了空间中，每一个点的值

即它定义了空间中的一个噪声函数，给定空间中的一个点，都可以计算出这一个点的噪声。然后我们就可以对这个噪声进行一系列的处理了。

广泛应用于体积渲染中

## 记录信息

纹理还可以记录之前已经计算好的一些信息。

比如我们可以提前使用环境光遮蔽技术，生成一个携带有阴影信息的图，然后再应用就非常快了