# 如何使用包围盒来加速光线追踪？

思想：
1. 光线和盒子的求交计算非常快
2. 只有当光线穿过盒子时，再和盒子内部的物体进行三角面片求交计算

以下的加速结构都是预处理过程中做好的，然后才会去计算光线求交

## 均匀格子

步骤：
1. 创建一个包围盒，包裹住场景中的所有物体
2. 在包围盒内部，均匀的划分格子
3. 当格子内有物体时，我们将其标记(不考虑物体内部，只考虑物体表面)
4. 然后当有光线时，判断它和那些格子相交
	- 当格子内部没有物体时，就忽略
	- 当格子内部有物体时，就进行光线和物体的求交

判断光线传播方向的一种简化思路：
- 假如说光线是沿着右上方传播的
- 当光线和某个格子有交点，则下一个一定是在它的右方和上方。其他位置的格子就不用判断了

空间中划分多少个格子合适呢？
- 一般是 27 \* 场景中物体的数量

适用场景：空间中的物体分布比较均匀。因为走格子，即判断和包围盒相交也是一种性能计算

## 空间划分

格子划分时是均匀的，而空间划分可以不均匀

### 八叉树(Oct-Tree)

指的是在空间中，切三刀，变成了 8 块这一个过程(二维空间中是 4 块)

然后对每一块，继续切下去，当切完后达成某一个条件(如 4 块中 3 块都没有物体)，这一部分就不再切了
- 有的子节点切，有的不切，所以是不均匀的划分

但是它有一个问题：维度越高，每次切割出的格子数就越多

### KD-Tree

它的做法和 8 叉树类型，但是对于某个包围盒，它每次只沿着某个轴切一刀

它就会形成一个类似二叉树的结构

在切割时，一般我们按照每一层沿同一个轴来切割。如在二维空间下，第一层沿 x 轴切，第二层都沿 y 轴切，第三层再沿 x 轴切 ...

### BSP-Tree

它和 KD-Tree 的区别就是，它可以沿任意方向切割，而非必须沿着轴的方向进行切割 

# KD-Tree 的实现

设计数据结构：
1. 节点：
		- 当前节点沿着哪一个轴进行划分(它和下面的属性是用于判断孩子包围盒的大小的)
	- 划分的位置(不一定是中点)
	- 指向孩子节点的指针
2. 叶子节点
	- 盒子内部存储的物体信息

问题：
- 很难判断一个物体和给定的包围盒是否有交集(如三个三角形三个顶点都不在包围盒内，但是物体本身却和包围盒有交集的情况)。
- 一个物体可能和很多包围盒都有交集，即会造成重复计算的情况

# BVH

Bounding Volume Hierachy：它和上述空间划分的观念不同，它是一种物体划分的思想

步骤：还是由一个 AABB 包围盒开始
1. 将空间中的物体分成两部分，然后分别用一个包围盒来进行包围起来
2. 重复上面的过程，一直划分
3. 同样，实际物体存储在叶子节点内

它有一个好的性质：一个物体可以完整的在一个包围盒内部

但是它并不是空间的均匀划分，即一个物体可能也同时在两个盒子内出现
- 当然，怎样划分是很讲究的。因为我们希望物体尽量不重叠出现在多个盒子内部

如何划分一个节点？
- 选择一个合适的维度(如这次是 x ，下次就沿 y)
- 每次都沿着长轴进行划分
- 每次取中间位置的三角形，然后进行划分，可以保证两边的物体数量尽量相同
	- 排序的时候通过重心排序
	- 可以去找中位数，此时就不用排序(快速选择算法)

数据结构：
1. 中间节点
	- 包围盒
	- 孩子节点的指针
2. 叶子节点
	- 包围盒
	- 包含的物体列表