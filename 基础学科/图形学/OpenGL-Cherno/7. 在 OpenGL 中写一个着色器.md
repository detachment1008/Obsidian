# `Shader`
---

Shader 就好像是一个个的文件一样，它们虽然可以处理某些功能，但是互相之间也会配合，所以单个是无法完成工作的，所以我们需要将其链接起来

所以，第一步：创建一个程序
`glCreateProgram()`: 创建显存，存储程序

然后，我们就像 C++ 一样，分离式编译，即单个文件先单独编译，形成二进制文件
`glCreateShader()`: 创建显存，存储 shader
`glShaderSource()`: 传递数据，内存 -> 显存
`glCompileShader()`: 编译 shader, 用编译过后的数据覆盖了当前的未编译的 shader

我们可以查看编译的结果，以判断当前 shader 是否编译通过
`glGetShaderiv()`: 获取指定的内存中 shader 的信息，通过第二个参数的不同，可以获取是否成功的信息、编译的 log 信息长度等
`glGetShaderInfoLog()`: 获取指定内存中 shader 的 log 信息(可以只获取一部分，所以通过上一步获取长度后就可以获取全部的 log 信息了)

如果编译都成功通过，就可以链接到第一步创建的用于存储可执行程序的显存了
`glAttachShader()`: 为一个程序，添加指定编译后的二进制代码
`glLinkProgram()`: 链接程序
`glValidateProgram()`: 每次应用某个数据的时候，我们都要激活一下(经过测试，这个不加也没有关系)
`glUseProgram()`: 表示之后的渲染使用这个程序

最后，因为链接好的可执行程序都生成了，之前的编译后的单个文件的二进制代码就没有用了，可以删除以释放内存了
`glDeleteShader()`

# 额外
---

数组无法动态分配内存，但是可以使用 `alloca`

这个函数可以在栈上动态分配内存，比堆上的( `malloc` )更加快速；

# 一点 GLSL 的代码
---

1. 开始前，使用预处理定义当前使用的版本：`#version 330 core`
2. 主函数和 C++ 一样，但是是没有返回值类型的: `void main() {}`
3. 获取属性：
	1. `layout(location = 0)` ，表示获取 0 号属性的值
	2. `in vec4 position`: 加在获取属性的后面，表示输入到这个 `vec4` 类型的变量 `position` 中
4. 顶点着色器：注意，前面说的顶点着色器的主要目的是设置顶点位置，所以一定要为默认变量 `gl_Position` 赋值，它是一个 `vec4` 类型的变量，决定了顶点的位置(如果不指定，默认的数据类型都是 `float`，如 `vec4` 就是 4 个 `float` 类型组成的)
5. 片段着色器：注意，前面说的片段着色器的主要目的是设置片段颜色，所以一定要有一个输出的 `vec4` 类型的变量，即第一个输出的 `vec4` 类型的变量将自动被用做当前片段的颜色(不知道为啥不也搞一个内置的变量 `gl_Color` 之类的)