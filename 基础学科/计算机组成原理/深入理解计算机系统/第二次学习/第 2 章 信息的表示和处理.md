# 引言
---

计算机存储和处理的信息都以二值信号表示，好处：容易被表示、存储和传输

孤立的位并不是非常有用，所以需要：
1. 多个位组合在一起
2. 以某种解释方式，去解释这些位

三种最重要的数字表示：
1. 无符号数编码：基于传统的二进制表示法，表示大于或等于零的数字
2. 补码编码：表示有符号整数的最常见方式，可以表示为正或负的数字
3. 浮点数编码：表示实数的科学计数法的以 2 为基数的版本

因为计算机是以有限的位+某种解释去表示数字的，所以当结果太大以至于不能表示时，某些运算就会溢出。

浮点数的溢出和整数不同，如它会产生正无穷，但是一组正数的乘积总是正的。而且浮点数不可结合，因为它的精度有限。

# 2.1 信息存储
---

最小可寻址的内存单元：字节(8 位的块)

我们可以将内存视为一个非常大的字节数组，即虚拟内存(实际不是这样的)

存储器空间存放三种信息(这完全在虚拟地址空间内完成的)：
1. 程序数据
2. 指令
3. 控制信息

## 2.1.1 十六进制表示法

由于二进制表示法中，太冗长了，如果我们用十进制表示，但是它和二进制之间的相互转换比较麻烦，所以我们使用十六进制来表示二进制的位模式。

十进制转换到其他进制：除法(除以进制的范围)
其他进制转换到十进制：乘法(乘以自己对应的权重)

## 2.1.2 字数据的大小

字长：即 CPU 一次可以处理的最大长度，它反映在地址上，就是虚拟地址空间的大小。如 32 位和 64 位机器

32 位程序和 64 位程序的区别：在于该程序是如何被编译的，而不是运行时的机器类型。64 位机器可以运行 32 位程序(相当于只用了一半的地址空间罢了)，但是 32 位机器无法运行 64 位程序。

在 c 语言编程中，如果希望对数据准确控制，就需要使用确定大小的整数类型；但是如果希望拥有良好的可移植性，就需要程序对不同数据类型的大小不敏感了。(如当 32 位程序迁移到 64 位时，如果 int 用于存储地址长度，那么就会出现错误)

## 2.1.3 寻址和字节顺序

多字节对象：被存储为连续的字节序列。所以我们需要知道它的起始地址和长度

两种对象内部的排列字节方式(多字节对象才有)：
1. 大端(高尾端)
2. 小端(低尾端)

当是小端时，从右向左读即可(左是低地址时)；大部分 Inter 兼容机都是小端模式

字节顺序其实大部分情况下都是不可见的，除非：
1. 网络传输二进制数据时
2. 阅读编译后的字节序列时
3. 强制类型转换时

编程的建议：
1. 使用 `sizeof(类型)` 而不是使用固定的值
2. 使用 `typedef` 来命名数据类型，即可以改善代码的可读性，也便于之后的类型修改

## 2.1.4 表示字符串

它不记录长度，我们只记录起始地址，然后直至一个以 null (值为 0) 字符结尾时结束。每个字符都由 ASCII 编码。当然，它和大端小端之类的就没有关系了，按顺序一个一个读的。

0x3x -> x：1~9，正好表示十进制的数字 1~9

## 2.1.5 表示代码

两点特殊：
1. 二进制代码几乎不能在不同的机器和操作系统之间移植
2. 它也仅仅是字节序列，没有关于源程序的任何信息

## 2.1.6 布尔代数简介

布尔代数：将逻辑值和二进制联系在一起，即 1 表示 真，0 表示假。如此可以利用 1 和 0 的代数，研究逻辑推理的基本原则。

四种布尔运算：
1. 与
2. 或
3. 非
4. 异或

扩展到位向量的运算：即定义为参数的每个对应位之间的运算

环：一种代数结构，由一个集合和两种二元运算(加法和乘法)组成，且满足一系列公理，如结合律，分配率等

布尔环：集合就是 0 和 1 组成的实数集
1. 加法：异或
2. 乘法：与
3. 或运算

布尔环的加法逆元：是它自己的本身，即 0 ^ 0 = 1 ^ 1 = 0，(a ^ b) ^ a = b

位向量的应用：表示有限的集合(即 0 表示不存在，1 表示存在)

## 2.1.7 C 语言中的位级运算

它支持按位布尔运算，一个常见的用法就是实现掩码运算：
1. 与(0 位置)：置 0
2. 或(1 位置)：置 1
3. 异或(1 位置)：取反

## 2.1.8 C 语言中的逻辑运算

逻辑运算不是位级运算，它认为任何非 0 的都是真，而 0 表示假

而且它会进行短路求值，即第一个参数求值就能确定表达式的结果时，就不会对第二个参数求值

且对任何一个非 0 数，使用两次 !，都会变成 1(1 是真的默认表示数)

## 2.1.9 C 语言中的移位运算

左移：右侧补 0

右移：
1. 逻辑右移(针对无符号数编码)：左侧补 0
2. 算术右移(针对补码编码)：左侧补最高有效位的值

# 2.2 整数表示
---

整数有两种编码方式：
1. 非负数：无符号数
2. 负数、零、正数：补码

一些术语：无符号数和补码指的是十进制下的数值大小
- $B2T_w$：函数，二进制转补码
- $B2U_w$：函数，二进制转无符号数
- $U2B_w$：函数，无符号数转二进制
- $U2T_w$：函数，无符号数转补码
- $T2B_w$：函数，补码转二进制
- $T2U_w$：函数，补码转无符号数
- $TMin_w$：常数，补码的最小值
- $TMax_w$：常数，补码的最大值
- $UMax_w$：常数，无符号数的最大值
- $+^t_w$：操作，补码的加法
- $+^u_w$：操作，无符号数的加法
- $*^t_w$：操作，补码的乘法
- $*^u_w$：操作，无符号数的乘法
- $-^t_w$：操作，补码的取反
- $-^u_w$：操作，无符号数的取反

## 2.2.1 整型数据类型

C 语言只规定了每种类型的最小取值范围

注意一个特点：补码中，负数的范围比正数的范围大 1

## 2.2.2 无符号数的编码

**原理**：无符号数编码的定义
$$B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i$$

即每位的权值，是 $2^{w-1}$，每一位加起来就是无符号数

无符号数的范围：$0$~$2^w-1$

**原理**：无符号数编码具有唯一性

$B=B2U->U2B$

## 2.2.3 补码编码

它和无符号数编码的区别：它将最高有效位解释为负权

**原理**：补码编码的定义
$$B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$$

因为最高位如果是 1 就一定是负数，如果是 0 就一定是正数，所以最高位也被称为符号位

范围：$-2^{w-1}$~$2^{w-1}-1$

**原理**：补码编码的唯一性

$B=B2T->T2B$

## 2.2.4 有符号数和无符号数之间的转换

对于 C 语言来说，强制转换只改变解释方式，不改变位模式

$T2U(x)=B2U(T2B(x))$

即补码转无符号数，就先由 T 转换为 B ，再由 B 转换为 U

所以它们可能有相同的位表示，但是它们的结果可能会不同

如果我们希望结果不变，而位模式可以变：

**原理**：补码转换为无符号数
$$T2U_w(x)=
\left\{
\begin{matrix}
x+2^w,x<0  \\
x,x>=0 
\end{matrix}
\right.
$$

因为最高位由 $-2^{w-1}$ 变为了 $2^{w-1}$

**原理**：无符号数转换为补码
$$U2T_w(u)=
\left\{
\begin{matrix}
u,u<=TMax_w  \\
u-2^w,u>TMax_w
\end{matrix}
\right.
$$

同理，无符号数如果超过了最大值，就说明最高位是 1，则转换为补码时，就需要减去 $2^{w-1}$

总结：在范围 $0$～$TMax_w$ 内，它们的位模式也相同；否则就需要根据情况，加上 $2^{w-1}$ 或 减去 $2^{w-1}$

## 2.2.5 C 语言中的有符号数与无符号数

对于 C 语言来说，立即数除非带了后缀 'u'，否则都视为有符号数

在运算中，如果一个运算数是有符号的，而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制转换为无符号数；这对于算术运算来说没有什么影响，因为我们都将其看作位模式罢了，但是对于关系运算符来说，会导致非直观的结果。如：负数的有符号数被转换为无符号数时，一定比一半的无符号数都要大。

## 2.2.6 扩展一个数字的位表示

希望不同字长的整数之间进行转换，同时又保持数值不变是一个常见的运算；当目标数据类型太小，以至于无法表示想要的值时无法完成，但是当从一个较小的数据类型转换到一个较大的数据类型时，是一定可以完成的。

**原理**：无符号数的零扩展
- 即简单地在无符号数的二进制表示的开头添加 0 即可

**原理**：补码数的符号扩展
- 补码需要进行符号扩展，即在补码的二进制表示的开头添加最高有效位的值

注意：如果变大小与类型转换同时发生，则先改变大小，再进行类型转换

## 2.2.7 截断数字

**原理**：截断无符号数
- 简单的将其高位截断即可，即 $x$ $mod$ $2^k$

**原理**：截断补码数值
- 也是简单的将高位截断，但是结果并不是简单的取模，而是需要重新进行 $B2T$

## 2.2.8 关于有符号数与无符号数的建议

由于存在很多隐式的类型转换，所以很容易出现错误。

所以除非将字看作是位的集合而没有任何数字意义时，无符号数值是非常有用的，如：往一个字中放入描述各种布尔条件的标记时。否则不使用无符号数。

# 2.3 整数运算
---

整数的运算有很大计算机的局限性影响，如：两个正数相加会得出一个负数，而比较表达式 x < y 和比较表达式 x - y < 0 会产生完全不同的结果。

理解计算机运算的细微之处能够帮助程序员编写更加可靠的代码

## 2.3.1 无符号加法

如果有两个非负整数 x,y 满足 $0<=x,y<2^w$ ，则每个数都能表示为 $w$ 位的无符号数字；然而如果计算它们的和，我们就有一个可能的范围：$$0<=x+y<=2^{w+1}-2$$
这表明这个和可能需要 $w+1$ 位。

而编程语言一般支持固定精度的运算，因此 $+^u_w$ 被视为将 $x+y$ 截断为 $w$ 位后的结果(前面学的截断就用上了)，然后再将其看作是一个无符号数即可

**原理**：无符号数加法
- 对满足 $0<=x,y<2^w$ 的 x 和 y 有：
$$x+^u_wy=
\left\{
\begin{matrix}
x+y,x+y<2^w  \\
x+y-2^w,2^w<=x+y<2^{w+1}
\end{matrix}
\right.$$

因为无符号数的截断就是求模运算，而最大也不会超过 $2^{w+1}$ ，所以减去 $2^w$ 即可

**原理**：检测无符号数加法中的溢出
- 设结果为 $s$，则 $s<x$ (或等价的 $s<y$) 时，发生了溢出

可以将无符号数的加法想象为一个 $0$ ~ $2^w-1$ 的钟，首尾相接；所以当溢出时，结果一定比 $x$，$y$ 都小

**原理**：无符号数求反
$$-^u_wx=\left\{
\begin{matrix}
x,x=0  \\
2^w-x,x>0
\end{matrix}
\right.$$

即把 $2^w$ 理解为 $0$ 即可。(将其想象为一个钟)

模数加法形成了一种数学结构：阿贝尔群

## 2.3.2 补码加法

对于无符号数加法，它只可能出现正溢出，但是补码加法既可能会出现正溢出，还可能会出现负溢出

对于 $-2^{w-1}<=x,y<=2^{w-1}-1$ 之内的整数值 $x$ 和 $y$ ，它们的和就在范围 $-2^w<=x+y<=2^w-2$ 之内，想要准确表示同样需要 $w+1$ 位。同无符号数，我们将通过截断来避免数据大小的不断扩张。

**原理**：补码加法
$$x+^t_wy\left\{
\begin{matrix}
x+y-2^w,2^{w-1}<=x+y(正溢出)  \\
x+y,-2^{w-1}<=x+y<2^{w-1}(正常)\\
x+y+2^w,x+y<-2^{w-1}(负溢出)
\end{matrix}
\right.$$


注意：负溢出后的结果一定为正，正溢出的结果一定为负。还可以将其想象为一个种，首尾相接，首就是 $2^{w-1}-1$ ，尾就是 $-2^{w-1}$。

因为正溢出时，一定最高位是 0 ，第二高位是 1；发生一位的截断时，损失了最高位的 0，从加 $2^{w-1}$ 变成了减 $2^{w-1}$，即需要减 $2^w$；
负溢出时，一定最高位是 1，第二位一定是 0 (否则不发生溢出)，当发生一位截断时，都损失了 $-2^w$，即需要加上 $2^w$

可以类比符号扩展，当是负数时，高位补 1 即可，即当负数截断时，可以一直截断 1 直至第二位不是 1，这个过程中结果一直不变。同理，正数时一定是第二位不是 0 才停。则当溢出时，一定一，二位的结果不同。

**原理**：检测补码加法中的溢出
- 设结果为 s，如果 x,y 皆正，s 负则正溢出；如果 x,y 皆负，s 正则负溢出；如果 x,y 不同号，则不可能发生溢出

## 2.3.3 补码的非

**原理**：补码的非
$$-^t_wx\left\{
\begin{matrix}
TMin_w，x=TMin_w\\
-x,x>TMin_w
\end{matrix}
\right.$$

即对于 $TMin_w$ 来说，自己是自己的逆(将 $-2^w$ 当作 0)；否则，对于其他任何的数值 $x$ ，都有 $-x$ 作为其加法的逆

补码的两种快速求逆的方法：
1. 所有位取反，然后加 1
2. 找到最右的 1，然后它左边的全部取反即可

## 2.3.4 无符号乘法

x,y 的范围在 $0$ ~ $2^w-1$ 的范围内，则 x \* y 的范围就在 $0$ ~ $2^{2w}-2^{w+1}+1$ 的范围内，即可能需要 $2w$ 位来表示。但是同加法一样，都是固定大小的，以防止数据不断扩张，所以需要截断为 $w$ 位；我们称之为 $x*_w^uy$

**原理**：无符号数乘法
- 对一个无符号数截断，数值上就等价与计算该值对 $2^w$ 求模
$$x*_w^uy=(x*y)mod2^w$$

## 2.3.5 补码乘法

x,y 的范围在 $-2^{w-1}$ ~ $2^{w-1}-1$ 内，则 x \* y 的范围就在 $-2^{2w-2}+2^{w-1}$ ~ $-2^{2w-2}$ 之间，即可能需要使用 $2w$ 位来表示。但是会同样利用截断来固定大小。因为无符号数和补码的位模式是相同的，所以将补码截断至 $w$ 位就相当于先计算该值(当作无符号数)对 $2^w$ 的模，然后再把无符号数转换为补码

**原理**：补码乘法
$$x*^t_wy=U2T((x*y)mod2^w)$$

**原理**：无符号和补码乘法的位级等价性
$$T2B_w(x*^t_wy)=U2B(x'*^u_wy')$$
$$其中：x,y=B2T_w;x',y'=B2U_w$$

注意：虽然补码和无符号数的完整乘积的位级表示可能不同，但是截断后的乘积的位级表示是相同的

可以利用对应的 **除法**，直接判断乘法是否溢出。(因为除法不会产生溢出，而减法会产生溢出)

## 2.3.6 乘以常数

运算指令的时钟周期：
- 加法，减法，位运算，移位：1 个时钟周期
- 乘法：10 个以上时钟周期
- 除法：30 个以上时钟周期

所以编译器会进行优化：尽量使用移位和加法运算的组合来代替乘以常数因子的乘法

**原理**：乘以 2 的幂
- 即乘以 $2^k$ 就相当于在二进制表示的右侧增加了 $k$ 个零

**原理**：与 2 的幂相乘的无符号乘法
$$x*_w^u2^k=x<<k$$

**原理**：与 2 的幂相乘的补码乘法
$$x*^t_w2^k=x<<k$$

即无论是无符号数还是补码，在乘以 $2^k$ 的常数时，都可以转换为左移 $k$ 位

如果非 2 的幂，就可以化为 2 的幂的和的形式，如：$14 = 2^3+2^2+2^1$，即等于 $(x<<3)+(x<<2)+(x<<1)$；或 $14=2^4-2^1$，即 $(x<<4)-(x<<1)$，这样更加简便。

移位运算和直接乘的表现相同，即使发生了溢出

## 2.3.7 除以 2 的幂

除法也可以利用移位来完成，只不过乘法是左移，而除法是右移

无符号数：利用逻辑右移
补码：利用算术右移

我们定义两个符号 $\lfloor x \rfloor$ 和 $\lceil x \rceil$，分别代表对 $x$ 的向下取整和向上取整；则当 x>=0 ，y > 0 时，结果会是 $\lfloor x/y \rfloor$ ，而当 x<0 ，y>0 时，结果会是 $\lceil x/y \rceil$ ；即它向零取整

**原理**：除以 2 的幂的无符号数
- 逻辑移位：$x>>k$ 产生数值 $\lfloor x/2^k \rfloor$

**原理**：除以 2 的幂的补码除法，向下舍入
- 算术移位：$x>>k$ 产生数值 $\lfloor x/2^k \rfloor$

由于总是向下舍入的，对于负数的情况，和我们在上面定义的符号不同了，我们希望负数是向上舍入的；所以我们需要调整策略来处理负数 $x$ 的除法

**原理**：除以 2 的幂的补码除法，向上舍入
- 我们可以通过在移位之前偏置，来修正这种不合适的舍入
- 算术移位：$(x+(1<<k)-1)>>k$ 产生数值 $\lfloor x/2^k \rfloor$

```
(x<0 ? x+(1<<k)-1 : x) >> k
```

相当于对于负数来说，加上一个不会导致变成下一个整数的数，让其再向下取整即可，因为是除以 $2^k$ ，所以我们加上 $2^k-1$ ，得到的结果向下取整就是目的值了

## 2.3.8 关于整数运算的最后思考

思考：
1. 整数运算，实际上就是一种模运算；因为数字的有限长度限制了结果的取值范围；结果也可能溢出
2. 补码的运算，使用了和无符号数相同的位级运算；即无论是补码还是无符号数，它们都有相同的位级行为

# 2.4 浮点数

浮点数对形如 $V=x*2^y$ 的有理数进行编码，它使用于非常大或非常接近于 $0$ 的数字

IEEE 标准的出现，统一了浮点数的表示和运算

本节将看到 IEEE 浮点格式中数字是如何表示的，还将探讨 **舍入** 的问题
- 舍入：当一个数字不能被准确地表示为这种格式时，就必须向上调整或者向下调整

## 2.4.1 二进制小数

十进制表示小数：$d_md_{m-1}···d_1d_0.d_{-1}d_{-2}···d_{-n}$
$$d=\sum_{i=-n}^m10^i*d_i$$

小数点左边的数字的权是 10 的正幂，得到整数值；小数点右边的数字的权是 10 的负幂，得到小数值

类似，二进制也是这样表示的：$b_mb_{m-1}···b_1b_0.b_{-1}b_{-2}···b_{-n+1}b_{-n}$
$$b=\sum_{i=-n}^m2^i*b_i$$

现在小数点变成了二进制的点，左边数字的权是 2 的正幂，得到整数值；右边数字的权是 2 的负幂，得到小数值

小数点左移一位相当于除以 2 ，向右移一位相当于乘以 2

二进制表示法只能表示能够被写成 $x*2^y$ 的数，其他值只能被近似地表示；增加二进制表示的长度可以提高表示的精度

## 2.4.2 IEEE 浮点表示

由于该形式是固定的($x*2^y$)，所以我们希望通过给定 $x$ 和 $y$ 的值来表示该值。

IEEE 浮点标准：
$$V=(-1)^s*M*2^E$$
即 $(-1)^s*M==x$ ，$2^E==2^y$
- $s$：符号位，即决定该数是负数还是整数(对于 0 的解释单独处理)
- $M$：尾数，是一个二进制的小数
- $E$：阶码，对浮点数进行加权

即浮点数的位有三个字段：
1. 1 位的字段，用于编码符号位 $s$
2. $k$ 位的字段，用于编码阶码 $E$
3. $n$ 位的小数字段，用于编码尾数 $M$

单精度格式($s$ 是最高位，最高地址)：
1. $s$：1 位
2. $k$：8 位
3. $n$：23 位

双精度格式：
1. $s$：1 位
2. $k$：11 位
3. $n$：52 位

即顺序是：符号位 -> 阶码 -> 尾数

根据阶码的值(8 位)，分为三个阶段：以 float 举例
1. 阶码 != 0 且 阶码 != 255：规格化的
2. 阶码 == 0：非规格化的
3. 阶码 == 255：两种情况
	1. 尾数 == 0：无穷大
	2. 尾数 !=0：NaN

分情况讨论：
1. 情况 1：规格化的值
	- 此时，阶码字段被解释为 **偏置** 形式表示的有符号数，即阶码的值为 $E=e-Bias$，$Bias$ 即 **偏置值**，为 $2^{k-1}-1$。由此产生的取值范围就是 $-126$~$127$ (其实是$-127$ ~ $128$，但由于不能是全 0 或 全 1，所以去掉了最大值和最小值；$-128$ ~ $127$ -> $-127$ ~ $128$ -> $-126$~$127$)
	- 小数字段被解释为 $0.f_{n-1}···f_1f_0$，即默认小数点在最高位的左边。尾数的值为 $M=1+f$，即 **隐含的以 1 开头的表示**
	- 这种方法的好处是可以轻松获得一个额外的精度位的表示。既然第一位总是等于 1，那么我们就不需要显式地表示它了；但是它的局限性就是它一定表示的是非零的；规格的目的就是最高位为 1
 2. 情况 2：非规格化的值
	 - 此时，阶码域全为 0，阶码值是 $E=1-Bias$，尾数的值是 $M=f$，即完全是小数字段的值，不包含隐含的开头的 1
	 - 非规格化的第一个用途：提供了一种表示数值 0 的方法，因为使用规格化的时候，我们必须总是使 $M>=1$，因此我们就不能表示 0；注意，浮点数中存在 +0.0 和 -0.0，它们被认为是不同的
	 - 非规格化的另一个用途：表示那些非常接近于 0.0 的数；它们提供了一种属性，即 **逐渐溢出**，其中可能的数值分布均匀地接近于 0.0
  3. 情况 3：特殊值
	- 此时，阶码全为 1；当小数域全为 0 时，得到的值表示无穷，当 $s==0$ 时表示正无穷，当 $s==1$ 时，表示负无穷；
	- 当我们把两个非常大的数相乘，或者除以 0 时，可以用无穷来表示 **溢出** 的结果
	- 当小数域为非零时，结果值被称为 **NaN**，即 **Not a Number**；用于表示未初始化的值或非实数等