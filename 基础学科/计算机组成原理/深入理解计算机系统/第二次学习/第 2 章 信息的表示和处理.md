# 引言
---

计算机存储和处理的信息都以二值信号表示，好处：容易被表示、存储和传输

孤立的位并不是非常有用，所以需要：
1. 多个位组合在一起
2. 以某种解释方式，去解释这些位

三种最重要的数字表示：
1. 无符号数编码：基于传统的二进制表示法，表示大于或等于零的数字
2. 补码编码：表示有符号整数的最常见方式，可以表示为正或负的数字
3. 浮点数编码：表示实数的科学计数法的以 2 为基数的版本

因为计算机是以有限的位+某种解释去表示数字的，所以当结果太大以至于不能表示时，某些运算就会溢出。

浮点数的溢出和整数不同，如它会产生正无穷，但是一组正数的乘积总是正的。而且浮点数不可结合，因为它的精度有限。

# 2.1 信息存储
---

最小可寻址的内存单元：字节(8 位的块)

我们可以将内存视为一个非常大的字节数组，即虚拟内存(实际不是这样的)

存储器空间存放三种信息(这完全在虚拟地址空间内完成的)：
1. 程序数据
2. 指令
3. 控制信息

## 2.1.1 十六进制表示法

由于二进制表示法中，太冗长了，如果我们用十进制表示，但是它和二进制之间的相互转换比较麻烦，所以我们使用十六进制来表示二进制的位模式。

十进制转换到其他进制：除法(除以进制的范围)
其他进制转换到十进制：乘法(乘以自己对应的权重)

## 2.1.2 字数据的大小

字长：即 CPU 一次可以处理的最大长度，它反映在地址上，就是虚拟地址空间的大小。如 32 位和 64 位机器

32 位程序和 64 位程序的区别：在于该程序是如何被编译的，而不是运行时的机器类型。64 位机器可以运行 32 位程序(相当于只用了一半的地址空间罢了)，但是 32 位机器无法运行 64 位程序。

在 c 语言编程中，如果希望对数据准确控制，就需要使用确定大小的整数类型；但是如果希望拥有良好的可移植性，就需要程序对不同数据类型的大小不敏感了。(如当 32 位程序迁移到 64 位时，如果 int 用于存储地址长度，那么就会出现错误)

## 2.1.3 寻址和字节顺序

多字节对象：被存储为连续的字节序列。所以我们需要知道它的起始地址和长度

两种对象内部的排列字节方式(多字节对象才有)：
1. 大端(高尾端)
2. 小端(低尾端)

当是小端时，从右向左读即可(左是低地址时)；大部分 Inter 兼容机都是小端模式

字节顺序其实大部分情况下都是不可见的，除非：
1. 网络传输二进制数据时
2. 阅读编译后的字节序列时
3. 强制类型转换时

编程的建议：
1. 使用 `sizeof(类型)` 而不是使用固定的值
2. 使用 `typedef` 来命名数据类型，即可以改善代码的可读性，也便于之后的类型修改

## 2.1.4 表示字符串

它不记录长度，我们只记录起始地址，然后直至一个以 null (值为 0) 字符结尾时结束。每个字符都由 ASCII 编码。当然，它和大端小端之类的就没有关系了，按顺序一个一个读的。

0x3x -> x：1~9，正好表示十进制的数字 1~9

## 2.1.5 表示代码

两点特殊：
1. 二进制代码几乎不能在不同的机器和操作系统之间移植
2. 它也仅仅是字节序列，没有关于源程序的任何信息

## 2.1.6 布尔代数简介

布尔代数：将逻辑值和二进制联系在一起，即 1 表示 真，0 表示假。如此可以利用 1 和 0 的代数，研究逻辑推理的基本原则。

四种布尔运算：
1. 与
2. 或
3. 非
4. 异或

扩展到位向量的运算：即定义为参数的每个对应位之间的运算

环：一种代数结构，由一个集合和两种二元运算(加法和乘法)组成，且满足一系列公理，如结合律，分配率等

布尔环：集合就是 0 和 1 组成的实数集
1. 加法：异或
2. 乘法：与
3. 或运算

布尔环的加法逆元：是它自己的本身，即 0 ^ 0 = 1 ^ 1 = 0，(a ^ b) ^ a = b

位向量的应用：表示有限的集合(即 0 表示不存在，1 表示存在)

## 2.1.7 C 语言中的位级运算

它支持按位布尔运算，一个常见的用法就是实现掩码运算：
1. 与(0 位置)：置 0
2. 或(1 位置)：置 1
3. 异或(1 位置)：取反

## 2.1.8 C 语言中的逻辑运算

逻辑运算不是位级运算，它认为任何非 0 的都是真，而 0 表示假

而且它会进行短路求值，即第一个参数求值就能确定表达式的结果时，就不会对第二个参数求值

且对任何一个非 0 数，使用两次 !，都会变成 1(1 是真的默认表示数)

## 2.1.9 C 语言中的移位运算

左移：右侧补 0

右移：
1. 逻辑右移(针对无符号数编码)：左侧补 0
2. 算术右移(针对补码编码)：左侧补最高有效位的值

# 2.2 整数表示
---

整数有两种编码方式：
1. 非负数：无符号数
2. 负数、零、正数：补码

一些术语：无符号数和补码指的是十进制下的数值大小
- $B2T_w$：函数，二进制转补码
- $B2U_w$：函数，二进制转无符号数
- $U2B_w$：函数，无符号数转二进制
- $U2T_w$：函数，无符号数转补码
- $T2B_w$：函数，补码转二进制
- $T2U_w$：函数，补码转无符号数
- $TMin_w$：常数，补码的最小值
- $TMax_w$：常数，补码的最大值
- $UMax_w$：常数，无符号数的最大值
- $+^t_w$：操作，补码的加法
- $+^u_w$：操作，无符号数的加法
- $*^t_w$：操作，补码的乘法
- $*^u_w$：操作，无符号数的乘法
- $-^t_w$：操作，补码的取反
- $-^u_w$：操作，无符号数的取反

## 2.2.1 整型数据类型

C 语言只规定了每种类型的最小取值范围

注意一个特点：补码中，负数的范围比正数的范围大 1

## 2.2.2 无符号数的编码

**原理**：无符号数编码的定义
$$B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i$$

即每位的权值，是 $2^{w-1}$，每一位加起来就是无符号数

无符号数的范围：$0$~$2^w-1$

**原理**：无符号数编码具有唯一性

$B=B2U->U2B$

## 2.2.3 补码编码

它和无符号数编码的区别：它将最高有效位解释为负权

**原理**：补码编码的定义
$$B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$$

因为最高位如果是 1 就一定是负数，如果是 0 就一定是正数，所以最高位也被称为符号位

范围：$-2^{w-1}$~$2^{w-1}-1$

**原理**：补码编码的唯一性

$B=B2T->T2B$

## 2.2.4 有符号数和无符号数之间的转换

对于 C 语言来说，强制转换只改变解释方式，不改变位模式

$T2U(x)=B2U(T2B(x))$

即补码转无符号数，就先由 T 转换为 B ，再由 B 转换为 U

所以它们可能有相同的位表示，但是它们的结果可能会不同

如果我们希望结果不变，而位模式可以变：

**原理**：补码转换为无符号数
$$T2U_w(x)=
\left\{
\begin{matrix}
x+2^w,x<0  \\
x,x>=0 
\end{matrix}
\right.
$$

因为最高位由 $-2^{w-1}$ 变为了 $2^{w-1}$

**原理**：无符号数转换为补码
$$U2T_w(u)=
\left\{
\begin{matrix}
u,u<=TMax_w  \\
u-2^w,u>TMax_w
\end{matrix}
\right.
$$

同理，无符号数如果超过了最大值，就说明最高位是 1，则转换为补码时，就需要减去 $2^{w-1}$

总结：在范围 $0$～$TMax_w$ 内，它们的位模式也相同；否则就需要根据情况，加上 $2^{w-1}$ 或 减去 $2^{w-1}$

## 2.2.5 C 语言中的有符号数与无符号数

