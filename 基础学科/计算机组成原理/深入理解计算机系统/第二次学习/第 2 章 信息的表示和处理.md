# 引言
---

计算机存储和处理的信息都以二值信号表示，好处：容易被表示、存储和传输

孤立的位并不是非常有用，所以需要：
1. 多个位组合在一起
2. 以某种解释方式，去解释这些位

三种最重要的数字表示：
1. 无符号数编码：基于传统的二进制表示法，表示大于或等于零的数字
2. 补码编码：表示有符号整数的最常见方式，可以表示为正或负的数字
3. 浮点数编码：表示实数的科学计数法的以 2 为基数的版本

因为计算机是以有限的位+某种解释去表示数字的，所以当结果太大以至于不能表示时，某些运算就会溢出。

浮点数的溢出和整数不同，如它会产生正无穷，但是一组正数的乘积总是正的。而且浮点数不可结合，因为它的精度有限。

# 2.1 信息存储

最小可寻址的内存单元：字节(8 位的块)

我们可以将内存视为一个非常大的字节数组，即虚拟内存(实际不是这样的)

存储器空间存放三种信息(这完全在虚拟地址空间内完成的)：
1. 程序数据
2. 指令
3. 控制信息

## 2.1.1 十六进制表示法

由于二进制表示法中，太冗长了，如果我们用十进制表示，但是它和二进制之间的相互转换比较麻烦，所以我们使用十六进制来表示二进制的位模式。

十进制转换到其他进制：除法(除以进制的范围)
其他进制转换到十进制：乘法(乘以自己对应的权重)

## 2.1.2 字数据的大小

字长：即 CPU 一次可以处理的最大长度，它反映在地址上，就是虚拟地址空间的大小。如 32 位和 64 位机器

32 位程序和 64 位程序的区别：在于该程序是如何被编译的，而不是运行时的机器类型。64 位机器可以运行 32 位程序(相当于只用了一半的地址空间罢了)，但是 32 位机器无法运行 64 位程序。

在 c 语言编程中，如果希望对数据准确控制，就需要使用确定大小的整数类型；但是如果希望拥有良好的可移植性，就需要程序对不同数据类型的大小不敏感了。(如当 32 位程序迁移到 64 位时，如果 int 用于存储地址长度，那么就会出现错误)

## 2.1.3 寻址和字节顺序

多字节对象：被存储为连续的字节序列。所以我们需要知道它的起始地址和长度

两种对象内部的排列字节方式(多字节对象才有)：
1. 大端(高尾端)
2. 小端(低尾端)

当是小端时，从右向左读即可(左是低地址时)；大部分 Inter 兼容机都是小端模式

字节顺序其实大部分情况下都是不可见的，除非：
1. 网络传输二进制数据时
2. 阅读编译后的字节序列时
3. 强制类型转换时

编程的建议：
1. 使用 `sizeof(类型)` 而不是使用固定的值
2. 使用 `typedef` 来命名数据类型，即可以改善代码的可读性，也便于之后的类型修改

## 2.1.4 表示字符串

它不记录长度，我们只记录起始地址，然后直至一个以 null (值为 0) 字符结尾时结束。每个字符都由 ASCII 编码。当然，它和大端小端之类的就没有关系了，按顺序一个一个读的。

0x3x -> x：1~9，正好表示十进制的数字 1~9

## 2.1.5 表示代码

两点特殊：
1. 二进制代码几乎不能在不同的机器和操作系统之间移植
2. 它也仅仅是字节序列，没有关于源程序的任何信息

## 2.1.6 布尔代数简介

布尔代数：将逻辑值和二进制联系在一起，即 1 表示 真，0 表示假。如此可以利用 1 和 0 的代数，研究逻辑推理的基本原则。

四种布尔运算：
1. 与
2. 或
3. 非
4. 异或

扩展到位向量的运算：即定义为参数的每个对应位之间的运算

环：一种代数结构，由一个集合和两种二元运算(加法和乘法)组成，且满足一系列公理，如结合律，分配率等

布尔环：集合就是 0 和 1 组成的实数集
1. 加法：异或
2. 乘法：与
3. 或运算

布尔环的加法逆元：是它自己的本身，即 0 ^ 0 = 1 ^ 1 = 0，(a ^ b) ^ a = b

位向量的应用：表示有限的集合(即 0 表示不存在，1 表示存在)

## 2.1.7 C 语言中的位级运算

它支持按位布尔运算，一个常见的用法就是实现掩码运算：
1. 与(0 位置)：置 0
2. 或(1 位置)：置 1
3. 异或(1 位置)：取反

## 2.1.8 C 语言中的逻辑运算

逻辑运算不是位级运算，它认为任何非 0 的都是真，而 0 表示假

而且它会进行短路求值，即第一个参数求值就能确定表达式的结果时，就不会对第二个参数求值

且对任何一个非 0 数，使用两次 !，都会变成 1(1 是真的默认表示数)

## 2.1.9 C 语言中的移位运算

左移：右侧补 0

右移：
1. 逻辑右移(针对无符号数编码)：左侧补 0
2. 算术右移(针对补码编码)：左侧补最高有效位的值