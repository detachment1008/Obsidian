# 引言
---

学习汇编的好处：
1. 便于理解编译器优化能力，并最大化优化代码的性能
2. 理解程序运行时的行为
3. 了解系统中的漏洞是如何出现的，以及如何防御它们

可以通过逆向工程来找到源代码和对应汇编代码之间的关系

学习方式：注重细节

# 3.1 历史观点
---

两个最著名的处理器厂商：
1. Intel(x86 系列)
2. Amd(amd 系列)

# 3.2 程序编码
---

四种编译优化选项：
- `-Og`：使用会生成符合原始 C 代码整体结构的机器代码的优化等级，便于学习
- `-O1`
- `-O2`
- `-O3`

`gcc` 命令的一整套程序：
1. 预处理器
2. 编译器
3. 汇编器
4. 链接器

## 3.2.1 机器级代码

ISA(Instruction Set Architecture)：指令集架构，用于抽象机器程序的行为
- 即机器的行为都可以用 ISA 来描述，它们的结果一致(虽然实际上干的事情可能不同，如：ISA 是串行，而机器是并行)

虚拟地址：抽象了内存模型
- 我们用虚拟地址，将内存看作一个非常大的字节数组即可(实际上，它们是分块相连的)

汇编代码：就是机器代码(ISA)的文本格式描述

x86_64 能见到，而 C 语言程序员见不到的：
1. 程序计数器：即 PC
2. 整数寄存器：属于标量寄存器
3. 条件码寄存器：记录上次计算的状态信息
4. 向量寄存器：存放多个整数或浮点数(除了它都是标量寄存器)

对于 C 语言中的，无论是向量(数组，结构体)，还是标量(整数，指针等)，都不区分；机器代码之将其看作是一个个字节

程序的内存：
1. 可执行机器代码
2. 操作系统需要的控制信息
3. 过程调用和返回的运行时栈
4. 用户分配的内存块
这些都是在虚拟内存中分配的，操作系统会将这些虚拟内存翻译成实际的物理地址的。这些虚拟地址也不是全合法的，只有一部分是合法的。

一条机器指令也只执行一条非常基本的操作

## 3.2.2 代码示例

`-S` 选项：产生汇编代码，不需要选项参数
`-c` 选项：编译并汇编该代码，产生目标代码文件，同样不需要选项参数

可以发现，机器执行的指令只是一个字节序列，它对应的就是指令的编码，即机器对产生这些指令的源代码一无所知