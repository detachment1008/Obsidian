# 引言
---

学习汇编的好处：
1. 便于理解编译器优化能力，并最大化优化代码的性能
2. 理解程序运行时的行为
3. 了解系统中的漏洞是如何出现的，以及如何防御它们

可以通过逆向工程来找到源代码和对应汇编代码之间的关系

学习方式：注重细节

# 3.1 历史观点
---

两个最著名的处理器厂商：
1. Intel(x86 系列)
2. Amd(amd 系列)

# 3.2 程序编码
---

四种编译优化选项：
- `-Og`：使用会生成符合原始 C 代码整体结构的机器代码的优化等级，便于学习
- `-O1`
- `-O2`
- `-O3`

`gcc` 命令的一整套程序：
1. 预处理器
2. 编译器
3. 汇编器
4. 链接器

## 3.2.1 机器级代码

ISA(Instruction Set Architecture)：指令集架构，用于抽象机器程序的行为
- 即机器的行为都可以用 ISA 来描述，它们的结果一致(虽然实际上干的事情可能不同，如：ISA 是串行，而机器是并行)

虚拟地址：抽象了内存模型
- 我们用虚拟地址，将内存看作一个非常大的字节数组即可(实际上，它们是分块相连的)

汇编代码：就是机器代码(ISA)的文本格式描述

x86_64 能见到，而 C 语言程序员见不到的：
1. 程序计数器：即 PC
2. 整数寄存器：属于标量寄存器
3. 条件码寄存器：记录上次计算的状态信息
4. 向量寄存器：存放多个整数或浮点数(除了它都是标量寄存器)

对于 C 语言中的，无论是向量(数组，结构体)，还是标量(整数，指针等)，都不区分；机器代码之将其看作是一个个字节

程序的内存：
1. 可执行机器代码
2. 操作系统需要的控制信息
3. 过程调用和返回的运行时栈
4. 用户分配的内存块
这些都是在虚拟内存中分配的，操作系统会将这些虚拟内存翻译成实际的物理地址的。这些虚拟地址也不是全合法的，只有一部分是合法的。

一条机器指令也只执行一条非常基本的操作

## 3.2.2 代码示例

`-S` 选项：产生汇编代码，不需要选项参数
`-c` 选项：编译并汇编该代码，产生目标代码文件，同样不需要选项参数

>nvim -- `:%!xxd`

可以发现，机器执行的指令只是一个字节序列，它对应的就是指令的编码，即机器对产生这些指令的源代码一无所知

机器代码的特性：
1. x86_64 的指令长度在 1～15 之间；常用的与操作数少的指令长度就短，不常用或带有多操作数的指令就长
2. 指令设计的方式：将字节可以唯一地解码为机器指令
3. 反汇编器：只根据机器代码文件的二进制字节序列即可，无需访问源代码
4. 反汇编器生成的汇编代码和 GCC 生成的有细微的差别

生成可执行的代码：链接器，且必须有且只有一个 `main` 函数

链接器：
1. 可以将被链接的代码移动位置
2. 需要填上函数调用时匹配的函数的可执行代码的位置
3. 会插入空代码( `nop` )，将函数代码填充为 8 字节的倍数( 64 位程序)，方便更好的放置下一个代码块

## 3.2.3 关于格式的注解

汇编代码：
1. 包含了伪指令：指导汇编器和链接器工作
2. 真正的机器代码

C 语言中插入汇编代码的方法：
1. 用汇编编写整个函数，然后在链接阶段将它们链接在一起
2. 利用 GCC 的特性，直接在 C 程序中嵌入汇编代码

# 3.3 数据格式
---

字：2 字节(16 位)
双字：4 字节(32 位)
四字：8 字节(64 位)

浮点数：
- 单精度：4 字节
- 双精度：8 字节

在 ATT 汇编中，会在指令后使用一个字符的后缀来表明操作数的大小：
- `b`：字节
- `w`：字
- `l`：双字，或单精度
- `q`：四字，或双精度

# 3.4 访问信息
---

首先就是通用寄存器，它在 x86_64 中有 16 个，用于存放整数数据和指针的

即发展历程：`ax`->`eax`->`rax`

16 个寄存器：
- `rax` `rbx` `rcx` `rdx`
- `rdi` `rsi`
- `rdp` `rsp`
- `r8` ... `r15`

虽然一个寄存器是 8 字节的，但是我们可以单独操作一字节，两字节，四字节

两个规则：
1. 单独操作一字节或两字节时，剩下的字节保持不变
2. 单独操作四字节时，会把高位的四字节置 0

最特殊的寄存器：`%rsp`；它是栈指针，指明了栈顶元素

## 3.4.1 操作数指示符

指令一般都会有两类操作数：
1. 源操作数：指明源数据
2. 目的位置：指明在哪里放置结果

源操作数：
1. 立即数
	- 以 `$` 开头，后面跟一个 C 风格的整数
2. 寄存器的值
3. 内存的值

目的位置：
1. 某个寄存器
2. 内存的某个地方

当我们需要从内存中获取源操作数，或者想要将值放置在内存中的某个地方时，需要给出一个内存中的地址，而这个地址有很多种形式，称为寻址模式

最丰富的模式：$Imm(r_b,r_i,s)$：$M[Imm+R[r_b]+R[r_i]*s]$
- 它们之间可以互相任意组合，不必给出完整的表示
- $s$ 是比例因子，它只能取 1，2，4，8

## 3.4.2 数据传送指令

数据传送指令：将数据从一个位置复制到另一个位置的指令。它是最常用的指令。

如果操作的行为相同，只是操作数的大小不同( $b,w,l,q$ )，我们就将这些指令放在一起，称为它们是一个指令类

三个数据传送指令类：`mov`，`movz`，`movs`
1. 在数据传送指令中，给出的立即数一般都是 32 位的补码形式
2. 不允许源数据是内存中的值，目的位置是内存中的位置；即如果需要进行这样的操作，必须经过寄存器的中转

### mov

`mov` 指令类：它后面跟的指明数据大小，同时指明了源操作数和目的位置的大小
- `movb`
- `movw`
- `movl`：相当于零填充的 `movq`
- `movq`
- `movabsq`：它的源操作数是 64 位的立即数形式，它的目的位置一定是一个寄存器

注意：当使用 `movl` 指令时，如果目标位置是一个寄存器，会将寄存器的高 4 字节设置为 0

### movz

`movz` 指令类：它有两个字符分别指明源操作数和目的位置的大小，源一定小于目的，即它是负责将小传送到大的，`z` 表示小操作数用 0 填充至相同大小
- `movzbw`
- `movzbl`
- `movzbq`
- `movzwl`
- `movzwq`

注意：它没有 `movzlq`，因为在 `mov` 指令类中，已经有了 4 字节目的时，以 0 填充寄存器，所以可以使用以寄存器为目的的 `movl` 来代替(一定要以寄存器为目的位置，不能是内存)

### movs

`movs` 指令类：它也是小操作数到大目的位置的，只是它使用小操作数的符号进行填充
- `movsbw`
- `movsbl`
- `movsbq`
- `movswl`
- `movswq`
- `movslq`
- `cltq`：没有操作数(隐含了)

注意：它有 `movslq`，且多了一个 `cltq`，这个指令是只针对于源操作数是 4 字节的 `%eax`，目的位置是 8 字节的 `%rax` 的，即等同于 `movslq %eax,%rax`；

## 3.4.3 数据传送示例

有一些注意事项：
1. 指针实际就是地址，使用时会将指针放在寄存器中，然后使用这个寄存器进行内存寻址
2. 局部变量一般都是放在寄存器中，而不是内存中

## 3.4.4 压入和弹出栈数据

栈是后进先出的，`%rsp` 始终指向着栈顶的元素(似乎没有指向栈底元素的指针)。

入栈和出栈指令(可以有其他大小的操作数，但是此处以 `q` 举例)：
- `pushq`：入栈
	1. 先将 `%rsp` 向下移动 8 个字节
	2. 将数值放入到 `%rsp` 指向的内存中
- `popq`：出栈
	1. 先将 `%rsp` 指向的值传送给目标位置
	2. 将 `%rsp` 的值加上 8

注意：栈都是向小地址方向增长的；我们将小地址定义在下方，所以 `%rsp` 向下移动就是栈在增长

栈只是一种操作方式；对于栈内的元素，我们还是可以利用 `%rsp` 的值进行随机存取的，不一定非要后进先出

# 3.5 算术和逻辑操作
---

因为算术和逻辑运算较多，我们给指令类也分一个类，即下面除了加载有效地址的 `leaq` ，都由四条不同数据大小的指令组成。

共分为四组命令

加载有效地址：它只能操作四字八字节(`q`)
- `leaq S,D`：加载有效地址

一元操作：
- `INC D`：自增 1
- `DEC D`：自减 1
- `NEG D`：取负
- `NOT D`：取补

二元操作：(结果都存储在右边，第一个操作数也是右边)
- `ADD S,D`：加
- `SUB S,D`：减
- `IMUL S,D`：乘
- `XOR S,D`：异或
- `OR S,D`：或
- `AND S,D`：与

移位：
- `SAL k,D`：左移
- `SHL k,D`：左移(等同于 `SAL`)
- `SAR k,D`：算术右移
- `SHR k,D`：逻辑右移

## 3.5.1 加载有效地址

`leaq` 的第一个参数一定是一个内存地址形式，第二个参数一定是一个寄存器

它和 `movq` 命令在参数相同时，运行的结果很相似；唯一的区别就是 `movq` 真的从第一个参数给定的内存地址中取出数值放在第二个参数指定的寄存器中，而 `leaq` 只进行地址计算，然后不从内存中取值，而是将计算得到的地址放入第二个参数指定的寄存器中

它还可以简介的描述普通算术操作，即将几个操作数都看作地址，然后利用 `leaq` 指令得到目标地址(其实不是)。

`leaq` 指令可以执行加法和有限形式的乘法，如果编译很简单的算术表达式，这个指令非常好用。

## 3.5.2 一元和二元操作

一元操作：只有一个操作数，既是源，又是目的，即这个值就不能是立即数了，只能是寄存器或内存。

二元操作：有两个操作数，左边是源，右边既是源，又是目的；所以第一个操作数可以是寄存器，内存，立即数，而第二个操作数由于同时表示目的，只能是寄存器或内存。(如果第二个数是内存的话，由于当源，会从这里取值，又由于当目的，又会向这里赋值)

## 3.5.3 移位操作

移位操作的两个操作数：移位量，被移位的数
- 移位量：只能是立即数或寄存器中的数，**不能是内存**；如果希望使用内存中的值，只能先加载到寄存器中，再使用；寄存器只能是 `%cl` 中的值。

但实际上移位的量只由 `%cl` 中的部分决定，即如果使用了 `salb`，则最多只会左移 7 位，因为一个字节有 8 位，最多移动 7 位；即由 `%cl` 中的低 3 位决定了，剩下了不考虑。

`SAL` 和 `SHL`：分别是算术左移和逻辑左移，它们的功能是相同，都是在右边补 0
`SAR` 和 `SHR`：分别是算术右移和逻辑右移，它们不同，即算术右移补符号，逻辑右移补 0

## 3.5.4 讨论

大多数指令，都既可以用于无符号数运算，也可以用于补码运算，即都当作二进制数看待就可以了。这就是为什么补码运算是目前大多数采用的有符号整数运算的原因之一了。

函数参数：
1. `%rdi`
2. `%rsi`
3. `%rdx`
4. `%rcx`
5. `%r8`
6. `%r9`

函数返回值：
1. `%rax`

## 3.5.5 特殊的算术运算

对于乘法和除法，x86_64 指令集对 128 位数的操作提供支持。即两个 64 位数相乘得 128 位结果和 128 位数除以一个 64 位数，得到一个 64 位数结果和一个 64 位数的余数

如果不使用 128 位乘法，就需要提供两个操作数，即显式的指明存储结果的位置：
- `imul S,D`

对于除法，只有这一种使用方式，即它的被除数一定由 `%rdx` 和 `%rax` 组成的，即使是只使用了部分

大数乘法：
- `imulq S`：有符号数乘法
- `mulq S`：无符号数乘法

之所以需要区分有符号数和无符号数，是因为在符号扩展时有不同的操作

大数乘法的特殊之处：
1. 隐含的一个乘数是 `%rax`
2. 结果存储的位置固定：`%rdx`，`rax`

符号扩展：
- `clto`：即 convert to o，8 字节扩展 16 字节

之前有一个 `cltq` 是 4 字节扩展为 8 字节，都是针对与 `%rax` 的，但是扩展到 16 字节时使用的是：`%rdx`，`%rax`

除法(支持大数)：即除法都是用这个的
- `idivq S`：有符号除法
- `div S`：无符号除法

除法的特殊之处：
1. 被除数：固定为 `%rdx`，`%rax`
2. 结果：还是存储在 `%rdx` ，`rax`
	- `%rdx`：余数
	- `%rax`：商

即乘法有两种，对应正常乘法和大数乘法，根据操作数的个数判定；除法只有一种，标明的是除数的大小，当除数是 8 字节时就说明开始大数除法了；还有一个额外的扩展命令：`clto` 用于 `%rax` 扩展到 `%rdx` 了

# 3.6 控制
---

目前为止，都是只考虑了代码的直线行为。但是 C 语言中有条件、循环、分支等语句，会根据计算结果来选择执行的顺序。

机器代码的控制一般是：
1. 产生测试结果
2. `jump` 指令跳转执行

## 3.6.1 条件码

CPU 维护了一个用单个位表示信息的寄存器：条件码寄存器，它描述了最近一次的算术或逻辑运算的属性

常用的条件码：
1. CF：进位标志
2. ZF：零标志
3. SF：符号标志
4. OF：溢出标志

进位标志描述的是无符号数溢出：因为补码的溢出可能只是溢出到符号位，并没有进位

溢出标志描述的是补码的溢出：正溢出或负溢出

举例：`t=a+b`
- CF：`(unsigned) t < (unsigned) a`，即无符号溢出
- ZF：`t == 0`
- SF：`t < 0`
- OF：`(a < 0 == b < 0) && (t < 0 != a < 0)`，即有符号溢出
	- 两者同号，且结果和数值不同号，就溢出了

对于 [[#3.5 算术和逻辑操作|上文的算术和逻辑运算]] ，只有 `leaq` 指令是不改变任何条件码，其他的都会设置条件码

特殊的：
- `xor`：进位和溢出标志位一定为 0
- `移位`：溢出一定为 0，进位为最后一个被移出的位
- `INC` 和 `DEC`：不会设置进位标志位

还有两类指令(同样都有 `b,w,l,q` 四种状态，只设置条件码而不改变任何其他的寄存器：
- `CMP S1,S2`：基于 `S2 - S1` 设置条件码 
- `TEST S1,S2`：基于 `S1 & S2` 设置条件码

## 3.6.2 访问条件码

条件码通常不会直接读取，一般有三种使用方法：
1. 根据条件，将一个字节全部设置为 0 或 1
2. 根据条件，跳转到程序的某个其他地方
3. 根据条件，传送数据

`SET` 类指令，即根据条件码的某种配合，将一个字节全部设置为 0 或 1；注意，由于确定了数据大小，所以 `set` 指令的后缀表示不同的条件，而不是操作数的大小

这些条件可以相互组合：`n` 在最前面，`e` 在最后面，最多三个
- `g`：greater，大于；针对有符号数
- `a`：above，高于；针对无符号数
- `e`：equal，等于；
- `l`：less，小于；针对有符号数
- `b`：below，低于；针对无符号数
- `n`：not，非
- `s`：signal，符号(是否为负数)；针对有符号数

注意：大于小于或高于低于的命令，都可以用 `n`  和 `e` 之类的找到替代的
- 如：`setg` 等于 `setnle`
- 如：`setae` 等于 `setnb`

有符号数：
- 符号位(SF)
- 溢出位(OF)
- 零位(ZF)

无符号数：
- 进位(CF)
- 零位(ZF)

大多数情况下，机器代码不区分补码和无符号数，除非：
1. 右移(算术和逻辑右移)
2. 乘法和除法(在计算方面)
3. 条件码组合(不同操作数，考虑不同的条件码)

## 3.6.3 跳转指令

跳转指令，即根据不同条件，跳转到程序中的一个全新的位置执行

和 `SET` 类指令相比，多了一个无条件的跳转指令：
- `jmp Label`
- `jpm *Operator`

跳转的目标有两种方式给出：
1. 标号：会在汇编过程中，替换为真实的地址并编于 `jmp` 指令中
2. 操作数：可能存于寄存器中，也可能存于内存中，它之前必须用 `*` 显式的标明

注意：如果是条件跳转(`j + 条件`)，就只能是直接跳转，即通过标号；这些条件都同 `SET` 类指令处给出的条件

## 3.6.4 跳转指令的编码

当有跳转指令时，将它们编写为机器代码时有两种方式(因为地址也会编入到机器代码中)：
1. 相对位移：即利用地址差，进行编写
	1. PC 跳转到下一条指令的位置
	2. 根据相对位移，PC 和这个数相加，得到下一条指令的位置
2. 绝对位移：给出真实的地址

相对位移的好处：
1. 更短的指令：可以使用 1，2，4 字节来编写跳转指令中的地址
2. 更方便的移动代码：即可以随意移动代码块，而不用改变跳转指令编码

## 3.6.5 用条件控制来实现条件分支

对于 `if-else` 这种条件分支，汇编一般使用有条件跳转和无条件跳转结合使用来实现

如果反汇编到 C 语言，就会发现汇编的这种方式就类似于 C 语言的 `goto` 语句(虽然不建议在 C 中使用 `goto` 语句)

一般汇编是这样实现条件分支的：
1. `cmp`
2. `jge`
3. A 部分
4. `ret`
5. B 部分
6. `ret`

## 3.6.6 用条件传送来实现条件分支

上面说的实现条件分支是通过 **条件控制** 的方式的，即通过更改 **PC** ，从而修改代码指令的执行线路实现的；而条件传送是不修改 **PC** 的

方式：相当于条件传送是全部都执行一边，最后根据情况进行取舍。这样做的好处就是符合了现代处理器的流水线式工作；因为条件控制可能会导致预测失败，从而丢弃掉之前的指令工作，从而浪费时间

流水线工作：
1. 内存取指
2. 确定指令类型
3. 内存读取数据
4. 执行算术运算
5. 内存写入数据
6. 更新程序计数器

简单来说，就是不闲着，都工作起来

条件传送指令：`CMOV` 类
- 示例：`cmove S,R`

注意：
1. `S`：不能是立即数
2. `R`：一定是寄存器，所以不需要在指令中指明数据大小了，可以直接根据给出的寄存器推断出指令执行的数据大小
3. 不支持单字节的条件传送

条件传送的限制：
1. 当分支内执行大量运算时，条件传送就得不偿失了，因为它是将每个分支里的内容都计算一遍
2. 当分支内的运算有副作用时(如给全局变量加 1)，就无法使用条件传送了
3. 当某个情况下，某分支无法执行时，就还是不能使用条件传送(如给指针判空，然后操作指针)

所以，条件传送只能用于非常受限制的情况，但是它与现代处理器的运行方式非常契合

## 3.6.7 循环

C 语言有三种循环：
1. `do-while`
2. `while`
3. `for`

汇编通过条件测试和跳转的组合来实现循环的效果

对于 `do-while`：
1. 设置标记
2. 执行内容
3. 进行测试
4. 判断跳转回标记

对于 `while`：它和 `do-while` 不同的是，可能一次都不执行

一般有两种方法翻译 `while` 循环至机器指令：
1. 跳转到中间策略
	1. 先无条件跳转到循环结尾的测试
	2. 然后参照 `do-while` 的方式即可
2. guareded-do 策略(`-O1` 的优化策略)
	1. 先进行条件分支
	2. 如果初始条件不成立，转换为 `do-while` 循环
	3. 如果出时条件成立，直接跳转到循环结束，即不执行循环了

对于 `for` 循环：它实际可以转化为 `while` 循环

即对于 `for` 循环，也是使用和 `while` 同样的方法来执行的

综上，C 语言的循环都可以通过条件分支、条件控制、条件跳转来将循环翻译为机器代码的

## 3.6.8 switch 语句

switch 语句是通过一个整数来进行多重分支执行的，主要是通过 **跳转表** 来实现的

跳转表是一个数组，它存储的是不同代码段的地址：
- 当整数不连续的时候，通过默认值的地址填充
- 当一个整数的代码段为空时，用下一个的代码段填充
- 如果结尾用了 goto，就相当于代码段结束进行了 `jmp`

注意：在开始的时候，会利用减法将最小的跳转整数变成 0，方便数组的跳转；跳转数组时使用 `jmp *Operator` 来进行内存的跳转(可以寄存器或内存)，否则只能进行标号跳转。

跳转表：一种非常好用的实现多重分支方法，它的效率和分支的多少无关，都是只访问一次即可

# 3.7 过程
---

过程就是封装代码：
1. 函数
2. 方法
3. 子例程
4. 处理函数

它对外提供接口，用一组指定的参数和一个可选的返回值实现某种功能

机器指令如何实现过程？假设 P 调用 Q，Q 返回 P：
1. 传递控制：即在 P 中设置 PC 为 Q 的起始地址；返回时，在 Q 中将 PC 设置为 P 调用 Q 后面的那条指令
2. 传递数据：P 需要有向 Q 提供一个或多个参数的能力；Q 必须有能向 P 返回一个值的能力
3. 分配和释放内存：开始时 Q 需要内存以为局部变量分配空间，结束后又需要释放 Q 过程分配的内存

总结有三部分：传输控制，传输数据，内存管理

## 3.7.1 运行时栈

大多数语言在过程调用上，都使用了 **栈帧** 这样的数据结构来实现的

即 P 在调用 Q 的过程中，先将控制和数据信息添加到栈尾；当 P 返回时，这些信息会被释放掉(一般使用 `pushq` 和 `popq` 指令)

流程：当过程 P 调用过程 Q 时，会把返回地址压入栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行，我们把这个地址当作 P 栈帧的一部分；然后 Q 扩展当前栈的边界，分配栈帧所需的空间，大多数都是定长的，但是也有变长的

如果所有局部变量都可以保存在寄存器里，并且该函数不会调用任何其他的函数，那么就不需要栈帧！

## 3.7.2 转移控制

过程调用指令：
1. `call`
2. `ret`

`call` 指令：
1. 将 `call` 下一条指令的地址压入栈中(应该就是此时的 PC 值了)
2. 然后将 PC 设置为给定的地址
	- `Label`：标签
	- `*Operand`：内存或寄存器中存储的

`ret` 指令：
1. 出栈，并将出栈的值设置为 PC 的值

这两个命令只是转移控制，即它没有转移参数，只在栈中存储了 PC 值

## 3.7.3 数据传送

在过程调用时，一般都需要传递参数，而且返回时可能还要包含一个返回值。

传递参数：前六个(整型或指针)使用寄存器传递：
1. `%rdi`
2. `%rsi`
3. `rdx`
4. `%rcx`
5. `r8`
6. `%r9`

如果数据长度大小不是 64 位，可以使用对应寄存器的低位来存储，如：使用 `%edi` 来存储 32 位参数

如果参数长度超过 6 个，就必须使用调用者的栈帧来存储了，即从第 $n$ 个开始依次存储到栈帧中，直到第 $7$ 个；然后再调用 `call` 指令来将下一条指令的地址存入到栈中，即栈顶仍是地址，只是之后的为参数。

如果被调用的函数需要使用到这些参数，就不能将其视为一个栈了，只能进行随机存取的方式获取参数，如：获取第 7 个参数 `movq 8(%rsp), %rax` ，因为当前 `%rsp` 指向地址，只能加 8 来获取。

注意：如果参数被存储到内存的栈帧中，就都当作 8 字节 64 位来存储了，即不会像寄存器一样还区分大小了。

注意：上述获取参数的时候有一个前提，即 `%rsp` 保持不变，即被调用过程没有栈帧，但是如果有栈帧呢，即 `%rsp` 变化了该如何做呢？

## 3.7.4 栈上的局部存储

对于很多情况，如小函数，局部变量只需要存储在寄存器中就可以了，不需要存储到内存中，但是有些情况局部变量也需要存放到内存中：
1. 寄存器不足以存放所有的本地数据
2. 对一个局部变量使用 `&` 符号，因为需要产生地址
3. 当局部变量是数组或结构时

一般当使用栈帧来存储局部变量时：
1. 减小 `%rsp` 来减小栈指针，从而在内存中划出额外的栈帧来存储
2. 局部变量根据 `%rsp` 进行存储
3. 当执行结束后，函数返回的 `ret` 指令之前，加大栈指针 `%rsp` 来释放栈帧

所以栈帧链一般是这样的：
1. 上个函数存储的局部变量
2. 上个函数存储的参数
3. 上个函数调用的下个地址
4. 当前函数局部变量
5. 当前函数存储的参数
6. 当前函数调用的下个地址
...... 如此循环下去

注意：存储局部变量的时候，不需要和参数一样 8 字节对齐(因为 64 位处理器)

## 3.7.5 寄存器中的局部存储空间

过程调用时，寄存器被分为两种：
1. 被调用者保存寄存器
2. 调用者保存寄存器

被调用者保存寄存器：
1. `%rbx`
2. `%rbp`
3. `%r12`~`%r15`

即当 P 调用过程 Q 时，如果 Q 想要使用其中的寄存器，必须先将原始的值压入栈中，然后在返回前从栈中弹出旧值即可

所以对于这些寄存器，调用者无需额外处理，在调用前将值放在这些寄存器中，调用后可以直接使用这些寄存器中的数据

调用者保存寄存器：
- 除了 `%rsp` 寄存器，都是调用者保存寄存器。

这些寄存器被调用者可以随意修改，即如果调用者在函数调用后还希望使用这些寄存器，就需要自己先保存好

总结：
- 被调用者保存寄存器：相当于是自己私有的，使用前先入栈，函数返回后出栈即可；无需担心其他过程会修改这些寄存器
- 调用者保存寄存器：相当于公用的，每次调用过程，就可以通过这些寄存器共享数据了，如：参数、返回值
- `%rsp` 寄存器比较特殊，它用于维护栈帧，公用的

总结一下过程的通用流程，之前说的都是逻辑处理，除了逻辑处理还有些流程处理：
1. **被调用者保存寄存器** 入栈(可选)
2. 减小 `%rsp` ，给当前过程生成栈帧(可选)
3. 逻辑处理 ...；当调用其他过程时：
	1. 将不希望被更改的数据放入被调用者保存寄存器
	2. 通过 **调用者保存寄存器** 传递参数
	3. 如果需要的话，压栈再存储额外参数
	4. 调用
	5. 通过 **调用者保存寄存器** `%rax` 获取返回值，继续执行逻辑
 4. 将返回值移入 **调用者保存寄存器** `%rax`
 5. 增大 `%rsp`，和之前减小的一样大，以回收栈帧(局部变量)
 6. **被调用者保存寄存器** 出栈(可选)
 7. 使用 `ret` 指令，进行过程返回

## 3.7.6 递归过程

正常利用上述机制，保存局部变量，使用被调用者保存寄存器和调用者保存寄存器即可完成

即使是复杂情况，如 P 调用 Q，Q 调用 P ，也可以用上述机制轻松完成

# 3.8 数组分配和访问
---

数组 = 标量数据聚集为更大数据类型的方式

特点：可以产生指向数组中元素的指针，并对这些指针进行运算(如果没有指针，可以直接存储在寄存器中，不存储在内存中)

## 3.8.1 基本原则

对于 `T A[N]`：
1. 在内存中分配了长度为 N，数据大小为 T 的大小的数组
2. 引入标识符 A，即可以用 A 来作为指向数组开头的指针

对于 x86_64 的内存引用指令，非常方便的进行数组的访问：
```
movl (%rdx,%rcx,4),%eax
```

即访问了数组开头为 `%rdx`，索引为 `%rcx`，数据大小为 `4` 的数组元素，并存储在 `%eax` 中

>可以将变量理解为两种情况，指针变量或数据变量；* 就是区分它们的方式，在变量声明处的前面使用

## 3.8.2 指针运算

C 语言允许对指针进行运算，但是会进行大小伸缩：
1. 数据和数据运算->数据
2. 指针和数据运算->指针
	1. 数据先根据指针类型的大小进行扩大
	2. 运算得到新指针
3. 指针和指针运算->数据
	1. 指针和指针运算得到结果
	2. 结果根据指针类型的大小继续收缩

```
// 建议使用
int *t; // 相当于把变量 t 变为指针变量了，它还是 int 类型
int *aray[12]; // 相当于把变量 t 从一维指针变量，变为了二维指针变量；即它存储的 12 个元素就变为了一维指针变量了
// 不建议使用
int* t; // 将变量看作了 int* 类型了；但实际不是的，仍然是 int 类型
```

## 3.8.3 嵌套的数组

对于嵌套数组，位于前面的数组的值是固定的，因为要保证值的连续存储，即二维指针存储的相当于是正常的数组(一维指针)，此时即二维指针的项要和上一个二维指针的数组的最后一个元素地址相接，才能保证值是连续的

**可以想象为一个一维数组；从开头开始，分段将中间的地址再存储起来，再构建为一个数组，即多了一个用于保存分段地址的数组

对于一个 `T D[R][C]` 的二维数组来说：
- `&D[i][j]`：$x_D+L(C•i+j)$
	- $x_D$：二维数组起始地址(即 D)
	- L：数据类型大小
	- C：小数组的最大长度

求地址的通用方法：
1. 确定起始地址
2. 确定数据大小
3. 确定索引(二维数组就加起来，得到一个最终的)，即得到是第几个
4. 将这个索引根据数据大小进行扩大(相当于以字节为单位的地址差了)，然后和起始地址进行计算

## 3.8.4 定长数组

如果是定长数组，编译器能够很好的进行优化：即会将所有数组的操作都转换为指针的操作，用 `do while` 循环代替 `for` 循环。

建议：当我们需要常数作为数组维度或缓冲区大小时，最好通过 `#define` 进行定义

typedef 的用法：
```
typedef <old_type> <new_type>
// 例子
typedef int *ptr; // 注意：ptr 还是 int 类型，不过它是指针类型罢了
typedef int array[N][N]; // 注意：现在 array 还是 int 类型，不过它是一维指针类型，并且有额外的两个维度
```

类型->：
1. 指针类型
2. 数据类型

`*` 用于将类型转换为指针类型，将变量转换为指针变量

## 3.8.5 变长数组

在 ISO C99 之后，引入了一种功能，允许数组维度是表达式
```
int A[expr1][expr2]
```

它既可以当作局部变量，也可以当作函数的参数，只不过 `expr1` 和 `expr2` 如果是参数就一定要在它的前面

这样做会引起性能消耗：无法使用 移位或 `leaq` 命令进行计算了，只能使用乘法，因为这些都只能对立即数进行运算的

# 3.9 异质的数据结构
---
C 允许将两种不同类型的对象组合到一起创建数据类型的机制：
1. `struct`：多个对象集合到一个单位
2. `union`：几种不同的类型来引用一个对象

## 3.9.1 结构

结构的特点：
1. 所有组成部分都存放在内存中的一段连续的区域内，类似可存放不同类型的数组
2. 结构的指针就是结构的起始地址
3. 编译器维护着结构类型的信息，指示着每个字段的字节偏移

`偏移(结构起始地址,数组的索引(如果是数组对象),数组数据类型的大小)`：结构的寻址方式，如果不是数组对象，只需要 `偏移(结构起始地址)` 即可

## 3.9.2 联合

它是一种规避 C 语言的类型系统的方式，即它划分了一块内存，可以以提前声明的任何类型去解释它；当然内存的大小是以声明的最大类型来划分内存的

作用：
1. 在数据结构中，将互斥的两个数据类型放到一个 `union` 中，以减少内存占用
2. 进行不改变位模式的类型转换
	- 如：在进行浮点数和整型转化时，会改变底层的位模式的
	- 但是使用浮点数和整型的 `unicon` 时，就只改变了解释方式，不改变位模式

## 3.9.3 数据对齐

内存对齐很重要，提高了性能，相当于内存换时间吧。

就比如处理器一次拿 8 字节的数据，如果有一个 4 字节的数据跨越了 8 的倍数，那么就需要拿两次才能访问到，浪费了性能。

对齐的原则：$K$ 字节的基本对象的地址必须是 $K$ 的倍数，如：`int` 就必须是 4 的倍数

对于结构体这种复合类型，就需要内部的对象全部内存对齐；首先，结构体的地址必须是 4 的倍数，方便内部对象以偏移地址的方式进行内存对齐，即将结构体的起始地址视为 0 即可(如果有 `long`，就只能是 8 的倍数了)

另外，结构的结尾也需要被填充，以满足 4 的倍数。因为如果结构被声明为数组的类型，就需要以连续的地址存储，如果结尾地址没有被填充，可能在下一个结构被分配内存时，起始地址就不是 4 的倍数了

# 3.10 在机器程序中将控制与数据结合起来
---



