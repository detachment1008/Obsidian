# 引言
---

指令集体系结构(Instruction-Set Architecture)：即 ISA，包含：
- 一个处理器支持的指令
- 指令的字节级编码

不同处理器生产厂商有不同的 ISA，它们互不相同；但是同一个厂商的处理器家族一般都保持着兼容

编译器需要了解的：(不关系指令编码是如何执行的，只知道它可以执行)
1. 允许哪些指令(汇编)
2. 这些指令是如何编码的(汇编和字节级编码的对应关系)

处理器设计者：必须建造出能够执行这些指令(编码后)的处理器

本章将研究如何已知的 ISA 是如何被执行的：看上去是顺序执行的(对于编译器来说)，但实际是流水线执行

本章的过程：
1. 先定义一个简单的指令集，作为处理器实现的运行实例
2. 提供一些数字硬件设计的背景
3. 介绍一种描述硬件系统的语言：HCL(Hardware Control Language)
4. 开始设计处理器了
	1. 先实现一个基于顺序操作的处理器
	2. 创建一个流水线化的处理器
5. 通过工具研究和测试处理器的设计

# 4.1 Y86-64 指令集体系结构
---

首先，定义一个指令集体系结构，包括：
1. 各种状态单元
2. 指令集
3. 编码
4. 编程规范
5. 异常事件处理

## 4.1.1 程序员可见的状态

程序员可见的状态：即指令可以读取或修改的部分
- 通用寄存器
- 条件寄存器
- 程序计数器
- 程序状态
- 内存

## 4.1.2 Y86-64 指令

给出了 Y86_64 的 ISA 中的各个指令和对应编码，它只包括 8 字节的整数操作，编码长度从 1 字节到 10 字节不等

## 4.1.3 指令编码

指令的编码第一个字节表明了指令的类型：
- 高 4 位：代码部分(表示指令类)
- 低 4 位：功能部分(表示指令类中的具体指令)

寄存器有一个标识符，用这个标识符去编码表示寄存器即可
- 因为处理器中有一个小的随机存储器，以寄存器 id 作为地址；所以通过它和寄存器 id 就可以找到对应的寄存器；

如果不需要寄存器，就可以将其设置为 0xF 即可，表示无寄存器

在 x86_64 中，分支跳转使用的是相对地址；在这里我们为了方便，就用绝对地址了；过程调用可能都是绝对地址吧

指令集的一个重要性质：字节编码必须具有唯一的解释
- 所以我们也需要知道代码序列的起始位值

## 4.1.4 Y86-64 异常

状态码 Stat，它有四种状态：
1. AOK：正常操作
2. HLT：遇到 halt 指令
3. ADR：遇到非法地址
4. INS：遇到非法指令

在 Y86-64 中，遇到异常时我们会让处理器简单的停止执行指令；但实际上处理器通常会调用一个 **异常处理程序** ，用来处理指定的某种异常

## 4.1.5 Y86-64 程序

和 X86-64 的一些区别：
1. 它的立即数不能直接用于运算；需要先放到寄存器
2. 在运算的时候，不能直接使用内存中的值；需要先放到寄存器

伪指令：告诉汇编器如何放置等信息

一个程序的内存信息：从小到大
1. 预指令(调用 `main` 函数)
2. 数据
3. 代码(`main` 函数开始)
4. 栈(起始地址很大，然后向小地址方向增长；增长太多就将代码覆盖了)

有一个指令集模拟器(YIS)，可以帮助模拟 Y86-64 的机器代码程序执行

## 4.1.6 一些 Y86-64 指令的详情

对于 `pushq %rsp` 和 `popq %rsp` 这两个指令可能会有歧义，这里 Y86-64 和 X86-64 使用相同的处理：
1. 对于 `pushq %rsp`：原本是先移动 `%rsp`，再压入；但实际上是先记录原先 `%rsp` 的值，然后移动 `%rsp`，再将原先记录的值压入；即对其他没有影响，对于 `%rsp` 压入的是当前的值
2. 对于 `popq %rsp`：很正常，即先将值出栈到 `%rsp`，然后 `%rsp` 再加。

# 4.2 逻辑设计和硬件控制语言 HCL
---

数字系统的三个组成部分：
1. 组合逻辑：用于对位进行操作
2. 存储器单元：用于存储位
3. 时钟信号：控制存储器单元更新

HCL：高级语言描述硬件电路

HDL：硬件描述语言，低级一些；Verilog 就是其中一种语言

我们拥有将 HCL 翻译为 Verilog 的工具！

## 4.2.1 逻辑门

上面说的数字系统的三大部分，计算，存储，时钟信号；逻辑门就是用于计算的

数字系统：主要用于操作数字信号的。计算机可以说就是一种数字系统。

逻辑门的三大运算：
1. 与
2. 或
3. 非

我们用 C 语言中的逻辑运算符表示它们，即：`&&` ，`||`，`!`

为什么不是位运算符呢，即：`&`，`|`，`~`；这是因为逻辑门的两个输入(或一个输入)都是只对单个位的数进行操作的，而不是整个字(一次读取的全部位)

对于逻辑门，一旦一个门的输入变化了，输出也会相应的变化(非常快)

## 4.2.2 组合电路和 HCL 布尔表达式

什么是组合电路？即逻辑门的组合

组合电路的组成限制：
1. 每个逻辑门的输入来源固定：
	1. 系统输入
	2. 存储单元
	3. 其他逻辑门的输出
2. 两个或多个逻辑门的输出不能连在一起，因为它们的结果不一定相同，可能会导致出现错误
3. 组合电路必须是无环的。即不能一个逻辑门的输入经过一系列变化又到了自身的输入，这样也会出现错误的。

多路复用器：一种特殊的组合电路，利用 `s` 可以选择信号：
```
bool out = (s && a) || (!s && b);
```

HCL 和 C 语言表达式的区别：
1. HCL 组合电路是持续计算的，而 C 语言是调用时才计算
2. HCL 只接受 0 或 1，而 C 语言接受任意整数
3. HCL 的逻辑门对所有输入相应变化(同时)，而 C 语言是一个一个的，即它拥有短路求值的特性

## 4.2.3 字级的组合电路和 HCL 整数表达式

我们可以构造更大的组合电路，来对字级的数据进行操作。

字：即一次处理的数据，字长就是位数之和；它是可变的，之前说的 64 位字长是最大字长，在实际的计算中，可以随意的用小字长计算的

如：64 个位级相等组合电路实现字级的组合电路；64 个用一个控制信号的位级多路复用器组合实现字级的复用器组合电路

HCL 情况表达式：
```
word <name> = [
select1 : expr1;
...
selectk : exprk;
]
```

这里是顺序取值，直到第一个取值成功为止；所以一般在最后都是 `1 : expr` 用以表示默认值；而且它的控制信号是不互斥的，但是在实际的多路复用器信号中必须互斥。

重要的组合电路：**算术/逻辑单元**，即 ALU

它有三个标准输入：
1. 数据源1
2. 数据源2
3. 控制输入
	- 应该是两个输入电路，即 2 位的控制信号
	- 2 个控制信号电路可以表示 4 种信号，即控制执行加减乘除运算

## 4.2.4 集合关系

很多情况下，需要用到信号之间做比较的情况，如：两位数产生两个信号
```
bool s1 = code == 2 || code == 3;
bool s2 = code == 1 || code == 3;
```

这里用了十进制表示，看的时候可以看作二进制即可

这里可以用集合的方式表示这种关系：`iexpr in {iexpr1, iexpr2, ..., iexprk}`

示例：
```
bool s1 = code in {2, 3};
bool s0 = code in {1, 3};
```

注意：信号可以理解为有或没有。要将 `code` 理解为这样。

## 4.2.5 存储器和时钟

组合电路只是简单的响应输入，即输入转化为输出，没有输入就没有输出；而时序电路是可以存储状态的，即需要引入按位存储的设备

需要引入的两种存储器设备：
1. 时钟寄存器：即寄存器，存储单个位或字；时钟信号控制寄存器的输入加载
2. 随机访问寄存器：即内存，存储多个字，用地址选择该读或写的字
	- 处理器的虚拟内存系统
	- 寄存器文件

两类寄存器：其实就是两种不同角度的看待，寄存器还是那个寄存器
1. 硬件寄存器：即直接和组合电路输入和输出相连的部分
2. 程序寄存器：指的是寄存器文件，它也存储了寄存器的值；但是可以按址访问

相当于寄存器的值在两个地方都存储了，一个是硬件供组合电路使用，一个是寄存器文件，供外部程序使用

**硬件寄存器** 是如何工作的？它有一个输入和输出，但是大部分的时候，内部都是一个稳定的状态，即此时输出等于它内部的状态；大部分情况下，它是不接收输入的；但是当时钟是高电位的时候，它就接收输入信号了，即此时它内部的状态就等于输入信号了，然后直到下一个时钟高电位时，它内部一直保存着这个状态；

在 Y86-64 处理器中，时钟寄存器保存着程序计数器，条件代码和程序状态

**寄存器文件** 是如何工作的？如：它拥有两个读端口，一个写端口
读端口：
1. 输入地址(寄存器 id)
2. 输出数据
写端口：
1. 输入地址(寄存器 id)
2. 输入数据

它就好像是逻辑电路一样(虽然不是，因为有内部存储)，当输入地址后，等待一段延迟，存储在对应地址的寄存器值就会出现在输出数据的电路上

同硬件寄存器(时钟寄存器)，当时钟上升时，才会去读取写端口的值，也可以故意将地址设置为非法的，从而在时钟上升时也不写如。如果同时读写，那么先写再读。

内存的组成：
1. 控制端口(两个)
	- 读控制
	- 写控制
2. 输入端口(两个)
	- 地址输入
	- 数据输入
3. 输出端口(两个)
	- 数据输出
	- 错误输出
4. 时钟输入(一个)

同理，它也在时钟上升时，才会去读取输入信息

实际中，还会有一个只读存储器，用来读指令

# 4.3 Y86-64 的顺序实现
---

我们首先描述一个 SEQ 处理器！它会在时钟周期上，完成一条完整的指令。

## 4.3.1 将处理组织成阶段

我们可以将所有指令的执行都组织成固定的阶段，从而充分利用硬件的处理器：
1. 取指：即根据 PC 寄存器取出指令，指令为一个字节，前面 4 位表示指令代码，即 `icode`，后面 4 位表示指令功能，即 `ifun` 。之后根据指令，还可以继续取出操作数，如：一个寄存器指示符，或两个寄存器指示符(都是一个字节)，或一个四/八/其他个数的字节的常数(根据 `ifun`)；然后计算它下一条指令的地址 `valP`
2. 译码：即译寄存器指示符字节；译码阶段从寄存器文件读入最多两个操作数(因为只有两个读端口)，得到值 `valA` 和 `valB`
3. 执行：在执行阶段，算术逻辑单元(ALU)要么执行指令指明的操作(`ifun` 指明)，要么计算内存的地址，要么增加或减少栈指针；得到的值为 `valE`；在此期间可以设置条件码，对于条件跳转指令可能还会检验条件码
4. 访存：可以将数据写入内存，或从内存读取数据；读取的话，数据为 `valM`
5. 写回：这个指的是寄存器文件，不是内存；最多可以写两个结果到寄存器文件
6. 更新 PC：将 PC 设置成为下一条指令的地址

现在已经将指令的处理组织成 6 个阶段了，现在的任务就是创建硬件设计，来实现这些阶段，并把它们连接起来

## 4.3.2 SEQ 硬件结构

上述说的都是理论描述，这里给出了具体硬件的结构，用于描述硬件是如何组织的以构造出这样执行指令的结构的

## 4.3.3 SEQ 的时序

一个时钟变化会引发一个经过组合逻辑的流来执行整个指令

SEQ 的实现：
1. 组合逻辑
2. 存储器设备
	- 时钟寄存器
	- 随机访问存储器

组合逻辑：完全不需要时序控制，输入变了输出就变了

我们可以将只读的随机访问存储器看作是组合逻辑一样的操作，输入变了(地址)，输出就变了

但是其他存储器设备就需要用时钟来控制时序了，它们通过一个时钟信号来控制，它触发将新值装载到寄存器，或者将值写到随机访问存储器中；每个时钟周期，程序计数器都会装载新的指令地址；但是只有在整数运算指令时，才会装载条件码寄存器

控制寄存器和内存的时序，即可控制处理器中活动的时序；即都只在时钟上升时变化

原则：从不回读
- 处理器从来不需要为了完成一条指令的执行，而去读由该指令更新了的状态

即时钟上升时会做两个事情：
1. 上一条指令的赋值
2. 当前指令的执行

## 4.3.4 SEQ 阶段的实现

SEQ 的整体详细设计：

### 1.取指阶段

首先，指令(第一个字节)会经由 **Split** 硬件来分成两部分，`icode` 和 `ifun`

`need_regids`：该指令是否需要寄存器
```
bool need_regids = icode in {IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ};
```

一共会产生这些信号：
- `imem_error`：指令地址是否合法
- `instr_valid`：指令是否合法
- `need_regids`：指令是否包含寄存器指示符
- `need_valC`：指令是否包含常数

如果 `need_regids` 为 1，则两个输入寄存器地址 `rA` 和 `rB` 通过后面第一个字节来设置，否则这两个地址被设置为 `0xF` ，表示没有寄存器地址；如果 `need_valC` 为 1，根据是否有 `need_regids` ，从后面第 1-8 或第 2-9 个字节处设置常数 `valC`；而 PC 的结果值 `valP` 就等于 `p + 1 + r + 8i` ，`p` 是原先的值，1 表示指令，`r` 表示是否有寄存器字节，`i` 表示是否有常数

### 2.译码和写回阶段

因为这两个阶段都需要访问寄存器文件，所以将它们放在一起

寄存器文件有四个端口，两个读，两个写；每个端口都有一个地址线和一个数据线，地址线都是输入，读端口数据线输出，写端口数据线输入

A, B 是读
```
word srcA = [
	icode in {IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ} : rA;
	icode in {IPOPQ, IRET} : RRSP;
	1 : RNONE;
]
```

E, M 是写
```
word dstE = [
	icode in {IRRMOVQ} : rB;
	icode in {IIRMOVQ, IOPQ} : rB;
	icode in {IPUSHQ, IPOPQ, ICALL, IRET} : RRSP;
	1 : RNONE;
]
```

### 3.执行阶段

执行阶段就是 ALU 的执行，它可以执行：加，减，与，异或运算

ALU 接受三个控制块：
1. 数据源 A
2. 数据源 B
3. `ifun` 信号

```
word aluA = [
	icode in {IRRMOVQ, IOPQ} : valA;
	icode in {IIRMOVQ, IRMMOVQ, IMRMOVQ} : valC;
	icode in {ICALL, IPUSHQ} : -8;
	icoee in {IRET, IPOPQ} : 8;
]

// 如果是运算类指令，我们就用具体的 ifun 指定的运算模式来进行操作，否则就用加法模式(可见大部分情况下，都是加法模式)
word alufun = [
	icode = IOPQ : ifun;
	1 : ALUADD;
]
```

每次 ALU 运行时，还会产生三个与条件码相关的信号：
1. 零
2. 符号
3. 溢出

但是，我们仅仅希望在执行 `OPq` 指令时才用这些信号重新设置条件码：
```
bool set_cc = icode in {IOPQ};
```

而且，还会有一个 `cond` 硬件单元，用来根据条件码和功能码确定是否进行条件分支或条件数据传送

### 4.访存阶段

该阶段的任务就是读写内存的程序数据部分了

内存有三个模块：
1. 入口模块：
	- 地址输入
	- 数据输入
2. 控制模块：
	- 读取数据
	- 写入数据
3. 出口模块：
	- 数据输出

`valE` 是上一个阶段，ALU 的输出
```
word mem_addr = [
	icode in {IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ} : valE;
	icode in {IPOPQ, IRET} : valA;
]

bool mem_read = icode in {IMRMOVQ, IPUPQ, IRET};
```

当然，如果地址错误等会产生信号 `dmem_error`

最后，还会根据 `icode`，`imem_error`，`instr_valid`，`dmem_error` 信号，计算状态码 `Stat`

### 5.更新 PC 阶段

最后一个阶段，是产生 PC 的新值的

```
word new_pc = [
	icode == ICALL : valC;
	icode == IJXX && Cnd : valC;
	icode == IRET : valM;
	1 : valP;
]
```

### 6.SEQ 小结

它目前唯一的问题，就是太慢了；因为这种方法是顺序执行，不能充分利用硬件单元，每个单元只在整个时钟周期内的一部分时间才被使用