# 引言

勿以浮沙筑高台

心中自有丘壑

# 3.1 历史观点

# 3.2 程序编码

## 3.2.1 机器级代码

两种抽象：
1. 指令集架构。我们认为好像是顺序执行，但实际上它不是的，只是结果相同罢了
2. 内存地址是虚拟地址

一些对 C 语言程序员隐藏的处理器状态：
1. 程序计数器(PC)
2. 整数寄存器(16 个)
3. 条件码寄存器
4. 一组向量寄存器

程序内存：
1. 程序的可执行机器代码
2. 操作系统需要的一些信息
3. 栈
4. 用户分配的内存块

操作系统负责管理虚拟地址空间，将虚拟地址转化为实际处理器中的物理地址

一条机器指令只执行一个非常基本的操作

## 3.2.2 代码示例

## 3.2.3 关于格式的注解

ATT 汇编：贝尔实验室的汇编，gcc 和 objdump 的默认格式
Intel 汇编：需要在 gcc 中加上 -masm=intel 才可以使用

区别：
1. Intel：省略了指示大小的后缀
2. Intel：省略了寄存器前面的 % 符号
3. Intel：用不同的方式描绘内存，如：`QWORD PTR [rbx]`，而 ATT 是 `(%rbx)`
4. 多个操作数时顺序相反：Intel 从右到左，ATT 从左到右

# 3.3 数据格式

从小到大：字节，字，双字，四字

ATT 汇编的大多数指令后面都有一个后缀，表示操作数的大小
- `b` ：字节
- `w` ：字
- `l` ：双字(l 表示 long)
- `q` ：四字

同时，l 也可以表示 8 字节的双精度浮点数
- 一个精度四个字

# 3.4 访问信息

包含 16 个 64 位(四字)的 **通用目的寄存器**
- 存储整数
- 存储指针

它们的名字都以 `%r` 开头，然后跟一个名字
- ax ~ dx
- si，di
- bp，sp
- 8 ~ 15

虽然它包含了四个字，但是我们可以单独操作它的字节，字，双字(仅限低位)

此时剩下的字节会怎样呢？
1. 操作字节和字：保持剩下的字节不变
2. 操作双字：将高位的双字置空

## 3.4.1 操作数指示符

大多数指令都有一个或多个 **操作数**，指示出 **源数据** 和 **放置结果的目的位置**

操作数的种类：
1. 立即数：用来表示常数值，如： `$-577`，`$0x1F`
2. 寄存器：用来表示寄存器中的内容
3. 内存引用：根据地址访问内存中的位置

有很多的寻址模式：
1. 立即数寻址：`$0x11`
2. 寄存器寻址：`$rax`
3. 绝对寻址：`rax`
4. 间接寻址：`(rax)`
5. (基址+偏移量)寻址：`0x11(rax)`
6. 变址寻址1：`(rax, rbx)`
7. 变址寻址2：`0x11(rax, rbx)`
8. 比例变址寻址1：
9. 比例变址寻址2
10. 比例变址寻址3
11. 比例变址寻址4

## 3.4.2 数据传送指令

MOV 类：
1. `movb`
2. `movw`
3. `movl`
4. `movq`

源操作数：立即数，寄存器的值，内存的值
目的操作数：寄存器，内存地址
(传送指令的两个操作数不能都指向内存位置)

(rax, eax, ax, al)
```
movl $0x4050,%eax
movw $bp,$sp
movl (%rdi,%rcx),%al
movb $-17,(%rsp)
movq %rax,-12(%rbp)
```

movq 的局限性：如果源操作数是立即数，只能表示 32 位，然后高位置 0

movabsq ：以任意 64 位立即数值为源操作数，只能以寄存器为目的

MOVZ 类：零扩展数据传送指令

MOVS 类：符号扩展数据传送指令

movq 无法传送 64 位立即数。如果两边大小不同，需要使用 movs 或 movz 来进行传送

## 3.4.3 数据传送实例

## 3.4.4 压入和弹出栈数据

栈：后进先出

```
pushq S == subq $8, %rsp   movq %rbp, (%rsp)
popq  D == movq (%rsp), %rax   addq $8, %rsp
```

栈顶：数组插入和删除元素的那一端(rsp 寄存器)

根据惯例，栈顶画在底部，最下面是 0 地址。在 x86-64 中，栈向低地址方向移动

# 3.5 算术和逻辑运算

大多数操作都分成了指令类，即各自带有不同大小操作数的变种

分为四组：
1. 加载有效地址
2. 一元操作
3. 二元操作
4. 移位

## 3.5.1 加载有效地址

leaq 指令就是 movq 指令的变形：从内存读取数据到寄存器

可以理解为 leaq 是一种语法糖：正常情况下 () 包裹的是根据该地址在内存中的结果，而 leaq 是之计算，不去内存取值

## 3.5.2 一元和二元操作

## 3.5.3 移位操作

移位量可以是一个立即数或单字节的 `$cl` 寄存器中(只能是这个寄存器) 

可以进行算术右移(填符号位)和逻辑右移(填 0)

## 3.5.4 讨论

## 3.5.5 特殊的算术操作

mulq 可以处理 128 位，它只和 %rax 运算，低地址结果存储在 rax，高地址结果存储在 源寄存器

imulq 是有符号数的乘法，mulq 是无符号数的乘法

除法中，给出的是除数

# 3.6 控制

## 3.6.1 条件码

CPU 还维护着一组单个位的条件码寄存器

除了 leaq 指令外，所有指令都会设置条件码

还有两类指令，只设置条件码，不改变其他任何寄存器
1. CMP
2. TEST

## 3.6.2 访问条件码

一般不会直接读取，常用的方法有 3 种：
1. 根据条件码的某种组合，将一个字节设置为 0 或 1
	- SET 指令
2. 根据条件，跳转到程序的某个其他部分
3. 有条件的传送数据

## 3.6.3 跳转指令

## 3.6.4 跳转指令的编码

## 3.6.5 用条件控制来实现条件分支

## 3.6.6 用条件传送来实现条件分支

## 3.6.7 循环

## 3.6.8 switch 语句

# 3.7 过程

过程是一种封装代码的方式，在 C/C++ 中就是函数

它包括以下机制：P->Q
1. 传递控制：程序计数器必须设置为 Q 代码的起始地址，然后返回时设置回 P
2. 传递数据：P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值
3. 分配和释放内存：在开始时，Q 需要为局部变量分配空间，返回前，又必须释放这些存储空间

## 3.7.1 运行时栈

## 3.7.2 转移控制

```
call Label
cal *Operand
ret
```

## 3.7.3 数据传送

## 3.7.4 栈上的局部存储

## 3.7.5 寄存器中的局部存储空间

## 3.7.6 递归过程

# 3.8 数组分配和访问

## 3.8.1 基本原则

## 3.8.2 指针运算

## 3.8.3 嵌套的数组

## 3.8.4 定长数组

## 3.8.5 变长数组

# 3.9 异质的数据结构

## 3.9.1 结构

## 3.9.2 联合

## 3.9.3 数据对齐

# 3.10 在机器级程序中将控制与数据结合起来

## 3.10.1 理解指针

## 3.10.2 应用：使用 GDB 调试器

## 3.10.3 内存越界引用和缓冲区溢出

## 3.10.4 对抗缓冲区溢出攻击

## 3.10.5 支持变长栈帧

# 3.11 浮点代码

## 3.11.1 浮点传送和转换操作

## 3.11.2 过程中的浮点代码

## 3.11.3 浮点运算操作

## 3.11.4 定义和使用浮点常数

## 3.11.5 在浮点代码中使用位级操作

## 3.11.6 浮点比较操作

## 3.11.7 对浮点代码的观察理论

# 3.12 总结