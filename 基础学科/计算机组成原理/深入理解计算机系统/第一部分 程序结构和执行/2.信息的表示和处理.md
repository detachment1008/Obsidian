# 引言
---

为什么使用二进制？
- 更容易被表示、存储和传输

单个的位不是很有用，我们需要结合起来：以表示任何有限集合的元素
1. 有限个位进行组合
2. 加上某种解释

三种最重要的数字表示：
1. 无符号编码：基于传统的二进制表示法，表示大于或等于零的数字
2. 补码：表示有符号整数最常见的方式
3. 浮点数：表示以 2 为基数的实数的科学计数法

我们是用有限个位来对数字进行编码，问题：
- 溢出：当结果太大以至于无法表示时

整数和浮点数不同的性质：
- 整数：无论是否溢出，都有交换律和结合律
- 浮点数：无论是否溢出，都没有结合律(因为它的精度有限)

# 2.1 信息存储
---

一些基本的概念：
1. byte：8 位，最小的可寻址内存单位
2. 虚拟内存：一个非常大的字节数组
3. 地址：字节数组的下标
4. 虚拟地址空间：字节数组下标的取值范围

存储的信息：
1. 程序数据
2. 指令
3. 控制信息

分配和管理内存：完全在虚拟地址空间内完成

## 2.1.1 十六进制表示法
---

对于字节来说想要表示位，二进制的表示过于冗长，十进制和二进制又不好相互转化，所以我们引入了十六进制来表示位模式

二进制和十六进制的相互转化：
- 每四个二进制视为一个十六进制即可

## 2.1.2 字数据的大小

字长： CPU 一次处理的数据的大小(就相当于寄存器的大小)
- 指明指针数据的大小，即虚拟内存空间的大小
- 指针就是地址
- 对于字长 w 位的机器来说，它的访问范围就是 0 ~ $2^w-1$

因为 CPU 一次处理的数据有限，所以如果一次全部用来寻址，那么它的寻址范围就是 CPU 一次处理的数据的范围，这就是字长

32 位程序指的是编译方式，即它只使用 32 位的虚拟内存空间大小，所以 64 位机器也可以运行 32 位机器编译的程序

除了 char ，只有前面加 unsigned 的才是无符号数，否则都是有符号的：
- char 类型的行为不确定

## 2.1.3 寻址和字节顺序

如果一个对象跨越了多个字节：
1. 定义它的起始地址
2. 确定它的大小
3. 定义它内部是如何排列这些字节的
	- 小端法：低尾端，即尾部在小地址
	- 大端法：高尾端，即尾部在大地址

## 2.1.4 表示字符串

字符串：一个以 null 字符结尾的字符数组
- null：编码位为 0

且每个字符都由某个标准编码来表示，常见的是 ASCII 字符码
- 即存储的是编码
- 使用时将这个编码，转换为对应的字符

## 2.1.5 表示代码

从机器的角度来看，程序仅仅是一个字节序列

## 2.1.6 布尔代数简介

它定义的是一种以位为最小单位的运算：
1. 与：都真为真
2. 或：有真为真
3. 非(一元)：假为真
4. 异或：相反为真

## 2.1.7 C 语言中的位级运算

## 2.1.8 C 语言中的逻辑运算

逻辑运算：它针对的是任何一个数，而非位
- 当逻辑运算的单位是一个位时，它才和位运算等级

逻辑运算的另一个特性：
- 从左往右计算，当已经确定结果时，就不会向下继续计算了
- 即如果在逻辑与运算中，左边已经是 false，它就不会再去计算右边，而会直接返回 false

## 2.1.9 C 语言中的移位运算

移位运算：
1. 左移：补 0 即可
2. 右移：有两种方式
	- 逻辑右移：补 0，它是针对 ***无符号*** 数进行的
	- 算术右移：补最高有效位的值，它是针对 ***有符号*** 数进行的

# 2.2 整数表示

整数表示有两种方式：
1. 无符号数：非负数
2. 有符号数：负数 + 零 + 正数

## 2.2.1 整型数据类型

特点：
1. 不同的数据类型，差别仅仅是表示的范围不相同
2. 如果是有符号数，它表示的范围并不是对称的，即负数的范围比正数的取值范围大 1

## 2.2.2 无符号数的编码

直接编码即可

在取值范围内的任何一个数，它都有唯一一个 $w$ 位的值编码

## 2.2.3 补码编码

有符号数通常用补码来进行编码：
1. 正数和负数的加法采用同样的方式进行
2. 每个数都有唯一的补码
3. 表示了范围更广的整数值

有符号数的三种表示方法：最高位都永远表示符号
1. 原码：最高位为符号位，其他位直接编码
2. 反码：
	- 正数：等于原码
	- 负数：先表示出它的绝对值，然后所有位取反
3. 补码：
	- 正数：等于原码
	- 负数：先表示出它的绝对值，然后所有位取反，然后再加 1

注意：计算只针对非符号位
如果有-0的表示，就说明它表示的是这个范围内的最大负数，而非负0

为什么补码表示的有符号数，负数范围比正数范围大 1：
1. 如果把补码看作是无符号数：
	- 正数：补码越大，数越大
	- 负数：补码越大，数越小

```
0000 -> 0
0001 -> 1
0010 -> 2
0011 -> 3
0100 -> 4
0101 -> 5
0110 -> 6
0111 -> 7
1000 -> -8
1001 -> -7
1010 -> -6
1011 -> -5
1100 -> -4
1101 -> -3
1110 -> -2
1111 -> -1

```

## 2.2.4 有符号数和无符号数之间的转换

C 语言允许不同数字数据类型之间做强制转换：
- 即只改变解释方式和长度，不改变存储方式和位值

内容组成：
1. 解释方式
2. 长度
3. 存储方式(大端小端)
4. 内容(位值)

## 2.2.5 C 语言中的有符号数和无符号数

C 语言没有规定有符号数用什么表示，但是几乎所有的机器都使用补码

立即数：通常是有符号的
无符号立即数：在后面加后缀 'u' 或 'U'

运算时：
1. 有符号数与无符号数 -> 有符号数强转为无符号数

## 2.2.6 扩展一个数字的位表示

即小数据类型扩展到大数据类型：这样不会造成数值改变
- 大数值到小数据类型，无法完成

扩展方式：
- 无符号数：零扩展
	- 即在开头加 0 即可
- 补码：符号扩展
	- 在开头加最高有效位的值

## 2.2.7 截断数字

数据类型从大变小：即舍去了它的高位数字(可能是因为小端吧)

截断一个数字可能会改变它的值：溢出的一种形式，即小类型无法装载下大数值了

## 2.2.8 关于有符号数和无符号数的建议

存储数值时：尽量只使用有符号数
希望看作是位的集合而没有任何其他数字含义时：无符号数

# 2.3 整数运算
---

- 在进行运算时，会保证两个数据类型是相同的(不同则进行隐式转换)
- 且结果也仍是这个类型(可能会有溢出)

## 2.3.1 无符号加法

两个 $w$ 位的无符号数字相加:
- 结果的范围是：$0$~$2^{w+1}-2$
- 即结果需要 $w+1$ 位来表示

即当结果的首位是 0，那么结果就是正常的；
如果结果的首位是 1，那么结果就是不正常的

无符号数溢出的判断：
- 当结果大于任何一个加数，没有发生溢出
- 当结果小于其中一个或以上的加数，就发生了溢出

## 2.3.2 补码加法

两个 $w$ 位的有符号数字相加:
- 结果的范围是：$-2^w$~$2^w-2$
- 同无符号数一样，结果需要 $w+1$ 位来表示

因为还是用这个类型来表示结果，则太大或太小就会发生溢出

溢出的两种情况：
- 正溢出：结果大于 $2^{w-1}-1$
- 负溢出：结果小于 $2^w$

检测补码加法中的溢出：
1. 正溢出：两个加数都大于 0，但是结果小于等于 0
2. 负溢出：两个加数都小于 0，但是结果大于等于 0

## 2.3.3 补码的非

即求反加 1

## 2.3.4 无符号数乘法

两个 $w$ 位的无符号数字相乘:
- 结果的范围是：$0$~$(2^{w+1}-1)^2$
- 即结果需要 $2w$ 位来表示

## 2.3.5 补码乘法

两个 $w$ 位的有符号数字相乘:
- 结果的范围是：$(-2^{w-1} * 2^{w-1}-1)$ ~ $(-2^{w-1} * -2^{w-1})$
- 同无符号数一样，结果需要 $2w$ 位来表示

## 2.3.6 乘以常数

整数乘法指令相当慢，所以编译器进行了一项优化：移位和加法的组合来代替常数因子的乘法

移位：
- 左移一个数值，相当于执行一个与 2 相乘的无符号乘法

加法：
- 将常数化作不同的 2 的幂相加的形式，然后移位与加法组合即可

## 2.3.7 除以 2 的幂

在大多数机器上，除法比乘法还要慢

所以我们通过右移来对除以 2 的幂的除法进行优化

无符号数：
- 右移：即逻辑右移，右移一位相当于除以 2

补码：
- 算术右移：因为带有符号，所以使用算术右移的形式来右移，但是右移一位也相当于除以 2

## 2.3.8 关于整数运算的最后思考

整数运算实际上是一种模运算，因为数字的有限字长限制了可能的值的取值范围

补码提供了一种即能表示负数，也能表示正数，且可以实现和无符号数相同的运算

# 2.4 浮点数
---

它涉及非常大的数或非常接近0的数

它是由一个小数和一些表示范围的数组合而成的

## 2.4.1 二进制小数

$$b=\sum_{i=-n}^m2^i*b_i$$

同样的，小数点向左移动一位，表示这个数被 2 除

二进制也不能表示所有的数，它只能表示能够写乘 $x*2^y$ 的数，即只能近似的表示其他数

## 2.4.2 IEEE 浮点数表示

$$V=(-1)^s*2^E*M$$

- s：决定这个数是正数还是负数(一位，直接编码)
- E：对浮点数加权(k位)
- M：是一个二进制的小数(n位)

1. 规格化的值：
	- 阶码：最普遍的情况，即不全为0也不全为1。此时它以偏置值的形式表示，即值需要减去偏置的值(32 位为 127)。
	- 尾数：隐含的以 1 开头表示的小数
2. 非规格化的值：
	- 阶码：全部为 0 时，此时无需减去偏置值，直接将阶码解释为 0
	- 尾数：仍然为隐含的 1 开头的小数部分
3. 特殊值：
	- 阶码：全部为 1 时
	- 尾数：全部为 0 时表示无穷(正负根据符号位 s 来判断)。其他情况被判定为 NaN，即 Not a Number

总结：阶码其实直接被当作无符号数处理了，只是最后还要减去 127。即最小是全0，最大是全 1。所以用全 0 表示 0，全 1 表示无穷。其他情况下，正常考虑尾数结算即可。

偏置量：$2^{k-1}-1$
非规格化的值：区分正零和负零

## 2.4.3 数字示例

表示的值并不是均匀的，越靠近0，表示的数就越多，越远离0，表示的数就越少

## 2.4.4 舍入

四种舍入方式：
- 向偶数舍入：最接近的值舍入，当处于两个数之间时，舍入到结果的最低有效位数字是偶数的数字。
- 向零舍入：靠近 0 的方向舍入
- 向下舍入：向小值舍入
- 向上舍入：向大值舍入

## 2.4.5 浮点运算

阿贝尔群：

## 2.4.6 C 语言中的浮点数

即 float 和 double

