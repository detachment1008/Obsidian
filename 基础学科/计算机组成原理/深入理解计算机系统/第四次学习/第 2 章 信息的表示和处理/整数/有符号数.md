# 存储

原理：补码编码的定义

对向量 $x=[x_{w-1}, x_{w-2}, ..., x_0]$ ：
$$B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$$
最高位也被称为符号位，因为它的权重最大，决定了符号

最小值：
$$TMin_w=-2^{w-1}$$

最大值：
$$TMax_w=\sum_{i=0}^{w-2}2^i=2^{w-1}-1$$

映射：
$$(0,1)^w->(TMin_w, ..., TMax_w)$$

原理：补码编码的唯一性
函数 $B2T_w$ 是一个双射( $T2B_w$ 是它的反函数)

特点：
- 补码的表示范围是不对称的，它一半表示负数，一半表示非负数，所以它的正数比负数少一个
- 最大的无符号数是最大的补码的两倍再加 1

当有符号数为负数时，它的绝对值加上其强制转化为的补码，等于 $2^w$；正数时，它们的数值相同

原理：补码转换为无符号数

$$
T2U_w(x) = \left\{
    \begin{array}{ll}
        x+2^w, &  x < 0 \\
        x, &  x \geq 0
    \end{array}
\right.
$$

原理：补码数的符号扩展
(最前面加符号即可)

当既需要改变大小，又需要类型转换时，先改变大小，再类型转换

原理：截断补码数值
$x'=U2T_k(x\ mod \ 2^k)$
即先看作无符号数，然后截断，然后再转换为补码

# 运算

当一个运算中，既有有符号数，又有无符号数，会将有符号数强制转换为无符号数，然后再做运算

## 加法

原理：补码加法

对满足 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 的整数 $x,y$，有：
$$
x+^t_wy = \left\{
    \begin{array}{ll}
        x+y-2^w, &  2^{w-1}\leq x+y(正溢出) \\
        x+y, &  -2^{w-1}\leq x+y<2^{w-1}(正常) \\
		x+y+2^w, & x+y<-2^{w-1}(负溢出) 
    \end{array}
\right.
$$

原理：检测补码加法中的溢出

对满足 $TMin_w\leq x,y\leq TMax_w$ 的 $x$ 和 $y$ ，令 $s=x+^t_wy$ 。当且仅当 $x>0,y>0$，但 $s\leq 0$ 时，计算 $s$ 发生了正溢出。当且仅当 $x<0,y<0$ 但 $x\geq 0$ 时，计算 $s$ 发生了负溢出

原理：补码的非

对满足 $TMin_w\leq x\leq TMax_w$ 的 $x$，其补码的非 $-^t_wx$ 由下式给出：
$$
-^t_wx = \left\{
    \begin{array}{ll}
        TMin_w, &  x=TMin_w \\
		-x, & x>Tmin_w
    \end{array}
\right.
$$

因为它的取指范围不是对称的，所以在取逆元的时候特殊考虑 $TMin_w$ 即可(还是它自己本身)

获取补码非的小技巧：
- 取反加 1
- 找到右边第一个 1 的位置，然后其左边的全部取反

## 乘法

原理：补码乘法

对满足 $TMin_w\leq x,y\leq TMax_w$ 的 $x,y$ 有：
$$x*_w^ty=U2T_w((x*y)mod2^w)$$

因为乘法中无符号数和补码的位级表示是相同的

原理：无符号和补码乘法的位级等价性
$$T2B_w(x*_w^ty)=U2B_w(x*_x^uy)$$

鉴于在大多数机器上乘法都很慢，所以如果是乘以常数，就可以在编译时进行优化：移位+加法

原理：乘以 2 的幂

左移 $k$ 位等同于 $2^k*x$

原理：与 2 的幂相乘的补码乘法

$$x<<k=x*_w^t2^k$$

可以将倍数化为 2 进制，然后对每一个连续的 1 序列进行处理，假设其中一个连续的 1 的序列是 m~n，则： 
- $(x<<n)+x(x<<(n-1))+...+(x<<m)$
- $(x<<(n+1)-(x<<m))$

## 除法

原理：除以 2 的幂的补码除法，向下舍入

即右移：x >> k

原理：除以 2 的幂的补码除法，向上舍入

(x+(1<<k)-1)>>k