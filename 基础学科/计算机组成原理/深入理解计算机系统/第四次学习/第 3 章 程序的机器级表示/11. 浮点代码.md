# 浮点体系结构

组成：
1. 如何存储和访问浮点数值：浮点寄存器
2. 对浮点数据操作的指令
3. 向函数传递浮点数参数和从函数返回浮点数规则的结果
4. 函数调用过程中保存寄存器的规则：调用者保存和被调用者保存

历史：
1. *SIMD*：单指令多数据，即对多个操作并行模式执行
2. *MMX*：MM 寄存器(64 位)
3. *SSE*：XMM：寄存器(128 位)(16 字节)
4. *AVX*：YMM 寄存器(256 位)(32 字节)
5. *SSE2*：可以对标量数据进行操作，如 XMM 的低 32 位或 YMM 的低 64 位中的单个值
6. *AVX2*：大体上是一样的，命令名称和格式有所不同罢了。编译时，给定命令行参数 `-mavx2` 以生成

浮点寄存器：YMM 256 位
1. 共有 16 个 YMM 寄存器，命名为 `%ymm0~%ymm15`
2. 当需要对低 128 位操作时，命名为 `%xmm0~%xmm15`
3. 参数：`%ymm0~%ymm7` 8 个默认参数
4. 返回值：`%ymm0`
5. 调用者保存：`%ymm8~%ymm15`

# 浮点传送和转换

我们目前只考虑标量的操作，即一个数据

## `vmov` 类

它在内存和浮点寄存器之间互相传送数据，类型大小显示给出：第一个 s 表示 single 单个数据，a 表示 aligned 对齐的
```
ss: float 内存和寄存器之间
sd: double 内存和寄存器之间
aps: 内存之间的 float
apd: 内存之间的 double
```

## `vcvtt` 类

表示浮点数和整数之间的类型转换，`v convert to`：浮点数到整数是截断，即向 0 舍入，目的一定是寄存器
只有浮点数 -> 整数时才加：`to`(`vcvtt`)，否则是：`vcvt`
```
浮点数 -> 整数
ss2si: single 单精度 -> single int
sd2si: single 双精度 -> single int
ss2siq: single 单精度 -> single 四字 int
sd2siq: single 双精度 -> single 四字 int

整数 -> 浮点数(注意：它没有那个 to 了)，它有三个操作数，但是我们可以忽略第二个操作数，让它和第三个操作数相同即可
si2ss: 整数 -> 单精度
si2sd: 整数 -> 双精度
si2ssq: 四字整数 -> 单精度
si2sdq: 四字整数 -> 双精度
```

上述说的只是整数和浮点数之间的互相转换，不涉及浮点数之间的转换

## `vunpacklps`

交叉放置：将两个寄存器的值交叉放置(舍弃掉两个寄存器的高位，以 4 字节为单位交叉放置)，并将结果存储到第三个寄存器中
```
vunpacklps 源1, 源2, 目的
```

## `vcvtps2pd`

将两个低位 `float` 扩展为两个 `double`，注意：它操作的是两个数
```
vcvtps2pd 源, 目的
```

## `vmovddup`

用低位的 `double` 覆盖高位的 `double`
```
vmovddup 源, 目的
```

## `vcvtpd2psx`

将两个 `double` 生成两个 `float` ，并将目标的高位设置为 0
```
vcvtpd2psx 源, 目的
```

现在已经可以这样做了：
```
vcvtsd2ss %xmm0, %xmm0
```

# 函数调用中的浮点代码

它所有寄存器都是调用者保存，即被调用者可以直接覆盖使用

# 浮点运算操作

注意：目的一定是寄存器(`xmm`)

可以有两个源操作数：即不以最后一个目的为操作数了

## `vadds` 类

```
s: 单精度
d: 双精度
```

## `vsubs` 类

```
s: 单精度
d: 双精度
```

## `vmuls` 类

```
s: 单精度
d: 双精度
```

## `vdivs` 类

```
s: 单精度
d: 双精度
```

## `vmaxs` 类

```
s: 单精度
d: 双精度
```

## `vmins` 类

```
s: 单精度
d: 双精度
```

## `sqrts` 类

```
s: 单精度
d: 双精度
```

# 浮点常数

浮点操作不能以立即数为操作数，必须先放到内存中

#  浮点位级操作

## `vxorps`

单精度异或

## `vorps`

双精度异或

## `vandps`

单精度与

## `andps`

双精度与

# 浮点比较

## `ucomis` 类

ucomis S1, S2: S2 - S1
```
s: 单精度比较
d: 双精度比较
```

如果其中有 `NaN`，就会设置偶校验条件码，会认为是比较失败了(Nan 如果纯看数一定是比 0 大的，即比 0 小的一定不是 Nan)

# 更快捷的操作

使用 C 语言的 SIMD 扩展