#  条件码

常用条件码:
```
CF: 进位标志(最高位)，可用于检测无符号溢出
ZF: 零标志，检测最近的操作结果是否为 0
SF: 符号标志，检测最近的操作结果是否为负(即是否有符号)
OF: 溢出标志，即最近的操作是否导致一个有符号数溢出(正溢出或负溢出)
```

举例: `t = a + b;`
```
cf: (unsigned)t < (unsigned)a
zf: t == 0
sf: t < 0
of: (a < 0 == b < 0) && (t < 0 != a < 0)
```

除了 `leaq` 指令，所有算术逻辑运算符会改变条件码，也只有算术逻辑运算符(和只改变条件码的指令)可以改变条件码
- 移位运算: 进位标志会设置为移出的位
- 自增和自减: 不会设置进位标志(默认为有符号数)

# 设置条件码的指令

## `cmp` 类

进行减法操作，但只设置条件码，不改变其他任何寄存器: cmp S1, S2
```
效果: S2 - S1 -> 设置条件码
```

```
cmpb
cmpw
cmpl
cmpq
```

## `test` 类

进行与操作，同上只设置条件码，不改变其他任何寄存器: test S1, S2
```
效果: S2 & S1 -> 设置条件码
```

```
testb
testw
testl
testq
```

# 使用条件码的指令

## 条件设置

### `set` 类

它只操作字节: set D
```
效果: 根据条件，设置 D 的一个字节为 0 或 1(条件是否达成)
```

条件: 
```
e
e: 相等
ne: 不等

s
s: 负数
ns: 非负数

l, g(有符号)
g: 大于
l: 小于
ge: 大于等于
le: 小于等于

b, a(无符号)
a: 高于
b: 低于
ae: 高于等于
be: 低于等于
```
- 它的 l 这些不再表示长字(4 字节)，而是条件；因为 `set` 固定设置一个字节，无论后面给出的是一个寄存器的哪种形式

## 条件跳转

通常用标号指明跳转的目的地址，标号实际就是指令;

或者使用 `*` 号来取地址操作，即给出地址，前面加 `*` 获取其指向的指令(只有 `jmp` 可以这样做)

### `j` 类

```
jmp: 无条件

e
je: 相等
jne: 不等

s
js: 负数
jns: 非负数

l, g
jg: 大于
jge: 大于等于
jl: 小于
jle: 小于等于

b, a
ja: 高于
jae: 高于等于
jb: 低于
jbe: 低于等于
```

跳转地址的编码:
- 绝对地址(链接时给出)
- 相对地址(常用，用一个有符号数表示；链接时不需要改编码)

### 实现条件分支!

对于:
```c
if (expr)
{
}
else
{
}
```

通常的汇编:
```c
if (!expr)
{
	goto false;
}
逻辑1
goto done;
false:
逻辑2
done:
```

即用两次跳转来实现：
第一次：执行 `else` 逻辑
第二次：跳过 `else` 逻辑

基本上来说，就是在每一个程序块前，都判断一下是否执行，不执行就跳转走；当然有的可能用前面的判断结果就可以，即直接 `jmp`

流程: 
1. 代码块前进行判断是否执行
2. 代码块后跳转后续执行

## 条件传送

条件跳转可能预测错误，而条件传送效率更高

### `cmov` 类

只有满足特定的条件，才会传送：cmov S, R
```
效果: S -> R
```

注意：目的一定是寄存器，所以不需要 `b, w, l, q` 来标注大小，大小已经隐式的包含在寄存器命名中了

```
e
cmove
cmovne

s
cmovs
cmovns

l, g
cmovg
vmovge
cmovl
cmovle

b, a
cmova
cmovae
cmovb
cmovbe
```

不能使用条件传送的情况：
- 因为它对两种情况都计算，当一种情况非法时就不可以这样做
- 当条件分支中有大量计算，用条件传送就得不偿失了，不如使用条件跳转

## 循环

### do while

向回跳转：先执行，然后跳转回去重新执行的策略

### while

#### 跳转到中间

do while 的升级，即仍然是 do while 的策略，但是在开头添加一个 `jmp` 直接跳转到 do while 的判断处，然后直接判断即可

#### guarded-do

do while 的升级，即仍然是 do while 的策略，但是在开头添加一个 `if` 判断，成功再进入 do while 执行

### for

for 可以转化为 init + while 循环的形式

### switch

通过一个数组和条件跳转(if)实现的

在数组中存储了所有的 switch 选项，然后根据根据结果进行条件跳转到对应数组中执行逻辑即可

如果有空缺，而数组必须连续，可以跳转到默认项来实现；或者提前用一个 if 筛选走