有一个二进制可执行文件

1. 通常的操作：先 `objdump -d <file>` 进行反汇编是一个好的习惯
2. `gdb <file` 启动 GDB 进行调试
3. 之后通常的操作：在程序中感兴趣的地方附近设置断点，然后单步跟踪程序，并同时查看各个寄存器和内存的值

```
开始和停止：
quit: 退出
run: 运行程序(同时可以给出命令行参数)
kill: 停止程序

断点：
break <function-name>: 在指定函数入口设置断点
break *0x400540: 在指定地址处设置断点
break <line>: (有源码的情况下)在指定行设置断点
delete 1: 删除断点 1
delete: 删除所有断点

执行:非汇编不用加 i，就是以源码的一行为单位了
stepi   : 执行 1 条指令
stepi 4 : 执行 4 条指令
nexti   : 类似于 stepi，只是如果是函数调用会跳过函数
continue: 继续执行
finish  : 运行到当前函数返回

检查代码：
disas: 反汇编当前函数
disas <function-name>: 反汇编指定函数
disas 0x400544: 反汇编位于该地址附近的函数
disas 0x400540, 0x40054d: 反汇编该地址范围内的代码
print /x $rip: 以 16 进制输出程序计数器的值

检查数据：
print $rax: 以十进制输出 %rax 的内容
print /x $rax: 以十六进制输出 %rax 的内容
print /t %rax: 以二进制输出 %rax 的内容
print 0x100: 以十进制输出该数
print /x 555: 以十六进制输出该数
print /x ($rsp+8): 以十六进制输出 %rsp 的内容再加上 8
print *(long *)0x74444444e818: 输出位于该地址的长整数
print *(long *)($rsp + 8): 输出位于地址 %rsp + 8 处的长整数
x/2g 0x7fffffffe18: 检查从该地址开始的双字
x/20b <function-name>: 检查该函数的前 20 个字节

有用的信息
info frame: 当前栈帧的信息
info registers: 寄存器的值
help: 帮助信息
```

总结：
- `$` 不再表示立即数，而是表示寄存器的值(代替了 `%`)，立即数直接打出就可以
- 输出的格式：`print /格式 数`