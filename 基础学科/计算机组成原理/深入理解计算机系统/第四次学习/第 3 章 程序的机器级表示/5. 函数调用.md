函数调用(过程)，有三个机制：
1. PC 需要指向新的位置，并且在执行结束后可以再跳转回来
2. 可以向函数传递参数，并且可以接收参数
3. 可以分配新的内存使用，并且在结束的时候将这块内存进行回收

当需要的空间超过了寄存器可以存放的大小，就会分配内存，即栈帧；如果没有超过就不用分配内存

# 传递控制

## `call`

转移控制，并记录当前的控制以做恢复：call Label / call \**Operand

## `ret`

恢复控制：ret

它们都没有 `b, w, l, q` 这样的控制符，或者一定带的是 `q`；因为一定是 8 字节

栈保存数据，即 `%rsp`，每次调用其他函数之前，都会压入当前下一个指令的地址，用作恢复

# 数据传送

寄存器最多传递 6 个整数参数，剩下的用内存传递
```
%rdi, %rsi, %rdx, %rcx, %r8, %r9
```

内存传递参数：
- 大小一定，都是 8 字节
- 第 7 个参数在栈顶，后面的参数依次排队

这部分内存属于调用者的栈，即调用者的栈存储：
1. 额外参数
2. 返回地址

所以第 7 个参数的位置就是：`%rsp + 8`
- `%rsp` 存储的是返回地址，获取参数时必须越过它；即 `n*8(%rsp)` 获取的就是第 n 个额外参数

# 栈帧

并不是所有情况下都会有栈帧的，比如数据可以全部放在寄存器里就不需要栈帧

需要栈帧的情况：
1. 寄存器不足以存放所有本地数据
2. 对局部变量使用了 `&` 就必须为其产生一个地址
3. 局部变量是数组或结构体，需要通过引用访问到
4. 内部调用其他函数

分配的过程：通过减去 `%rsp` 的值来分配栈帧

## 寄存器中的局部空间

### 被调用者保存寄存器

即被调用者使用前需要暂存，结束后需要再恢复的寄存器：
```
%rbx, %rbp, %r12, %r13, %r14, %r15
```

### 调用者保存寄存器

即任何函数都有可能修改它们，且不进行恢复操作
```
除了 %rsp 和被调用者保存寄存器以外的所有寄存器
```

所以希望调用函数后，不改变的本地值需要放在被调用者保存寄存器当中，或者是栈空间中

分配的栈帧内存：
1. 如果有函数调用(无论多少个)，8 字节
2. 如果在函数调用前，有超过 6 个的局部变量，存放于栈帧中
3. 其他 `&` 等特殊变量

## 递归过程

和调用其他函数一样，没有什么特殊之处