# `leaq`

通过内存的方式计算数值，但不获取内存的值

它可以计算形如：`x + y + s * t` 这样形式的式子

# 一元操作

即它的操作数既是源，又是目的

## `inc`

自增 1:  inc D
```
incb
incw
incl
incq
```

## `dec`

自减 1: dec D
```
decb
decw
decl
decq
```

## `neg`

取负: neg D
```
negb
negw
negl
negq
```

## `not`

取补: not D
```
notb
notw
notl
notq
```

# 二元操作

第一个数是源; 第二个数既是源，又是目的(且是第一个操作数)

## `add`

加: add S, D
```
addb
addw
addl
addq
```

## `sub`

减: sub S, D
```
subb
subw
subl
subq
```

## `imul`

乘: imul S, D
```
imulb
imulw
imull
imulq
```

注意：普通乘法的 `imulq` 有两个操作数，而 8 字节的乘法只有一个操作数

## `xor`

异或: xor S, D
```
xorb
xorw
xorl
xorq
```

## `or`

或: or S, D
```
orb
orw
orl
orq
```

## `and`

与: and S, D
```
andb
andw
andl
andq
```

# 移位

shift (algorighm) left/right

移位的量只能是立即数、`%cl`

## `sal`

算术左移: sal k, D
```
salb
salw
sall
salq
```

## `shl`

逻辑左移(等同于算术左移): shl k, D
```
shlb
shlw
shll
shlq
```

## `sar`

算术右移: sar k, D
```
sarb
sarw
sarl
sarq
```

## `shr`

逻辑右移: shr k, D
```
shrb
shrw
shrl
shrq
```

# 特殊的算术运算

## `imulq`

两个 8 字节的有符号数相乘: imulq S
```
效果: S * R[%rax] -> R[%rdx]:R[%rax]
```

即操作数的其中一个用 `%rax` 保存，结果用 `%rdx` 和 `%rax` 共同保存

## `mulq`

同上，但是是两个 8 字节的无符号数相乘: mulq S
```
效果: S * R[%rax] -> R[%rdx]:R[%rax]
```

因为有符号数和无符号数的乘法结果相同，我猜是为了结果的扩展吧

## `idivq`

除法只有这个单操作数除法，模操作也可以通过它来实现: idivq S
```
效果: R[%rdx]:R[%rax] ➗ S -> R[%rax] ... R[%rdx]
```

## `divq`

无符号的上述操作的版本，决定了输入结果的时候是符号扩展还是零扩展(%rax, %rdx)
```
效果: R[%rdx]:R[%rax] ➗ S -> R[%rax] ... R[%rdx]
```

## `cqto`

convert q to o
- 四字到八字

`%rax` 直接符号扩展为 `R[%rdx]:R[%rax]`，方便对被除数用 `%rax` 就可以表示出来的时候，对 `%rdx` 清除操作；因为只有这一种单操作数的除法操作
```
效果: R[%rax] -> R[%rdx]:R[%rax]
```

注意：只能在有符号除法中使用，因为它是符号扩展；无符号除法可以直接用 0 赋值代替

# 总结

注意：只要是 `l` 类型的指令，且目的是寄存器，就会将其高字节设置为 0，这和 `mov` 指令是没有关系的，这个规则是通用的