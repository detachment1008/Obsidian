# 组织为阶段

1. 取指
2. 译码
3. 执行
4. 访存
5. 写回
6. 更新

指令的功能段：决定了执行阶段的操作
指令的代码段：除了执行阶段的具体操作，剩下的全由它来决定
后面的字节：作为数据，是否被使用由指令的代码段决定

条件的设置由访存阶段设置

# 硬件结构

只有一个时钟寄存器，即存储 `PC`

即只有发射了一个时钟信号，才会引发 `PC` 的改变，从而执行整个指令

组合逻辑：持续接受输入
随机访问寄存器：同组合逻辑
时钟寄存器：只有时钟信号上移，才会接收输入；否则用上次的输入进行输出

原则：从不回读
- 即在指令开始执行之前，就将所有的数据读取了，不再重复读取

执行：可以理解为时钟寄存器被组合逻辑电路所包围，每个周期开始时，组合逻辑中的数据是新数据，会流入到时钟寄存器，从而更新输入；每个周期结束时，组合逻辑中充满了新数据，但是由于时钟信号还未上移，时钟寄存器中存储的还是旧数据。

# 各阶段实现

## 取指阶段

1. 组合逻辑 -> `PC`

	  此时，时钟信号上移，组合逻辑中的数据流入到了时钟寄存器 `PC` 中

2. `PC` -> 内存     `PC` -> `PC` 增加器

	 由于 `PC` 的数据发生更改，输出数据也发生更改；
     首先，数据流入到内存，读取指令
     其次，数据流入到硬件单元，用于增加 `PC` 的值
	
	- `imem_error`: 是否内存地址有误

3. 内存 -> 硬件单元(2 个)

	 由硬件单元 `Split` 分析读取的指令(1 个字节)，产生以下信号

	- `instr_valid`: 是否指令有效
	- `need_regids`: 是否需要寄存器
	- `need_valC`: 是否需要常数

	- `icode`: 指令代码
	- `ifun`：指令功能
	 
	 然后，信号再流入由硬件单元 `Align` ，它分析剩下的 9 个字节，根据是否需要寄存器，产生寄存器数据和常数数据
	 - `rA`: 由硬件单元 `Align` 分析得到的寄存器 1 
	 - `rB`: 由硬件单元 `Align` 分析得到的寄存器 2 
	 - `valC`: 由硬件单元 `Align` 分析得到的常数数据

如：`need_regids`
- `I`: `I` 开头，表示是一个数；后面给出的是对应的指令
```
bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ};
```

4. 硬件单元(`Split`) -> `PC` 增加器

	 `PC` 增加器由第二步给出的 `PC` 值，和第三步计算得到的信号，计算要增加的值，然后得到下一个指令的地址
	 - `valP`: 由硬件单元计算得到的新的 `PC` 值

## 译码和写回阶段

因为它们都是访问寄存器文件的操作，所以放在一起

寄存器文件一共有 4 个端口，两个读，两个写，每个端口都有一个地址线和一个数据线，读的端口数据线向外，写的端口数据线向内

译码：进行读操作，只需要一个寄存器的输入即可，根据 `icode` 决定寄存器的值
```
word srcA = [
	icode in { IRRMOVQ, IRMOVQ, IOPQ, IPUSHQ }: rA;
	icode in { IPOPQ, IRET }: RRSP;
	1: RNONE;
];

word srcB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ }: rB;
    1: RNONE;
];
```

写回：即向寄存器文件中写入数据，需要根据 `icode` 获取寄存器 `id` 和对应写入的数据
```
word dstE = [
	icode in { IRRMOVQ }: rB;
	icode in { IIRMOVQ, IOPQ }: rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET }: RRSP;
	1: RNONE;
];
```
- `dstE`: 表示写端口 `E` 的寄存器

## 执行阶段

主要是根据 `icode` 确定数据，根据 `ifun` 确定对 `aluA`, `aluB` 执行什么运算

该过程会产生条件码

```
word aluA = [
	icode in { IRRMOVQ, IOPQ }: valA;
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ }: valC;
	icode in { ICALL, IPUSHQ }: -8
	icode in { IRET, IPOPQ }: 8;
	# 其他的不需要计算
];
```
- 因为写入的值一定是 `valE`；即 `Alu` 计算的结果，所以只要有写入，就将该值加 0 即可，即一定需要参与运算

```
word alufun = [
	icode == IOPQ: ifun;
	1: ALUADD;
];
```
- 只要不是运算指令，都当作加法来处理(如：加 0)

每次运算都会产生条件码，但是我们希望仅仅是在运算后才使用该值；所以我们用另外一个信号来判断条件码是否有效
```
bool set_cc = icode in { IOPQ };
```

`cond` 硬件单元：会根据 `ifun` 和功能码来判断是否进行跳转，如果进行跳转就置为 1

## 访存阶段

就是读写内存

输入分为 4 块：
1. 内存地址
2. 内存输入
3. 读控制
4. 写控制

输出分为 2 块：
1. 输出数据(`valM`)
2. 状态码(`dmem_error`)

```
word mem_addr = [
	icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ }: valE;
	icode in { IPOPQ, IRET }: valA;
	# 其他的不需要读写内存
];
```

## 更新 PC 阶段

```
word new_pc = [
	icode == ICALL: valC;
	icode == IJXX && Cnd: valC;
	icode == IRET: valM;
	1: valP;
];
```