# 流水线说明

## 优点

将一个指令的整个阶段划分，每个阶段之间用流水线寄存器分隔开；这样每个周期都能输出一个指令，即降低了时钟周期提升了效率

## 缺点

划分时，会引入新的额外消耗

### 1. 不一致的划分

周期的时间是最长的那个阶段的执行时间

### 2. 流水线过深

流水线过深，收益反而下降了

# 流水线反馈说明

可以将各个阶段都理解为一条指令，后面的阶段内部的指令在前面阶段指令的前面

而相邻指令可能是有关联的，即第二条指令需要用到第一条指令的数据，所以需要后面阶段将数据传递给前面阶段的操作，这种操作就是：反馈

相邻指令的关联：
1. 数据相关(反馈传递数据)
2. 控制相关(反馈传递条件码)

# 流水线总览

## 预览图

![[DJ{X5@VXJ]@CR{807_5VMNL.png]]

## 预先操作

1. 将 PC 的计算移动到取指阶段，结果直接导入到自己的输入
2. 在各个阶段之前，加上流水线寄存器

## 数据冒险

只需要处理寄存器数据冒险就可以了
- 因为内存的读写都在一个阶段里，前后指令一定不同

一些解决办法：
1. 暂停(通过插入 `nop` 指令)：暂停在译码阶段之前，等待上一个通过了写回阶段
	- 保持  `PC` 值不变
	- 在执行阶段插入一个气泡
1. 转发(后面的阶段直接将数据发送给前面的阶段)
	- 五个转发源：`e_valE`, `m_valM`, `M_valE`, `W_valM`, `W_valE`
	- 两个转发目的：`valA`, `valB`
1. 加载/使用数据冒险(无法转发时的操作)
2. 避免控制冒险

## 控制冒险

解决办法：
1. 预测：永远预测选择了条件分支(除了 `ret`)
2. 暂停：对于 `ret`，无法预测，所以简单的暂停即可

`Predict PC`：从自增的 `valP` 和预测的 `valC` 中选择一个即可

## 异常处理

三种异常：
1. `halt` 指令
2. 非法指令和功能码结合的指令
3. 取指或读写内存时访问非法地址

原则：
1. 流水线越深，异常的优先级越高(越早引起异常)
2. 分支预测错误引起的异常可以取消

# 流水线各个阶段的实现

## F: PC 选择与取指

PC 的选择使用预测技术，输入三个数据：
1. `valC`
2. `valP`
3. `icode`

```
// 选择的值
word f_pc = [
	M_icode == IJXX && !M_Cnd: M_valA;
	W_icode == IRET: W_valM;
	1: F_predPC;
];
// 当之前的有跳转但是没有跳转时，此时说明预测错了，用自增的值覆盖(valP 存储在 M_valA); 执行阶段完成后才知道是否要跳转
// 当之前的指令是 RET 时，它会从内存中读取地址值，即 W_valM
// 否则，就用预测的值吧

// 预测的值
word f_predPC = [
	f_icode in { IJXX, ICALL }: f_valC;
	1: f_valP;
];
```

相当于有三块：组合逻辑，流水线寄存器，预测值

预测值永远预测中，组合逻辑进行判断，流水线寄存器只是分割

总结：
1. 一个硬件始终预测，并放在流水线寄存器里
2. 使用时先判断之前是否有跳转，且不跳转的；如果有就说明之前预测错了，用当时存储的 `valP` 继续
3. 如果之前有 `ret` 就说明之前没预测，就用它从内存中取出来的值做地址
4. 用预测的值

## D: 译码与写回阶段

合并：它会将 `valA` 和 `valP` 的值进行合并，因为只有 `call` 和跳转指令才可能会用到 `valP`(预测错误)，且这些指令不需要寄存器 `rA`，所以合并就可以了
```
word d_valA = [
	D_icode in { ICALL, IJXX }: D_valP;
	d_srcA == e_dstE: e_valE;
	d_srcA == M_dstM: m_valM;
	d_srcA == M_dstE: M_valE;
	d_srcA == W_dstM: W_valM;
	d_srcA == W_dstE: W_valE;
	1: d_rvalA;
];
// 当为跳转指令的时候，为了防止预测错误，使用 D_valP
// ---------------- 以下，都是说的寄存器 rA 取的值 ----------------------------
// 当读取的源地址和执行阶段后的写入源地址相同，就可以直接用了(上一条指令)
// 当读取的源地址和访存阶段后的写入源地址相同，就可以直接用了(上两条指令)
// 同上，只是另一个端口(上两条指令)
// 当和写回时相同时，直接用值就可以了(上三条指令)
// 同上，只是另一个端口(上三条指令)
```
- `src`: 表示读的地址
- `dst`: 表示写的地址
- `val`: 表示值
- `A, B`: 表示读取时的端口
- `E, M`: 表示写入时的端口

即防止数据冒险，用了反馈；从近到远依次考虑，即写回，访存，执行；当已经产生了结果，但是还没有处理的时候，我们就可以直接拿了

 考虑了两个端口，是为了避免 `pop %rsp` 的情况发生，此时它会写回两个值，但是我们需要的是第二次写回的值，所以用了端口 `M` 而非 `E`；不然我们只需要考虑一个写入端口就可以了（没错，就是 `E`）

总结：每次取值的时候，都先考虑写入的时候的值最早是什么时候就得到了，如果更早就得到了只是没有写，就从前面找找是否有已经得到结果，但是还没有写入的，如果有就直接用这个值，否则就老老实实查寄存器了

写回时，就需要把状态码写入了：
```
word Stat = [
	W_stat = SBUB: SAOK; // 如果当前指令是气泡，说明刚刚的指令是预测错了的；状态就重置为 SAOK
	1: W_stat;
];
```

## E: 执行阶段

`valA` 或 `valC` 和 `valB` 相加

如果前面的指令已经导致异常了，就不要覆盖了：`m_stat` 和 `W_stat` 有值，就不设置条件码了

## M: 访存阶段

# 流水线控制逻辑