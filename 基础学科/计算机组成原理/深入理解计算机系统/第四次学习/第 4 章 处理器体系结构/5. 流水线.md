# 流水线说明

## 优点

将一个指令的整个阶段划分，每个阶段之间用流水线寄存器分隔开；这样每个周期都能输出一个指令，即降低了时钟周期提升了效率

## 缺点

划分时，会引入新的额外消耗

### 1. 不一致的划分

周期的时间是最长的那个阶段的执行时间

### 2. 流水线过深

流水线过深，收益反而下降了

# 流水线反馈说明

可以将各个阶段都理解为一条指令，后面的阶段内部的指令在前面阶段指令的前面

而相邻指令可能是有关联的，即第二条指令需要用到第一条指令的数据，所以需要后面阶段将数据传递给前面阶段的操作，这种操作就是：反馈

相邻指令的关联：
1. 数据相关(反馈传递数据)
2. 控制相关(反馈传递条件码)

# 流水线总览

## 预览图

![[DJ{X5@VXJ]@CR{807_5VMNL.png]]

## 预先操作

1. 将 PC 的计算移动到取指阶段，结果直接导入到自己的输入
2. 在各个阶段之前，加上流水线寄存器

## 数据冒险

只需要处理寄存器数据冒险就可以了
- 因为内存的读写都在一个阶段里，前后指令一定不同

一些解决办法：
1. 暂停(通过插入 `nop` 指令)：暂停在译码阶段之前，等待上一个通过了写回阶段
	- 保持  `PC` 值不变
	- 在执行阶段插入一个气泡
1. 转发(后面的阶段直接将数据发送给前面的阶段)
	- 五个转发源：`e_valE`, `m_valM`, `M_valE`, `W_valM`, `W_valE`
	- 两个转发目的：`valA`, `valB`
1. 加载/使用数据冒险(无法转发时的操作)
2. 避免控制冒险

## 控制冒险

解决办法：
1. 预测：永远预测选择了条件分支(除了 `ret`)
2. 暂停：对于 `ret`，无法预测，所以简单的暂停即可

`Predict PC`：从自增的 `valP` 和预测的 `valC` 中选择一个即可

## 异常处理

三种异常：
1. `halt` 指令
2. 非法指令和功能码结合的指令
3. 取指或读写内存时访问非法地址

原则：
1. 流水线越深，异常的优先级越高(越早引起异常)
2. 分支预测错误引起的异常可以取消

# 流水线各个阶段的实现