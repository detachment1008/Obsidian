之前的 SEQ 顺序实现，只在 PC 处使用了时钟寄存器(条件、寄存器文件、内存默认使用)，相当于只有整个流程走完了，才会再次更新 PC 这个时钟寄存器；而现在是在每个阶段前都加上一个时钟寄存器，每执行完一个阶段，就更新一次这个时钟寄存器

注意：数据流入时钟寄存器也存在消耗，但是消耗+当前消耗小于顺序执行时的所有消耗即可

局限性：
1. 因为时钟周期由最慢的阶段决定，所以当存在不一致的划分时会延迟
2. 流水线过深会增加执行单个指令的开销，且增加了冒险的可能性

反馈：即将后一个阶段的数据传递给前面的阶段，在 SEQ 中就是这样设计的

流水线的两个问题：
1. 数据相关
	- 当下一条指令使用上一条指令的数据时，相当于仅比它晚了一个阶段，而寄存器是在第二个阶段译码获取，在第五个阶段写回再写入，会出现问题；而访存在第四个阶段获取，第四个阶段写入是没问题的
	- 相当于有一个动作是拿，处理，放回；如果我在处理的时候拿就有问题了，但是内存是拿或放回，即只有一步，所以不会有冲突
	- 如果我的整个操作是 3 步，就可能在这中间存在冲突，而如果只有一步不可分割，就没问题
2. 控制相关
	- 同样，在拿时是第一个阶段取指，而放回是在第六个阶段更新 PC，所以在这中间的都会有冲突；且只有在执行阶段或访存阶段(`ret`)后才知道结果

所以必须处理寄存器相关的冲突和 PC 相关的冲突