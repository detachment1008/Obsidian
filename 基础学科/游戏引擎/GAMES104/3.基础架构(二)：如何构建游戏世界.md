# 3.1 如何描述一个游戏世界
---

## 3.1.1 游戏对象

我们把游戏世界中的物体，都统称为 Game Object (go)

我们通过 go 来管理游戏世界中的所有物体

### 3.1.1.1 动态游戏对象

动态游戏对象：即 Dynamic Game Objects，就是游戏世界中可以交互的物体

### 3.1.1.2 静态游戏对象

静态游戏对象：即 Static Game objects，即游戏世界中不可交互的物体

### 3.1.1.3 环境

环境分为好多种类：
1. 天空：如，阴天晴天，云彩，下雨……
2. 植被：量特别大，平常不动但也有交互
3. 地形：通常被作为一个系统来处理，即地形系统

### 3.1.1.4 其他游戏对象

还有一些看不见的游戏对象：
1. 空气墙
2. 触发器
3. 寻路网格

## 3.1.2 组件

我们用游戏对象去描述游戏世界，我们又由什么去描述各种不同的游戏对象呢

### 3.1.2.1 纯面向对象描述

我们给每一个 go 都赋予属性和行为，再通过派生的方式来实现

缺点：发展到后面，不同的 go 可能没有明显的父子关系了

### 3.1.2.1 组件 + 面向对象描述

组件定义行为

我们通过给 go 添加不同的组件，定义其行为

我们可以用面向对象的思想，定义各种各样的组件，从而实现行为的模块化

## 3.1.3 总结

1. 游戏世界由各种各样的 go 描述，它是游戏世界的最小单位
2. go 由各种各样的 component 描述，component 又是 go 的最小单位

# 3.2 如何让游戏世界活起来
---

众所周知，我们推动游戏世界的方法是通过 tick 函数

所以，每个 component 都有一个 tick 函数

## 3.2.1 tick 调用的方式

1. 以游戏对象顺序来调用 tick
	- 需要再次规定 tick 的调用顺序，因为游戏对象就是一个 component 数组，有些 conponent 的 tick 调用是有先后顺序的
	- 不同游戏对象可能会有相同的 component，但是它们相同的 component 上的 tick 不是同时调用的
2. 以 component 为顺序来调用 tick
	- 首先，自然而然的解决了 tick 调用顺序的问题
	- 其次，同一类型的 component 同时调用 tick，即对同一块内存进行读写，效率高

## 3.2.2 游戏对象之间的交互

### 3.2.2.1 Hardcode：硬编码方式

如：直接搜索目标游戏对象，然后进行信息传递

- 当游戏世界变的越来越复杂的时候，这种方式就不适用了
- 因为需要知道所有交互的游戏对象，包括其类型，甚至包括其 component 的类型，这太复杂了


### 3.2.2.2 **Event**：事件机制

- 相当于有很多邮箱，里面可以存储信息
- 当需要交互的时候，源游戏对象向一个邮箱内发送信息
- 目标游戏对象在每一个 tick 前都检查一下这个邮箱，如果有信息，就开始处理交互了

现代游戏引擎很重要的一个功能，就是可扩展的消息类型(相当于游戏)，并可针对消息类型自定义处理逻辑

# 3.3 如何管理游戏对象
---

## 3.3.1 场景

### 3.3.1.1 场景管理方式

每个场景管理一批游戏对象

定义游戏对象的查询方式：
- 通过 id：每个游戏对象都有独一无二的 id
- 通过 position：根据游戏对象在场景中的位置来查询

这两种方式通常都是结合起来使用的

### 3.3.1.2 场景分割

1. 空间划分：相当于划格子，每个格子都被划分到一组
	- 可以根据情况，不均匀的分割空间
	- 目的是在不同空间内，游戏对象的数量基本保持一致
	- 常用算法：八叉树，kd-Tree 算法等
1. 分层划分：将场景从整体到局部的分解方法
	- 反向来看：最初它以游戏对象为单位，一层一层的进行分组合并，直至最终只有一个组，即场景
	- 常用算法：BVH 算法

# 3.4 其他需要处理的复杂情况
---

## 3.4.1 游戏对象绑定

即一个游戏对象跟随另一个游戏对象移动

需要保证一个游戏对象的 tick 在另一个游戏对象的 tick 之前进行

## 3.4.2 再探消息管理机制

我们不能直接让游戏对象给另一个游戏对象发送数据，即使是邮箱，这会导致时序问题，即它们同时互相发送数据

我们需要引入一个"邮局“的概念，发送数据都发送到邮局，由它再分发给游戏对象的邮箱，通过邮局来保证消息的时序正确

## 3.4.3 组件的依赖关系

可能会发生循环依赖

有些游戏可能会用几帧的延迟操作，来进行这种循环依赖的处理

