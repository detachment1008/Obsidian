# 介绍
---

现代游戏引擎的一种简单分层(5+1)
- 工具层
- 功能层
- 资源层
- 核心层
- 平台层
> 第三方软件(SDK：编译，然后集成在软件中的某一层)(在外部使用)

# 2.1 资源层
---

获取并管理资源，为上层提供资源的支持

## 2.1.1 资产的生成：导入

处理各种不同格式的资源，并转换为引擎中的资产(asset)：resource -> asset

原因：
- 我们需要统一格式方便管理
	- 不同来源的资源格式可能不同
	- 其他来源的资源格式，可能不适用于引擎使用
- 我们需要剔除资源的冗余信息
	- 其他来源的资源格式，可能会有冗余的信息

## 2.1.2 资产的整合

有些资产它们之间是互相关联的，如：一个机器人，它可能有网格资源，贴图资源，动画资源……

我们需要再创建一个新的资源，它记录了对于这个物体来说这些资产的关联信息

## 2.1.3 资产的唯一识别号

为了区分资产，我们给每个资产都生成一个唯一识别号：guid

## 2.1.4 资产管理器

- 相当于一个虚拟的文件系统，通过路径去加载或卸载资产
	- 即管理资产的生命周期，非常重要
- **handle system**

# 2.2 功能层

基础原理：人类依靠视觉残留感知连续的世界

## 2.2.1 tick

tick：我们在游戏世界中，构建的普朗克时间，也被称作帧

我们通过推动 tick，来推动游戏世界中的前进

## 2.2.2 tickLogic

- tickLogic：逻辑计算，即世界的模拟

## 2.2.3 tickRender

- tickRender：渲染，即物理世界的加载

## 2.2.4 区分游戏和游戏引擎

有些通用的功能，是属于游戏引擎的，如：渲染

但是有些功能，是属于游戏的，如：摄像机的摇晃感

一个游戏的实现，很多都需要在功能层进行实现

## 2.2.5 功能层的多线程

有很多功能，很适合并行操作，通过多线程可以大大减少计算压力，提升计算速度，如：物理计算

但是有很多功能，它们是有依赖关系的，即必须先进行 A ，再进行 B ，这种情况的多线程，就需要更加深入的考量了

但是未来的引擎架构，一定是多核的！！！

# 2.3 核心层
---

## 2.3.1 数学

除了物理等的计算，大部分的数学计算都是很轻松容易的，就如同大学的线性代数

但是，数学计算的 **效率** 非常重要，为此我们甚至可以放弃一些计算的精度，如：用牛顿迭代法计算平方根代替 sqrt 库函数

SIMD：GPU 中，通过一条指令然后并行来进行计算，并提升效率

## 2.3.2 数据结构和容器

虽然在 C++ STL 中都有实现，但是它并不适合游戏引擎：
- 它在频繁的增数据的过程中，会重新申请内存，引起内存碎片，造成内存浪费
- 它的内存管理不受我们控制
	- 如：vector 的扩充内存的容量是成倍增加，很容易造成内存浪费

## 2.3.3 内存管理

游戏引擎非常类似于一个操作系统，内存管理也都是它们的核心

### 2.3.3.1 内存池

首先，申请一大块内存：pool

### 2.3.3.2 降低缓存丢失率

cache的命中率对运行速率非常重要

方法：
1. 存储数据的时候，尽可能的将数据放在一起，这样就可以尽可能提升缓存的命中率
2. 访问数据的时候，尽可能的顺序访问
	- 读写操作
	- 移除操作，即一块直接移除

# 2.4 平台层
---

平台无关性：我们在功能层等写逻辑时，可以无视不同平台的差异

## 2.4.1 渲染硬件接口

我们重新定义了渲染使用的硬件接口，然后统一调用这个接口来渲染
- 用虚函数

如果没有这个，我们在不同平台需要写不同的 shader，太繁琐了

Render Hardware Interface (RHI)
- 透明处理了不同 GPU 架构和 SDK
- 自动应用到目标平台

## 2.4.2 硬件架构

不同的 GPU，架构也不一样，不同架构都要单独处理

# 2.5 工具层
---

运行任何人去创建游戏，如：UI 编辑器，shader 编辑器等

因为引擎才是我们使用的最终平台，在其他软件中创建的资源，可能在导入引擎变成资产后，看起来效果就不同了，我们想在引擎中再进行调整

## 2.5.1 开发语言的选择

在引擎的其他层，基本都是以 C++ 语言去编写的，因为我们希望有更好的运行效率

但是在工具层，我们可以使用其他语言去编写，因为在这一部分我服务于开发人员的，我们希望有更好的开发效率，而不是运行效率

当然运行起来后，工具层也就用不到了

## 2.5.2 Digital Content Creation