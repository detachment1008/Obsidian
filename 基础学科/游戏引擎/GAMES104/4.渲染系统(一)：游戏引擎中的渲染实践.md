# 4.1 渲染概述
---

图形学和游戏渲染的区别：

图形学：
1. 只针对单一效果
2. 重点放在精确的表示和数学的正确性
3. 没有严格的性能要求

游戏渲染：
1. 有成千上万个携带各种渲染效果的游戏对象
2. 适配在现代的 CPU 和 GPU ，并在性能有限的它们上面完成渲染
3. 帧率必须保持稳定，并保证高帧率
	- 分辨率也越来越高，画面的要求也越来越高
4. 我们只能完全使用 GPU，CPU 只能分配给渲染一部分
	- CPU 还要分配给游戏逻辑、网络、动画、物理、AI……

游戏渲染系统，它不是一个理论模型，它是一个工程实践出来的模型，因为它和很多外部条件，如：硬件，息息相关，有诸多限制

## 没有包含的知识点

- 卡通化渲染：Cartoon Rendering
- 2D 渲染引擎：2D Rendering Engine
- 皮肤相关：Subsurface
- 毛发相关：Hair / Fur

# 4.2 渲染系统的对象
---

## 4.2.1 渲染管线中的数据

1. 顶点数据
2. 三角面片数据
3. 材质数据
4. 纹理数据

## 4.2.2 计算方面

1. 投影：Projection
2. 光栅化：Rasterization
3. 着色：Shading
	- 纹理采样：Texture Sampling
		1. 找到两个最近的 mipmap 等级
		2. 线性插值找到合适的等级
		3. 线性插值找到最终的结果
	- 这一步的计算非常繁琐，所以我们需要使用 GPU

# 4.3 了解 GPU
---

## 4.3.1 SIMD 和 SIMT

- SIMD(Single Instruction Multiple Data): 即简单计算大量数据 
	- 有多个处理单元的计算机
	- 这些处理单元可以同时执行相同的计算操作
- SIMT(Single Instruction Multiple Threads)
	- 有多个处理单元的计算机
	- 这些处理单元可以同时执行相同的线程操作

所以我们在写 GPU 程序的时候，尽可能写可重用的处理代码，然后处理不同的数据即可

## 4.3.2 GPU 架构

### 4.3.2.1 费米架构

- GPC(Graphics Processing Cluster)：图形处理集群
	- 包含了很多内核
	- 用于处理几何运算
- SM(Streaming Multiprocessor)：流处理器
	- 包含了很多内核，用于处理数学运算
	- SM 之间不仅是并行运算关系，也可以交换数据
- Texture Units：一个纹理单位，可以获取和过滤纹理
- CUDA Core：并行的设备
	- 允许数据通过不同的程序进行工作
- Warp：线程块

### 4.3.2.2 CPU 向 GPU 的数据流动

为了效率，我们尽可能只让数据从 CPU 到 GPU，而不让数据从 GPU 到 CPU

### 4.3.2.3 缓存对性能影响非常大

为了保证缓存命中率：
1. 数据都放在一起
2. 减少内存碎片

## 4.3.3 GPU 程序的限制

1. 内存限制：Memory Bound
2. 算术逻辑单元限制：ALU Bounds
3. 纹理映射单元限制：TMU (Texture Mapping Unit) 
4. 带宽限制：BW (Bandwidth) Bound

## 4.3.4 现代硬件管线

# 4.4 可渲染物体
---

即拥有 Mesh Render Component 组件的游戏对象

## 4.4.1 网格渲染组件

网格数据：
- Mesh Primitive：不再使用了
	- 顶点数据
	- 三角面片数据(顶点数据数组)
	- 但是这种存储方式很浪费内存
 - Vertex and Index Buffer：相当于 OpenGl 中的 VBO 和 EBO
	- 包含顶点法向量等
- Materials：材质
	- 视觉材质，和物理材质不同
	- 它定义了物体表面的反射系数(光照要使用)
	- 材质模型(用于光照)
	- Texture：纹理
- Shader：着色器程序
	- 它是被当作数据的代码
 - Coordinate System and Transformation：坐标系统和变换

## 4.4.2 Submesh

它是针对单个游戏对象的一种优化方案

将使用同样纹理的面片数据，记录在一个 Submesh 下，它包括：
1. 面片数据：通过顶点数组的偏移和数量来确定
2. 材质
3. 纹理
4. Shader

相当于整合了面片

## 4.4.3 Resource Pool

它是针对整体的一种优化方案

组成：
1. Mesh Res Pool
2. Texture Res Pool
3. Shader Res Pool

实例化：使用句柄来获取重用的资源

## 4.4.4 Sort by Matrial

我们把 Submesh 通过材质来进行排序，相同材质的一起进行渲染

这样可以尽可能减少切换材质的时间

相当于调整了渲染顺序

## 4.4.5 GPU Batch Rendering

当有重复物体需要绘制时，我们可以将其合成一个批次进行处理，可以减少物体之间的状态切换和数据传输操作

这种优化技术通常适用于大量需要重复绘制的物体

相当于整合了游戏对象

# 4.5 可见性裁剪
---

我们用世界锥来表示可以看到的世界，它是一个锥形的，所以一个世界的绝大部分我们是看不见的

## 4.5.1 使用包围盒去裁剪

### 4.5.1.1 包围盒的种类

包围盒的种类：包围的越好越慢，包围的越差计算越快
1. SPHERE
2. AABB
3. OBB
4. 8-DOP
5. CONVEX  HULL

### 4.5.1.2 包围盒的应用

通过之前的场景划分，如：BVH，一层一层的向下判断，如果一个包围盒完全在世界锥的外面，这个包围盒内的所有游戏对象都可以被裁剪掉

## 4.5.2 潜在可见几何裁剪

PVS：Potential Visibility Set

它在离线状态下，根据不同游戏对象的位置关系，来确定哪些物体可能被视野范围内的摄像机看到。如：在一个小房间内时，通过窗户看到的游戏对象是一定的

## 4.5.3 GPU 裁剪

能在硬件上完成，就在硬件上完成，因为 GPU 真的很快

## 4.5.4 遮挡裁剪

即先绘制一份深度图，根据深度绘制游戏对象，被遮挡到的游戏对象就不再绘制了

# 4.6 纹理压缩
---

传统的图像压缩格式：JPG ，PNG 等
1. 高压缩率
2. 保证了图像质量
3. 很好的压缩和解压

游戏中的图像压缩：
1. 高解码速度
2. 随机访问
3. 压缩率兼顾图像质量
4. 编码速度

## 4.6.1 Block Compression

块压缩理念：将图片分成一个一个块，然后逐块去压缩

它是一种有损压缩

1. 找到最亮的像素和最暗的块，即就定义了图像颜色范围
2. 像素的颜色都有关联性，所以只记录它与最亮或最暗块的距离，就可以得到颜色了

常用算法：
1. PC：
	- BC7(modern)
	- DXTC(old)
2. mobile：
	- ASTC(modern)
	- ETC / PVRTC(old)

# 4.7 建模工具
---

## 4.7.1 多边形建模

Polymodeling：即多边形建模，通过基本几何体或自定义多边形来创建基础网格

优点：快速创造，灵活调整

缺点：多边形太多性能下降，否则质量不高

建模工具：
1. 3D MAX
2. MAYA
3. BLENDER

## 4.7.2 雕刻

Sculpting：即雕刻技术，它允许在 3D 模型上进行类似雕刻的手工操作，以创建具有高度复杂性和自然感的 3D 模型

优点：灵活，且可视化

建模工具：
1. ZBrush

## 4.7.3 扫描

Scanning：扫描技术，通过深度学习等通过扫描来建模

## 4.7.4 程序化建模

Procedural Modeling：即程序化建模，通过脚本或配置文件，来生成复杂的 3D 模型

建模工具：
1. Houdini
2. Unreal

# 4.8 新的渲染管线
---

渲染管线不是一成不变的，它是一直在发展的

## 4.8.1 基于集群的网格管线

Cluster-Based Mesh Pipeline：它的核心思想是集群

即将一个模型上的三角面片组合成一个个 cluster ，因为现代 GPU 可以快速生成几何体，不需要我们传递顶点数据

它可以自动由我们的 cluster，再生成无限细节的三角面片来组合

因为生成算法是一样的，所以它在 GPU 上并行处理起来非常快

它的裁剪，甚至也可以根据面片来进行裁剪，而非根据游戏对象

## 4.8.2 Nanite

虚幻引擎中，可以生成像素级别的模型！

# 4.9 总结
---

1. 游戏引擎的设计，深度依赖于 GPU 等硬件架构
2. Submesh 的设计是被用来解决模型多材质的情况的
3. 使用裁剪技术，尽可能的少绘制物体
	- 总之就是尽可能的，让计算机少做事情，这就是优化
4. 随着 GPU 的越来越强力，越来越多的计算也被移至 GPU，这就是 GPU Driven