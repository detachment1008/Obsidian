# 为什么需要事件系统
---

我们希望知晓系统中出现的任何事件，并为之做出相应的操作

事件：和用户交互时，用户进行的操作就是事件；如：用户改变了窗口的大小，关闭了窗口等

思路：我们有一个窗口类，当发生某种事件时它获取事件，并将其发送给 `App` 类，让 `App` 类进行处理即可

`Windows` 获取事件，并进行回调操作；回调就是 `App` 类该做的事，它设置回调就相当于对事件进行了处理

阻塞事件：停止处理其他事件，先处理这个事件

就是我们希望应用程序：
1. 获取事件
2. 处理事件

# 题外话：`static`
---
`static` 分为两种：
1. `class` 外的 `static`
	1. 修饰的符号在 `link` 阶段是局部的，也就是 `link` 阶段会忽略类外 `static` 标识的符号
	2. 即当链接时遇到了 `static` 修饰的类外的数据或函数时，它不会去当前文件 ( `obj` ) 的外部去寻找定义
	3. 当你需要使用到类外变量时，当然你要声明，但是变量没有函数这样的声明，`int x;` 这样的代码只会让编译器认为你定义了(生成了一块新内存)，只是没有用值对这块内存进行初始化；所以可以用 `extern` 关键字来进行声明，它会去别的 `obj` 中去寻找定义，即 `extern int x;` 当然，如果你使用了 `static` ，这样的( `extern` )代码也无法链接到这里了。
	4. 函数也是相同，就好像当前 `obj` 的专属函数一样
	5. 所以，在全局变量上用 `static` ，来避免其他文件来使用这个全局变量
	6. 类外只能放置声明或定义，无法直接执行代码
2. `class` 内的 `static`
	1. 表明这部分内存是这个类的所有实例所共享的
	2. 对于 `static` 数据，无论实例化多少个对象，这部分数据都只有一份
	3. 对于 `static` 函数，它的内部没有 `this` 指针
	4. `static` 的变量一定需要初始化，即需要显式的给它分配内存，如果你不想给他赋值，简单的 `int Entity::x;` 这样就可以，就好像是定义了一个变量一样，只不过它的范围属于这个类
	5. 既可以通过类名去访问这个 `static` 数据，也可以通过实例去访问 `static` 数据，效果是一样的
	6. 对于 `static` 函数，同样的也可以用类名直接去访问这个 `static` 函数
	7. 如果 `static` 函数需要直接访问到类内部的数据，那么这个数据一定要也是 `static` 的才行；这是因为 `static` 函数是没有 `this` 指针的
	8. 类就相当于是一个模板，一个规范，它没有生成任何的内存空间；所以当你在类中使用了一个 `static` 的时候，只是声明了在这个规范中存在一个 `static` 变量，当你第一次使用它之前，需要显式的为其生成内存 `int T::x = 2;` 才能使用这个 `static` 变量
3. 局部空间下使用 `static`
	1. 它的生命周期是整个程序
	2. 它的作用域是这个函数(或 `if` 这样的作用域)
	3. 相当于程序刚刚开始第一次调用这个函数时，这个 `static` 局部变量就已经被初始化了，即生成了一块内存，之后当我们再次的调用到这个函数时，也不会再次为这个 `static` 变量生成内存了，只是这块内存还不可用；当我们执行到了这个函数的内部之后，这个 `static` 的局部变量我们才可以访问到
	4. 局部空间下的 `static` 变量和全局变量很像，只是它的访问作用域被进行了限制罢了

总结：
1. 全局静态：希望在当前文件共享
2. 类中静态：希望在该类的成员中共享(如果放置在 `public` 下就和全局静态没有什么两样了)
3. 函数中静态：希望在所有调用当前函数中共享

# 题外话：`enum`
---

只是一种给整型的数命名的方式罢了，即给一块整型的数进行一个划分，并进行专门的命名；当使用的时候首先要找到这个块，然后再用名字找到这个整型数罢了
```
enum T : char
{
	A, B, C
}
```
也可以自定义类型，当然都必须是整型

注意：`enum` 也是一种规范，使用时必须定义，就相当于定义变量一样定义 `enum` 变量

`enum` 中的内容，就好像常量一样；即在使用 `enum` 的时候，就创建好了内部的这些变量，即为它们申请了内存，当再使用的时候，只需要创建变量，然后用创建好的这些内存对其赋值即可

如果只是简单的使用 `enum` ，里面的变量就只是简单的 `int` 或其他自定义的类型，它不是一个空间下的；但是如果使用 `enum class` 使用的时候就必须显式的加上它的空间，即 `T a = T::A;` 这样来使用，更加安全和规范吧

用途：
1. 当你希望表示一组状态的时候
2. 在任何你需要使用到数字集合的时候，枚举都是一个非常好的选择