# 为何需要日志系统
---

因为 debug 在解决特定问题的时候非常好用，但是在整个程序运行的时候，我们可能不知道问题出在哪里，所以我们需要使用一个日志系统来进行程序的反馈

# 什么是日志系统
---

日志系统可以以某种格式，颜色等来在控制台打印信息，用以反馈程序运行的状态；`std::cout` 是一种非常简单的输出方式，我们需要有 `error`，`warn` 等等分类和格式来输出，所以我们使用了第三方库 `spdlog`

# `spdlog`
---

这是一个开源的日志库，且只需要包含头文件就可以了

```
/*
%T: 表示时间戳
%n: 表示类型
*/
spdlog::set_pattern("%T^[%T] %n: %v%$");
// 设置类型以及颜色
s_CoreLogger = spdlog::stdout_color_mt("HAZEL");
s_CoreLogger->set_level(spdlog::level::trace);
```

# 构建自己的日志系统
---

尽管我们使用的是第三方库的日志系统，但是我们仍然要进行封装：
1. 当我们日后需要替换日志系统时，我们只需要替换封装前的就可以了，无需全局替换
2. 当我们打包发布的时候，我们就不需要日志系统了，我们可以简单的通过宏移除即可

## 定义 `Log` 类

因为这个类是全局的，所以我们需要将它的函数成员和数据成员都变为 `static` 的静态类型

函数成员：
1. 初始化函数
2. 获取引擎的 `Logger` 静态实例
3. 获取客户端的 `Logger` 静态实例

数据成员：
1. 引擎的 `Logger`，共享的智能指针
2. 客户端的 `Logger`, 共享的智能指针

这个类的目的就是将 `spdlog` 中的日志格式进行设置，并赋值到自己的静态变量中；这样使用的时候，使用自己的静态变量进行打印日志就可以了

# 封装
---

利用宏，进行封装(`__VA_ARGS__`: 表示接受变长参数，输入变长参数直接使用 `...` 即可)

使用的时候，只使用宏来进行打印；这样在发布的时候，清空宏就可以清除所有的日志打印代码了

# 题外话：静态成员
---

静态成员变量：
1. 使用前，需要在类外定义
2. 可以被不同的实例所访问，但是访问的都是同一个实体
3. 也可以直接通过类名访问静态成员变量，即无需产生对象实例

静态成员函数：
1. 同理，使用前也需要在类外定义；和静态成员变量一样，定义的时候不需要加 `static` 关键字了

其他：
1. 静态数据成员不能再类中定义，因为类定义只是一个模型、规范，它和变量或实体之间没有任何关联
2. 普通的成员函数中，可以调用静态成员变量和方法
	1. 直接访问
	2. `this` 指针访问
	3. `类名::func()` 方式访问
3. 静态方法中只能访问静态成员变量和方法，不能访问任何非静态的东西

# 题外话：智能指针
---

有三种智能指针：
1. `std::unique_ptr<>`：独占资源所有权的指针
2. `std::shared_ptr<>`： 共享资源所有权的指针
3. `std::weak_ptr<>`：共享资源的观察者；需要和 `std::shared_ptr<>` 一起使用，不影响资源的声明周期

## `std::unique_ptr<>`

基本的 `RALL` 思想，离开 `std::unique_ptr<>` 的作用域时，会自动释放资源

禁止使用它对另一个 `std::unique_ptr<>` 或其他任何进行赋值，因为它是独占的

## `std::shared_ptr<>`

对资源进行引用计数，当引用计数为 0 时，自动释放资源

## `std::weak_ptr`

1. 当需要 `std::weak_ptr<>` 观察资源时，可以将其升级为 `std::shared_ptr<>`
2. 当 `std::shared_ptr<>` 管理的资源被释放时，`std::weak_ptr<>` 自动变为 `nullptr`

## 用途

1. 如果只是使用，不负责资源生命周期的管理：原始指针
2. 只负责创建，但是释放时交给了其他对象来管理：`std::shared_ptr<>`
3. 创建和释放都由自身来进行管理：`std::unique_ptr<>`