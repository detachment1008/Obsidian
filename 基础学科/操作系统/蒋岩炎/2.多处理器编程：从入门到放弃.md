# 线程的状态机模型

并发：两个程序同时执行

并发的基本单位：线程

一个例子理解多线程：
1. 单线程就相当于是一个人在教室上课
2. 多线程就是多个人在教室上课
	- 教室就是全局变量和堆区，共享的
	- 每个人的大脑就是一个栈帧链，它保存着各自的独占的信息
	- 栈帧链：每个栈帧都保存着自己独有局部变量和PC，但是他们之间可以相互转换
	- 当执行时，就相当于老师提问一个学生，对于这个学生而言，它的大脑会更新，即栈帧信息更新，但是其他的学生没有更新。

并发程序的每一步都是不确定的


# thread.h 线程库

- create(fn)
	- 创建一个入口函数是 fn 的线程，并立即开始执行
		- void fun(int tid){...}
		- 参数 tid 从 1 开始编号
	- 语义：在状态中新增 stack frame 列表，并初始化为 fn(tid)
- join()
	- 等待所有运行线程的 fn 返回
	- 在 main 返回时会自动等待所有线程结束
	- 语义：在有其他线程未执行完时死循环，否则返回
- 编译时需要加 -lpthread

如何证明线程共享内存：写一个小程序，开启多线程，都访问全局变量即可

如何证明线程具有独立的栈帧链：写一个小程序，开启多线程，看看他们都有多大的栈帧链内存空间

进一步配置线程：
- 设置更大的线程栈
- 设置 detach 运行(不在进程结束后杀死，也不能 join)

# 原子性

当两个线程同时访问同一块共享内存(如全局变量)时，可能会因为并发而出现问题

之前的一条假设，程序(甚至是一条指令)独占处理器执行，在多处理器系统上不再成立

原子性：一段代码执行独占整个计算机资源
- 单处理器多线程：线程在运行时可能被打断，切换到另一个线程执行
- 多处理器多线程：线程根本就是并行执行

实现原子性：
1. 实现临界区之间的代码是绝对串行化的
2. 99%的并发问题都可以用一个队列解决

# 顺序

可以通过下面这两个之一来保证编译不被优化：
- `asm volatile("" :: "memory");`
- `volatile`

我们目前的 CPU 也是一个动态编译器，单个处理器把汇编语言(用电路)编译成更小的 $\mu$ops，每个$\mu$op 都有 Fetch, Issue, Execute, Commit 四个阶段

在任何时刻，处理器都维护一个 $\mu$op 的池子
- 每一个周期向池子补充尽可能多的 $\mu$op
	- 多发射
- 每一个周期(在不违背编译正确性的前提下)，执行尽可能多的 $\mu$op
	- 乱序执行，"按序提交"
- 内部实际上是一个指令的有向无环图

多处理器间即时可见性的丧失：满足单处理器 eventual memory consistency 的执行，在多处理器上可能无法序列化

当 x 和 y 没关系时，对 x 和 y 的内存读写是可以交换顺序的
- 他们甚至可以在同一个周期里完成
- 如果写 x 时发生 cache miss，可以让读 y 先执行
	- 满足尽可能执行 $\mu$op 的原则，最大化处理器性能

# 宽松内存模型

宽松内存模型的目的是使单处理器的执行更加高效

实现顺序一致性：
- 插入 fence 指令