# 硬件实现

我们可以通过硬件来实现，即当访问内存的时候，先把其他人的操作停下来，让我一个人操作完，其他人再开始操作

如：xchg

处理器保证所有带 lock 的指令都会进行一次排序，而且保证当执行某一个 lock 指令的时候，之前 lock 一定被执行。且指令的执行，不能跨过 lock，可以理解为 lock 指令把代码分块了，而一块内部，是可以在保证结果正确性的前提下，任意交换执行顺序的

原子指令：
1. 读取
2. 操作
3. 写入

# 自旋锁

缺点：
1. 有原子操作，延迟增加
2. 等待的线程一直在空转，即一直在检测锁状态，浪费 CPU 性能
3. 获取锁的线程，仍然可能挂起，就浪费了资源与性能了

它的特点：线程越多，时间越长

使用场景：
1. 临界区几乎不 "拥堵"
2. 持有自旋锁时，禁止自己被切换出去(但是操作系统绝不允许这种情况发生)
	- 优化：通过系统调用

好处：快的时候很快

## 睡眠锁

上锁失败会挂起睡眠

但是它会进出内核，慢

Fast path：一条原子指令，上锁成功立即返回
Slow path：上锁失败，执行系统调用睡眠

两者都可以使用

# 互斥锁



# futex