# 引言

在本章之前，都是写一些汇编指令。但是在本章，我们要开始写一个完整的程序了。

即写完整的汇编语言程序，然后用编译和链接程序将它们编译链接为一个可执行文件

# 4.1 一个源程序从写出到执行的过程

汇编语言程序从写出到最终执行的简要过程：
1. 编写汇编源程序
2. 编译源程序，产生目标文件
3. 链接程序，将目标文件链接，产生可执行文件

可执行文件包含三部分内容：
1. 程序：汇编指令翻译过来的机器码
2. 数据：源程序中定义的数据
3. 描述信息：如程序有多大，占用多少内存空间等

然后执行可执行文件中的程序即可：
1. 操作系统按照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存
2. 进行初始化操作，如：设置 CS:IP 指向可执行程序的第一条指令
3. 由 CPU 执行程序

# 4.2 源程序

```
assume cs:codesg

codesg segment

    mov ax,0123H
    mov bx,0456H
    add ax,bx
    add ax,ax

    mov ax,4c00H
    int 21H

codesg ends

end
```

## 1.伪指令

即没有对应的机器语言，不被 CPU 执行的命令。它是由编译器执行的指令，编译器根据伪指令来进行相关的编译工作

伪指令：
1. `codesg segment`：定义一个段的开始
2. `codesg ends`：定义一个段的结束

一个有意义的汇编程序中，至少要含有一个段，即用来存放代码的段

伪指令：
1. `end`：标记汇编语言结束，编译器在编译汇编程序时，如果碰到了伪指令 end，就结束对源程序的编译

伪指令：
1. `assume`：它将一个段寄存器和程序中的某一个用 `segment ... ends` 定义的段相关联。用法：`assume 段寄存器:段`

## 2.源程序中的"程序"

伪指令是编译器来处理的，汇编程序才是我们编程的最终目的。

## 3.标号

如上文的 `codesg`，一个标号代表了一个地址。如：`codesg segment`，表示它代表了一个段地址

## 4.程序的结构

之前我们在 debug 中直接写入汇编指令来执行汇编程序，但对于大一点的程序就不能如此了。我们要写出有结构的程序。

源程序是由一些段构成的，我们可以在这些段中存放代码、数据，或将某个段当作栈空间

步骤：
1. 定义一个段
2. 段中写入汇编指令，来完成我们的任务
3. 指出程序在何处结束
4. 在顶部，指出该段和哪一个寄存器联系起来的(如：代码段和 CS 联系起来)
5. 程序返回：一个程序 P2 在可执行文件中，必须有一个正在运行的程序 P1，它将 P2 从可执行文件中加载入内存后，将 CPU 的控制权交给 P2，然后 P2 才能得以运行。P2 开始运行时，P1 暂停运行。而 P2 程序在执行完毕后，需要将 CPU 的控制权交还给使它得以运行的程序，这个过程就是程序返回。`mov ax,4c00H int 21H`
6. 语法错误和逻辑错误：一般在编译时被发现的错误是语法错误，它由编译器发现。但是即使编译通过，在运行时也可能会出现错误，这被称为逻辑错误。


# 4.3 编辑源程序

```
assume cs:abc
abc segment
    mov ax,2
    add ax,ax
    add ax,ax
    mov ax,4c00H
    int 21H
abc ends
end
```

# 4.4 编译

在课程中，使用微软的 masm5.0 汇编编译器来进行编译(注意：文件名不能超过 8 个字符)

# 4.5 链接

得到目标文件后，还需要对目标文件进行链接，从而得到可执行文件

简单说明链接的作用：
1. 源程序很大时，可以分为多个源文件编译，然后链接生成可执行文件。加快速度
2. 程序中调用某个库文件中的子程序时，可以直接将库文件和目标文件链接起来
3. 目标文件中，有些内容还不能够直接生成可执行文件，链接程序将这些内容转化为最终的可执行程序

所以即使只有一个源程序，也不需要调用某个库时，也必须用链接程序对目标文件处理，生成可执行文件

# 4.6 以简化的方式进行编译和链接

# 4.7 1.exe 的执行

# 4.8 谁将可执行文件中的程序装载进入内存并使它运行？

操作系统的外壳：任何操作系统，都要提供一个 shell 程序(外壳程序)。用户通过这个程序来操作计算机系统进行工作。

当用户要执行一个程序时，shell 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 CS:IP 指向程序的入口，然后 shell 会暂停运行，CPU 运行该可执行程序。当程序运行结束后，返回到 shell 中，shell 再次显示路径提示符，等待用户的输入

# 4.9 程序执行过程的跟踪

如上所述，如果直接由 shell 加载程序，我们就无法逐条指令看到程序的执行过程了。我们可以启用 debug，让 debug 再将程序加载入内存，但此时 debug 并不放弃对 CPU 的控制，这样就可以使用 debug 的命令来单步执行程序，并查看每一条指令的执行结果了。

刚用 debug 加载程序时，cx 存放的是程序的长度

DOS 系统中，exe 文件中的程序加载过程：
1. 找到一段容量足够的空闲内存区，要偏移地址为 0
2. 前 256 个字节中(0100H)，创建一个程序前缀数据区(PSP)，DOS 通过它来和被加载的程序通信
3. 从程序前缀数据区后，将程序装入，即程序的起始偏移地址为：0100H，可以重新给程序划一个段，即：原段 + 0010H:0，即程序前缀数据区和程序区的物理地址连续，偏移地址都是 0，但是它们的段地址却不同
4. 将最开始的空闲内存区的段地址存入 ds，然后初始化其他寄存器，最后设置 cs:ip 指向程序的第一条指令

所以，最开始 cs 比 ds 大 1，ip 为 0

注意：在执行 `int 21H` 时，要使用 p 命令执行

程序加载流程：
1. shell 加载 debug
2. debug 加载 1.exe

程序结束流程：
1. 1.exe 中返回到 debug
2. debug 中返回到 shell

# 实验 3 编程、编译、链接、跟踪