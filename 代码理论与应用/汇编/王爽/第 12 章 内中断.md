# 引言

任何一种通用 CPU 都具有一种能力：在执行完当前正在执行的指令后，检测到从 CPU 外部发送过来的(或内部产生的)一种特殊信息，并可以立即对接收到的信息进行处理，这种特殊的信息：中断信息。即此时 CPU 不会接着之前的指令继续向下执行了，而是会去转而处理这个特殊的信息

本章，我们只讨论来自于 CPU 内部的中断信息

# 12.1 内中断的产生

对于 8086 CPU ，发生了以下情况时会产生相应的中断信息：
1. 除法错误(如：除法溢出)
2. 单步执行
3. 执行 into 指令
4. 执行 int 指令

CPU 需要区分这些中断信息，所以在中断信息中必须包含识别来源的编码，即中断类型码，它是一个字节类型的数据。(即可以表示 256 种中断信息的来源)

而产生中断信息的事件，我们称之为中断信息的来源，简称中断源，上面四种的中断类型码：
1. 0
2. 1
3. 4
4. `int n`，其中 n 为提供的中断类型码

# 12.2 中断处理程序

在 CPU 收到中断信息后，需要立即对中断信息进行处理，而如何处理是可以由我们编程决定的。我们编写的用来处理中断信息的程序被称为中断处理程序。一般来说，需要对不同的中断信息编写不同的处理程序。

有一个问题：当 CPU 收到中断信息后，如何根据中断信息确定其处理程序的入口？

# 12.3 中断向量表

CPU 如何根据 8 位的中断类型码找到对应的中断处理程序的入口地址呢？：中断向量表
- 中断向量：中断处理程序的入口地址

中断向量表在内存中保存着，存放着 256 个中断源所对应的中断处理程序的入口

但是 CPU 又是如何找到中断向量表的呢？：它有固定的地址。如 8086 CPU，就在 0000:0000 到 0000:03FF 的 1024 个内存单元中存放着中断向量表

# 12.4 中断过程

中断过程：
1. 从中断信息中，取得中断类型码
2. 标志寄存器入栈
3. 设置标志寄存器的第 8 位 TF 和第 9 位 IF 的值为 0
4. CS 入栈
5. IP 入栈
6. 从中断向量表中取值，并依次设置 CS 和 IP

这是一个由硬件自动执行的中断过程，程序员无法改变这个过程中所要做的工作

```
取得中断类型码 N
pushf
TF = 0, IF = 0
push CS
push IP
(IP) = (N * 4), (CS) = (N * 4 + 2)
```

# 12.5 中断处理程序和 iret 指令

中断处理程序的常规步骤：
1. 保存用到的寄存器
2. 处理中断
3. 恢复用到的寄存器
4. 用 iret 指令返回

iret 指令：
```
pop IP
pop CS
popf
```

# 12.6 除法错误中断的处理

# 12.7 编程处理 0 号中断

1. 我们写中断处理程序
2. 将其存放在内存中
3. 段地址和偏移地址(入口地址)存放在对应中断向量表中

# 12.8 安装

可以使用 movsb 指令，将代码送入到内存的指定位置
- 每次从 ds:si 向 es:di 传送一个字节的数据，传送 (cx) 个：`rep movsb`

# 12.9 do0

# 12.10 设置中断向量表

# 12.11 单步中断

当 CPU 执行完一步指令后，如果标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程

# 12.12 响应中断的特殊情况

有些情况下，即使发生了中断，CPU 也不会相应，这样的原因是当有连续的操作时，需要将这一整个操作做完再说(原子指令？)

# 实验 12 编写 0 号中断的处理程序