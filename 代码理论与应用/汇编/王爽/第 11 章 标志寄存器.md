# 引言

CPU 内部，有一种特殊的寄存器，它有三种作用：
1. 用来存储相关指令的某些执行结果
2. 用来为 CPU 执行相关指令提供行为依据
3. 用来控制 CPU 的相关工作方式

它们被称为标志寄存器，其他寄存器都是用来存放数据的，即整个寄存器具有一个含义；而标志寄存器是按位起作用的，它的每一位都有专门的含义

# 11.1 ZF 标志

标志寄存器的第 6 位是 ZF，即零标志位。它记录了相关指令执行后，结果是否为 0
- 如果结果为 0：zf = 1
- 如果结果不为 0：zf = 0

它只在计算后记录，即 mov 等传送指令它不记录
- 计算的指令如：add, sub, div, mul, inc, and, or, ...

# 11.2 PF 标志

标志寄存器的第 2 位，奇偶标志位。它记录了结果中所有 bit 为 1 的个数是否为偶数
- 如果 1 的个数为偶数：pf = 1
- 如果 1 的个数为奇数：pf = 0

# 11.3 SF 标志

标志寄存器的第 7 位是 SF，符号标志位。它记录了相关指令执行后结果是否为负
- 如果为负：sf = 1
- 如果为正：sf = 0

计算机把它当作有符号数来看待的(补码)，如果是无符号数，这个标志位就没有意义。

# 11.4 CF 标志

标志寄存器的第 0 位是 CF ，进位标志位。当进行无符号数计算时，它记录了运算结果向最高有效位的进位值或借位值

# 11.5 OF 标志

标志寄存器的第 11 位是 OF，溢出标志位。记录了有符号数的结果是否发生溢出
- 溢出：of = 1
- 没溢出：of = 0

CF 是对无符号数运算有意义的标志位，而 OF 是对有符号数运算有意义的标志位

# 11.6 adc 指令

adc 是带进位的加法指令(add with carry)，它利用了 CF 位上记录的进位值
```
adc 操作对象1,操作对象2
```

即 `操作对象1 = 操作对象1 + 操作对象2 + cf`

加法可以分为两步来进行：
1. 低位相加
2. 高位相加，再加上低位相加产生的进位值

对于 `add ax,bx`，就等于：
1. `add al,bl`
2. `adc ah,bh`

所以有了这个指令，就可以对大数进行计算了。即可以先对低位进行普通的 add 计算，然后再对高位进行 adc 携带 cf 信息的计算

即在保证没有更下层进位的情况下，使用 add 指令，同时也可以重设 cf 标志位；然后对于更上层的加法计算，需要使用 adc 指令，它同样也会重设 cf 标志位

# 11.7 sbb 指令

	sbb 是借位减法指令(subtract with borrow)，它利用了 cf 上记录的借位值
```
sbb 操作对象1,操作对象2
```

即 `操作对象1 = 操作对象1 - 操作对象2 - CF`

同理，利用 sbb 指令也可以对任意大的数据进行减法运算

它也是从小到大计算的，可以在最小的地方使用 sub 指令重设 cf 标志位，然后非最小的地方全部用 sbb 指令

# 11.8 cmp 指令

cmp 是比较指令，但它相当于不保存结果的减法指令；即它执行后只影响标志寄存器
```
cmp 操作对象1,操作对象2
```

即 `操作对象1 - 操作对象2`，但是不保存结果

如：`cmp ax,ax`
- zf = 1
- pf = 1
- sf = 0
- cf = 0
- of = 0

同 add 和 sub，对于有符号数和无符号数，意义不同

有符号数：
- 比较结果需要同时考虑 sf 和 of 的结果

四种情况：`cmp ah,bh`
1. sf = 1，of = 0：结果为负，且没有溢出，结果真实，ah < bh
2. sf = 1, of = 1：结果为负，发生溢出，结果相反，ah > bh
3. sf = 0, of = 0：结果为正，且没有溢出，结果真实，ah >= bh
4. sf = 0, of = 1：结果为正，发生溢出，结果相反，ah < bh

只要发生溢出，结果就是相反的。

这里比的只是 ah 和 bh 寄存器内的数值，并不是指的是它们内部存储的数。对于结果，我们是将它看作是一个补码的有符号数的，用以判断正负

# 11.9 检测比较结果的条件转移指令

转移：能够修改 IP，条件：可以根据某种条件，决定是否修改 IP

如：jcxz(检测 cx)，loop(减去 1，再检测 cx)

这些条件转移指令都和 cmp 指令配合使用

对于无符号数，不需要考虑溢出标志位：
1. je：等于则转移，zf = 1
2. jne：不等于则转移，zf = 0
3. jb：低于则转移，cf = 1
4. jnb：不低于则转移，cf = 0
5. ja：高于则转移，cf = 0 且 zf = 0
6. jna：不高于则转移，cf = 1 或 zf = 1

# 11.10 DF 标志和串传送指令

标志寄存器的第 10 位是 DF，方向标志位。在串处理指令中，控制每次操作后的 si，di 的增减
- df = 0：每次操作后 si、di 递增
- df = 1：每次操作后 si、di 递减

对于指令 `movsb`：
1. `mov es:[di],byte ptr ds:[si]`：只是起说明作用，实际需要用到寄存器中转
2. 根据 df 再递增或递减
	1. df == 0 ：`inc si`，`inc di`
	2. df == 1：`dec si`，`dec di`

对于指令 `movsw`，同理，只是针对字操作，最后的 si 和 di 递增和递减也是 2

一般配合指令 `rep` 来使用：`rep movsb`，相当于：
- `s: movsb`
- `loop s`

设置 df 标志位：
- `cld`：置 0
- `std`：置 1

# 11.11 pushf 和 popf

1. pushf：将标志寄存器的值压栈
2. `popf`：出栈，并将值赋给标志寄存器

# 11.12 标志寄存器在 debug 中的表示

# 实验 11 编写子程序