# 引言

两个基础问题：
1. 处理的数据在什么地方
2. 要处理的数据有多长

我们还定义了两个描述性符号：
1. reg 表示普通寄存器
2. sreg 表示段寄存器：cs, ds, ss, es

# 8.1 bx, si, di 和 bp

这四个都可以用作表示内存的偏移地址，前三个前面章节已经用过了

如果需要用到两个寄存器(最多也只能有两个)，必须一个是 bx, bp 中的一个，一个是 si, di 中的一个

bp 不存在，默认的段寄存器是 ds；bp 存在，默认的段寄存器是 ss

# 8.2 机器指令处理的数据在什么地方

数据处理分为 3 类：
1. 读取
2. 运算
3. 写入

数据可能出现在三个地方：
1. CPU 内部
	1. 寄存器
	2. 指令缓冲器(立即数)
2. 内存
3. 端口(后续再讨论)

# 8.3 汇编语言中数据位置的表达

数据位置的表达：
1. 立即数：放置在指令缓冲器中
2. 寄存器
3. 内存

# 8.4 寻址方式

总结：`[bx/bp + si/di + idata]`

最长就是如此了

# 8.5 指令要处理的数据有多长

两种方式指明数据长度：
1. 寄存器(隐式指明)
2. X ptr(显示指明)：`mov word ptr ds:[0],1`
	- `byte`
	- `word`
3. 栈操作(push pop)，默认数据长度为 2 个字节(1 个字) 

即如果没有寄存器的话，就需要 `X ptr` 来显式的指出数据的长度了

# 8.6 寻址方式的综合应用

C 语言和汇编语言之间的相互对照：
```
struct company {
	char cn[3];
	char hn[9];	 
	int pm;
	int sr;
	char cp[3]; 
};
struct company dec = {"DEC", "Ken Olsen", 137, 40, "PDP"};

int main() {
	int i;
	dec.pm = 38;
	dec.sr = dec.dr + 70;
    i = 0;
    dec.cp[i] = 'V';
	i++;
	dec.cp[i] = 'A';
	i++;
	dec.cp[i] = 'X';
	return 0;
}
```

- 设该数据的起始地址是 60h
- 注意，在 16 位 CPU 中 int 是 2 字节
```
mov ax,seg
mov ds,ax
mov bx,60h

mov word ptr [bx].0ch, 38
mov word ptr [bx].0eh, 70

mov si,0
mov byte ptr [bx].10h[si], 'V'
inc si
mov byte ptr [bx].10h[si], 'A'
inc si
mov byte ptr [bx].10h[si], 'X'
```

# 8.7 div 指令

div 是除法指令
1. 被除数：虽然是 16 位 CPU，但是被除数可以使用 32 位，即用 DX 存放高 16 位，AX 存放低 16 位
2. 除数：除数可以是 8 位，也可以是 16 位
3. 结果：结果是 8 位，AH 放余数，AL 放商；结果是 16 位，DX 放余数，AX 放商

如果除数是 8 位，被除数就是 AX；如果除数是 16 位，被除数就是 DX + AX

# 8.8 伪指令 dd

dd 可以定义双字类型的数值
- db：字节
- dw：字
- dd：双字

# 8.9 dup

它是一个操作符，也是由编译器识别处理的，用于配合定义的伪指令，进行数据的重复

如：
1. `db 3 dup (0)`：定义了三个字节类型，值为 0
2. `db 3 dup(0,1,2)`：定义了九个字节类型，值为 0,1,2,0,1,2,0,1,2
3. `db 3 dup('abc', 'ABC')`

使用格式：`d* 重复次数 dup (重复的数据)`

# 实验7 寻址方式在结构化数据访问中的应用