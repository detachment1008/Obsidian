# 引言

转移指令：修改 IP 或同时修改 CS:IP 的指令，称为转移指令

只修改 IP：段内转移
- `jmp ax`

同时修改 CS 和 IP：段间转移：
- `jmp 1000:0`

转移指令：
1. 无条件转移(jmp)
2. 条件转移
3. 循环指令(loop)
4. 过程
5. 中断

本节学习无条件转移指令：jmp

# 9.1 操作符 offset

它用以获取标号的偏移地址(非位移)：
```
assume cs:codesg
codesg segment
	start:mov ax,offset start
	s:mov ax,offset s
codesg ends
end start
```
相当于(第一条指令的长度为 3)：
```
mov ax,0
mov ax,3
```

# 9.2 jmp 指令

jmp 指令需要两种信息：
1. 转移的目的地址(段间转移)
2. 转移的距离(段内转移)

# 9.3 依据位移进行转移的 jmp 指令

段内短转移：`jmp short 标号`

一个问题：当我们查看它的汇编代码时：
```
EB03    jmp,0008
```

机器码中并没有 8，它怎么知道要跳转到 8 偏移地址的地方的呢？

在 `jmp` 上面添加代码，再调试，会发现虽然它的跳转目的地址发生变化，但是它还是 EB03，即 CPU 在执行 `jmp` 指令不需要转移的目的地址，但是 CPU 如何得知要跳转到哪里的呢？

我们在 `jmp` 下面再添加代码，发现机器码变化了，变成了 EB06，即后面的数字代表的是位移

即 `jmp short 标号` 的功能：(IP) = (IP) + 8 位位移
1. 8 位位移 = 标号处的地址 - `jmp` 指令后(IP已经加过后)的第一个字节的地址
2. `short` 指明此处的位移为 8 位位移
3. 8 位位移的范围就是 -128~127，用补码表示的
4. 8 位位移是由编译器在编译时计算得出

另一种标号跳转指令：`jmp near ptr 标号`，它将 `short` 换为了 `near ptr`，表示使用 16 位表示偏移；它被称为段内近偏移(短 -> 近)

# 9.4 转移的目的地址在指令中的 jmp 指令

段间转移(远转移)：`jmp far ptr 标号`，它利用标号，同时修改 CS 和 IP 寄存器。

# 9.5 转移地址在寄存器中的 jmp 指令

上面的目的地址，都是通过标号给出的，现在是通过寄存器给出(寄存器必须是 16 位)：`jmp reg`

# 9.6 转移地址在内存中的 jmp 指令

现在通过内存中的值，来进行跳转
1. 段内转移(直接改 IP)：`jmp word ptr 内存单元地址`
2. 段间转移(改 CS 和 IP)：`jmp dword ptr 内存单元地址`

# 9.7 jcxz 指令

它是有条件转移指令，有条件转移指令都是短转移，即位移为 8 位：`jcxz 标号`
1. 如果 `(cx) = 0`，则转移
2. 否则，什么也不做，继续向下执行

# 9.8 loop 指令

所有的循环也都是短转移，即 8 位的位移
1. `(cx) = (cx) - 1`
2. 同 jcxz

# 9.9 根据位移进行转移的意义

为了方便程序段在内存中的浮动装配，即程序段换了位置，代码也不用变

# 9.10 编译器对转移位移超界的检测

如果转移范围超界，则编译的时候编译器将报错

# 实验 8 分析一个奇怪的程序

# 实验 9 根据材料编程