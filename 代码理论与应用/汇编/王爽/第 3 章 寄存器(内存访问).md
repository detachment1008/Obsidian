# 引言

上一章是从 CPU 角度看待寄存器，这一章从内存角度看待寄存器

# 3.1 内存中字的存储

字单元：存放 2 个连续的字节的内存单元。低地址放低字节，高地址放高字节(小端)

# 3.2 DS 和 \[address]

当 CPU 要读写内存单元时，要先给出内存单元地址。

读取指令的是通过 CS:IP

读写数据是通过 DS 来指定默认读取的段寄存器的，所以只需要给出偏移地址即可
- 偏移地址，如：`mov bx, [1]`

注意，mov 也不能直接将立即数赋值给 DS，需要通过寄存器进行中转

>cs:ip，只能通过 jmp 修改，可以同时修改，也可只修改 ip
>ds，只能通过 mov 修改，但是源数据来源必须是寄存器

# 3.3 字的传送

虽然地址总线大于16 根(20根)，但是由于是 16 位 CPU，所以数据总线的宽度仍是 16。即一次可以传送一个字的数据，即两个字节大小

# 3.4 mov、add、sub 指令

mov 的几种形式：
```
mov 寄存器,立即数             mov ax,8
mov 寄存器,寄存器             mov ax,bx
mov 寄存器,内存单元           mov ax,[0]
mov 内存单元,寄存器           mov [0],ax
mov 段寄存器,寄存器           mov ds,ax
```

段寄存器除了不能被立即数赋值，其他的和通用寄存器相同

# 3.5 数据段

数据同样也可以放到一组内存单元，然后定义为一个段。注意：起始地址一定要是 16 的倍数

# 3.6 栈

栈：特殊的访问形式的存储空间。它不是随机存储的。而是后进先出(LIFO，Last In First Out)

即需要有一个标记，一直指示着栈顶的元素

# 3.7 CPU 提供的栈机制

它可以提供相关指令，来以栈的方式访问内存空间。即可以将一段内存当作栈来使用。

基本的入栈和出栈命令：
- push
- pop

它们都是以字为单位进行的

指定栈顶的寄存器：SS:SP，每次放元素后，SP 减去 2(一个字的大小)，以保证 SS:SP 始终指向栈顶的元素(字节)

注意：栈都是向低地址方向增长的

# 3.8 栈顶超界的问题

push 和 pop 都可能会引起栈的越界问题

但是 CPU 不知道我们安排的栈有多大，即它只知道栈顶是 SS:SP，不知道栈底在哪里，也不知道栈有多大

# 3.9 push、pop 指令

push 和 pop 可以直接操纵内存单元，无需使用寄存器进行中转

# 3.10 栈段

同理，我们也可以安排一个栈段。注意：这也是编程的安排，CPU 并不知道这样的安排

# 实验 2 用机器指令和汇编指令编程

## 1.预备知识：Debug 的使用

上一章讲的是 debug 的基础用法，这里进行额外的补充

### (1) 关于 D 命令

在使用 D 命令查看内存时，第一个参数可以使用寄存器

### (2) 在 E、A、U 命令中使用段寄存器

E、A、U 这些可以带有内存单元地址的[[第 2 章 寄存器#^ae140f|命令]]中，也可以同 D 命令一样，使用段寄存器表示内存单元的段地址

### (3) 下一条指令执行了吗

注意：在 debug 中，使用 T 命令在执行修改寄存器 SS 的指令时，下一条指令会自动的紧跟着被执行

## 2.实验任务

怀疑：可能是立即数在放到寄存器中时，会先放到内存，然后由内存传送给寄存器