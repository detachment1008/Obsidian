# 引言

call 和 ret 指令也是修改 IP 或 CS:IP 的指令。它们经常被共同使用来实现子程序的设计

# 10.1 ret 和 retf

1. `ret`：用栈中的数据，修改 IP 寄存器，从而实现近转移
2. `retf`：用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移
	- 先恢复 IP 再恢复 CS

# 10.2 call 指令

CPU 在执行 call 指令时，执行两步操作：
1. 将当前的 IP 或 CS 和 IP 压入栈中
2. 转移

# 10.3 依据位移进行转移的 call 指令

`call 标号`，相当于：
```
push IP
jmp near ptr 标号
```

# 10.4 转移的目的地址在指令中的 call 指令

`call far ptr 标号`，相当于：
```
push CS
push IP
jmp far ptr 标号
```

# 10.5 转移地址在寄存器中的 call 指令

`call reg`，相当于：
```
push IP
jmp 16位reg
```

# 10.6 转移地址在内存中的 call 指令

`call word ptr 内存单元地址`，相当于：
```
push IP
jmp word ptr 内存单元地址
```

`call dword ptr 内存单元地址`，相当于：
```
push CS
push IP
jmp dword ptr 内存单元地址
```

# 10.7 call 和 ret 的配合使用

可以在调用函数时使用，函数名就是一个标记，直接 call 标记即可

# 10.8 mul 指令

mul 即乘法指令：`mul reg`
1. 如果 reg 是 8 位的，就是两个 8 位相乘，结果放在 ax 寄存器中
2. 如果 reg 是 16 位的，就是两个 16 位相乘，结果放在 dx，ax 寄存器中(dx 是高位，ax 是低位)

用法：
```
mul reg
mul 内存单元(byte ptr/word ptr/dword ptr)
```

# 10.9 模块化程序设计

利用 call 和 ret 命令可以实现多个相互联系，功能独立的子程序来解决一个复杂的问题

# 10.10 参数和结果传递的问题

如何存储子程序(标记)需要的参数和产生的返回值呢？
1. 将参数存储在什么地方
2. 将返回值存储在什么地方

方法：
1. 寄存器存储：调用者将参数送入参数寄存器，从结果寄存器中取到返回值；子程序从参数寄存器取到参数，将返回值送入结果寄存器

# 10.11 批量数据的传递

如果参数过多，寄存器数量有限，就只能通过内存来传递参数了；返回值也是同样的道理

方法：
2. 栈传递参数：即使用内存来进行批量数据的传递

# 10.12 寄存器冲突的问题

可以通过 cx 寄存器来计算，然后通过 jcxz 来检测是否计算完成

但是 cx 同时也是循环的计数寄存器，如何解决寄存器冲突呢？
1. 在执行开始之前，将寄存器中的内容都保存起来
2. 在执行之后，再将寄存器中的内容恢复
3. 可以使用栈来保存寄存器中的内容

# 实验 10 编写子程序