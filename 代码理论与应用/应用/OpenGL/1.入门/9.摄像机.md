# 摄像机
---

OpenGL 本身并没有摄像机的概念

但摄像机的移动就等同于场景中其他所有物体作反向运动

注意：OpenGL 是观察 -z 方向的，即我们需要将摄像机变换到原点

# 摄像机/观察空间
---

观察空间，即摄像机的局部空间

为了创建一个摄像机，我们需要定义它在世界空间中的位置，观察的方向，右侧向量，上侧向量

根据这些，得到一个矩阵，即为 view transform

> 用哪个坐标系的单位描述，就是变换到哪个的坐标系(用逆矩阵就反过来了)

## 1. 摄像机位置

摄像机的位置：位置向量

## 2. 摄像机方向

摄像机的方向：方向向量(即需要单位化)

即摄像机局部空间的 z 轴负方向

## 3. 右轴

右轴：方向向量(即需要单位化)

即摄像机局部空间的 x 轴正方向

## 4. 上轴

上轴：方向向量(即需要单位化)

即摄像机局部空间的 y 轴正方向

小技巧：利用右轴 x 摄像机方向，即可得到已单位化的上轴

# Look At
---

## 矩阵的含义
有了上述观察空间的信息，我们就可以创建出一个仿射变换矩阵来使得世界空间中的物体变换到摄像机空间中。

就是用观察空间的基向量为基准，描述世界空间中的物体(model transform中，物体的位置已经确定)

我们先得到用世界空间基向量描述的摄像机局部空间的基向量，形成一个矩阵

然后取逆！！！逆矩阵才是我们真正的观察变换矩阵，逆矩阵是用摄像机的基向量描述世界空间的基向量

## 变换的本质

>矩阵变换只是描述了两个空间的基向量关系的信息，如果一个物体在一个空间有，另一个空间没有，我们希望在另一个空间创建出一个相同的，那就是物体的位置变换。如果说物体已经存在，我们只是希望换一个坐标系，那么就是物体的坐标变换

>A描述的矩阵 * 位置向量：
>1.表示 A 空间下的该位置向量的描述
>2.A 怎样描述的表示 A 空间下相同的位置向量经过这样的变换，得到的结果

>即如果你把这个位置向量看作是初始的坐标系，那么它的结果就是变换
>如果你把这个位置向量直接看作是矩阵的坐标系，那么它就是换一种描述

>A 描述的 B * 向量：
>1.表示用 A 描述 B 空间的该向量
>2.表示 A 空间的该向量变换到 B 空间

# 自由移动
---

现在我们希望自己移动摄像机，即动态改变 view 的位置向量

## GLFW 获取键盘输入

如下
```
glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS
```

# 移动速度
---

如果我们使用一个常量来表示速度，那么根据处理器能力的不同，帧数就不同，那么速度也就不同了

## 时间差

时间差是一个变量，它存储了渲染上一帧所需的时间，我们可以用速度乘以这个 deltaTime 变量

如果上一帧用了很长的时间，那意味着我们的速度变慢了，下一帧就需要加快，正好 deltaTime 记录了这个变化

可以利用 glfwGetTime 函数来计算每帧的时间

# 视角移动
---

即我们希望通过鼠标的输入改变 cameraFront 向量

# 欧拉角
---

一共有三种欧拉角：
1. 俯仰角：绕 x 轴旋转(pitch)
2. 偏航角：绕 y 轴旋转(yaw)
3. 翻滚角：绕 z 轴旋转(roll)

对于我们的摄像机系统来说，我们只关心俯仰角和偏航角

## 如何将俯仰角和偏航角转换为方向向量

只有转为方向向量，我们在可以在 view transform 中代替 -z 方向，从而更新观察变换矩阵

可以使用球形坐标系，即极坐标进行方向向量的计算

### 俯仰角

1. 绕 x 轴旋转
2. 旋转 pitch 弧度，90 - 和 y 轴正方向的夹角
3. 可以理解为抬头，将其和原点作连线，向 y 轴投影可得 y 坐标
	- y：sin(pitch)
4. 向 x，z 轴平面投影，可得长度：cos(pitch)
	- 这个长度可用作下面记录偏航角

### 偏航角

1. 绕 y 轴旋转
2. 旋转 yaw 弧度，90 - 和 -z 轴正方向的夹角
3. 可以理解为转向，获取计算俯仰角投影下来的点，和原点作连线
	- x：cos(pitch) * cos(yaw)
	- z：cos(pitch) * sin(yaw)
	
# 鼠标输入
---

偏航角和俯仰角是通过鼠标移动获得的，水平移动影响偏航角，竖直移动影响俯仰角

原理：存储上一帧鼠标位置，在当前帧计算鼠标位置与上一帧相差多少

1. 当处于焦点时，隐藏光标并捕捉它：`glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED)`
2. 监听鼠标移动事件
3. 处理鼠标输入
	- 计算鼠标距上一帧的偏移量
	- 把偏移量添加到摄像机的俯仰角和偏航角中
	- 对偏航角和俯仰角进行最大和最小的限制
	- 计算方向向量

# 缩放
---

控制鼠标滑轮，来改变 fov，即透视矩阵

# 总结
---

如果用坐标描述的话，就统一了形式。各个坐标系只是基向量的坐标表示不同而已。
这个不重要，为了可视化，我们使用世界坐标系。

这些向量并不代表坐标！！如果将基向量统一用标准坐标系去描述的话，它们才代表位置！！

所以我们平常使用的都是空间和向量，不是坐标系！！！世界空间和标准坐标系重合。

我们所说的坐标，实际是一种描述向量，只是它化为坐标系恰好和世界空间重合罢了

即 真实向量(坐标表示) = 描述矩阵 * 描述比例

## 我们希望只是换一种描述形式，不改变位移向量位置

1. 获取原空间描述比例
2. 更新基向量，即更新了描述矩阵，但是我们需要求得它的逆矩阵(如果单位矩阵是原空间的话)
3. 用更新后的描述矩阵，乘以描述比例
4. 重要：再用之前求得的逆矩阵 * 真实向量(它此时也被看作是描述比例了)

## 我们希望变换的同时，更改了位移向量的位置

1. 用原空间描述向量
2. 更新基向量，即更新了矩阵
3. 用更新后的矩阵，乘以向量

## 相当于

一个向量的真实坐标 = 矩阵 * 向量

当我们改变矩阵的时候，就相当于改变了向量的真实坐标，所以就相当于变换了

其中矩阵表示描述方式，即空间，而真实坐标表示了向量真实的位置

如果我们希望更新矩阵(变换矩阵 * 描述矩阵)，但是不更新向量，我们需要乘以变换矩阵的逆矩阵
相当于矩阵加，向量减，真实坐标保持不变

- 变换向量位置：描述矩阵 * 向量 -> 变换矩阵 * 描述矩阵 * 向量
- 不变换向量位置：描述矩阵 * 向量 -> 变换矩阵的逆 * 变换矩阵 * 描述矩阵 * 向量 -> 描述矩阵 * 新向量

我们描述的都是以全局标准空间来描述，此时系数就等于坐标
当我们以全局标准空间描述局部空间的向量时，系数就不等于坐标

