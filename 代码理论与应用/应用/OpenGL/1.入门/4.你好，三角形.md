# 你好，三角形
---

在OpenGL中，任何物体都是3D的，但是显示的屏幕和窗口都是2D的，这导致OpenGL的大部分工作都是从3D坐标转化为屏幕像素。

3D坐标转化为2D坐标的处理过程是通过OpenGL的图形渲染管线管理的，它主要包含了两个部分：
1. 3D坐标转化为2D坐标
2. 2D坐标转化为实际有颜色的像素

> 图形渲染管线：指的是一堆原始图形数据，经过一个输送管道，期间经过各种变化处理，最终呈现到屏幕上的过程

> 2D坐标和2D像素是不同的：2D坐标精确表示一个点在2D空间中的位置，而2D像素则是这个点的近似值，而且2D像素会受到屏幕或窗口的分辨率限制

图形管线可以被划分为几个阶段，每个阶段都会把前一个阶段的输出作为输入。这些阶段都是高度专门化的，并很容易执行，且具有并行的特性，即适合在GPU中执行，这些阶段运行的小程序被称为着色器

> GPU：弱化但多，适合于执行简单但执行次数非常多的程序

OpenGL的着色器由GLSL语言编写，我们可以在某些阶段自定义着色器代码，从而定制效果：
- 输入顶点数据
1. 顶点着色器(可定制)
2. 图元装配
3. 几何着色器(可定制)
4. 光栅化
5. 片段着色器(可定制)
6. 测试与混合
- 输出像素数据

- 顶点数据：是一系列顶点的集合
	- 顶点：由一系列顶点属性表示，可以包含一个顶点的所有数据(不仅仅是位置)
- 顶点着色器：把一个单独的顶点作为输入，将3D坐标转换为另一种3D坐标，并允许我们对顶点属性进行一些基本处理
- 图元装配：将顶点着色器中的所有顶点输入，并将所有点装配为指定的图元形状
	- 图元：数据渲染的类型，如：点，线，面
		- 点：GL_POINTS
		- 线：GL_LINE_STRIP
		- 面：GL_TRIANGLES
- 几何着色器：把图元映射为屏幕上相应的像素
- 片段着色器：计算一个像素最终的颜色，它是OpenGL产生高级效果的地方
	- 片段：渲染一个像素所包含的所有数据
- Alpha测试和混合阶段：检测片段对应的深度并判断其是否应该被丢弃，检测alpha值并对物体进行混合

我们至少需要定义一个顶点着色器和一个片段着色器，因为GPU中没有默认的顶点着色器和片段着色器。几何着色器是可选的，通常使用它默认的着色器就行了

# 顶点输入
---

OpenGL是一个3D图形库，所以最开始输入的坐标一定都是3D坐标。

OpenGL在处理坐标时，只能处理[-1, 1]范围内的坐标(即OpenGL的可见区域)，其他超过范围的坐标会被舍弃。即我们需要输入在这个范围内的坐标，或者在顶点着色器中将输入的坐标转换为[-1,1]范围内的坐标

> 标准化设备坐标：NDC，即范围在[-1,1]的范围内的坐标

## 定义顶点数据

如果我们希望绘制2D图形，将z值设为0即可

## 发送给顶点着色器

1. 在GPU上创建内存，用于存储我们的顶点数据

我们通过VBO管理这个内存，它会在GPU内存中存储大量的顶点，使用VBO的好处是我们可以一次性的发送大量数据到GPU上，而不是每个顶点发送一次

> CPU发送数据至GPU的速度很慢，所以我们需要一次发送尽可能多的数据

- 它就是一个对象，即可以理解为一个结构体，它管理着这片内存
- 每个对象都有一个独一无二的id
	1. 生成缓冲和对象
	2. 绑定缓冲的类型(即设置状态)
	3. 向GPU发送数据

可以理解为GPU中的内存被分成很多块，每块都绑定一个对象，然后通过对象来操作这块内存。
每次使用OpenGL进行操作的时候，都要先绑定状态。

2. 配置OpenGL如何解释这些内存
3. 指定其如何发送给显卡

# 顶点着色器
---

顶点着色器是几个可编程的着色器之一，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。

- gl_Position：它是顶点着色器的默认输出，我们至少要给它进行赋值，它是vec4类型的变量。
	- 在此着色器中，进行升维
	- 默认可以给第四个分量设置为1.0

在真实的输入数据中，通常都不是标准化设备坐标，所以需要在这里转换为NDC坐标，当然在本示例中不需要。

> 向量：GLSL中的向量为vec+n，n表示为向量的维数

# 编译着色器
---

每次运行OpenGL，都必须从 CPU 发送 着色器源代码至 GPU，所以 shader 都是动态编译的

1. 创建着色器对象
	- 这一步就包含了 OpenGl 状态绑定
	- 着色器的状态绑定，是为了在链接过程中确定链接的位置
1. 着色器源码附加到着色器对象上
2. 编译

如何判断 GLSL 是否编译成功：
```
int success;
char infoLog[512];
glGetShaderiv(vertexShader, GL_CPMPILE_STATE, &success);
if(!success)
{
	glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
	std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
}
```

# 片段着色器
---

片段着色器所做的是计算像素最后的颜色输出

> 在计算机图形中，通常用 4 个元素的数组表示颜色：RGBA
> 每个颜色的分量都在\[0.0,1.0]之间

片段着色器只需要一个输出变量，这个变量是一个 4 分量，它表示为最终的输出颜色(任意一个 vec4 的输出变量即可)

它的编译流程和顶点着色器类似，只是顶点着色器使用 GL_VERTEX_SHADER 状态进行编译，而片段着色器使用 GL_FRAGMENT_SHADER 进行编译

# 着色器程序
---

着色器程序是多个着色器合并之后，并最终完成链接的版本，如果要使用刚才编译的着色器，我们必须把它们链接为要给着色器程序对象，然后在渲染对象的时候激活这个着色器程序。

当链接着色器时，它会把每个着色器的输出链接到下个着色器的输入，当输入和输出不匹配时，会得到一个链接错误

## 步骤：

1. 创建一个程序对象
2. 添加编译后的着色器至程序对象上
3. 链接它们
4. 激活程序对象(在每次渲染时)
5. 之后可以删除着色器对象了，因为它们已经被链接成一个程序对象，它们的任务完成了

# 链接顶点属性

^062b06

---

顶点着色器允许我们任何以顶点属性为形式的输入，所以需要我们手动指定输入的哪一部分对应顶点着色器的哪一个顶点属性。

即顶点属性可以以任意的顺序进行输入，但是每个顶点的顶点属性顺序必须相同

## 步骤：
1. 指定顶点属性
2. 应用指定的顶点属性

# 顶点数组对象
---

顶点数组对象，即 VAO。它可以保存任意的顶点属性信息，这样的好处是当配置顶点属性指针时，只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 即可。这使得在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 即可。

VAO 必须在链接顶点属性之前创建和绑定。即链接顶点属性一定要将属性绑定在 VAO 上面。

可以理解 [[4.你好，三角形#^062b06|链接顶点属性]] 属于 VAO 操作的一部分

## 步骤：
1. 创建 VAO
2. 绑定 VAO
3. 设置顶点属性
4. 启用顶点属性(在 VAO 中)

# 我们一直期待的三角形
---

前提：
1. 我们需要激活着色器程序
2. 我们需要激活VAO(通过 VAO，就相当于有了 VBO)

> VAO 中存储了 VBO 的信息，即激活了 VAO，OpenGL就知道去哪里寻找 VBO 的信息 

## 绘制

`glDrawArray` 函数用于直接绘制指定图元，即我们需要指定图元类型，顶点数组起始索引，顶点数量即可

# 元素缓冲对象
---

当我们需要绘制拥有重复顶点的多个图形时，为了节约空间开销，我们申请两个缓冲区来存储，一个只存储顶点数据(VBO)，一个只存储索引信息(EBO)

即 EBO 记录的是顶点的地址，我们在使用的时候是按照 EBO 的顺序来进行的，而非 VBO 顺序

> 一个顶点的数据可能非常多，而元素缓冲区中只有一个元素就可以对应一个顶点，所以我们用 VBO 存储不重复的顶点数据，而用 EBO 存储绘制顺序

## 步骤：
1. 生成缓冲区
2. 绑定至 EBO
3. 传递数据
4. 通过 glDrawElements 进行绘制

> glDraw + 绘制的顺序指定

# 总结

不同对象的不同创建方式：
1. glGenBuffers：VBO，EBO
2. glGenVertexArrays：VAO
3. glCreateShader：VertexShader，FragmentShader
4. glCreateProgram：ShaderProgram
