# 坐标系统
---

已知前提：我们使用矩阵对位移向量进行变换

目的：OpenGL 希望每次在顶点着色器运行完毕之后，都会得到一个 **标准化设备坐标(NDC)** 的顶点
- 顶点着色器输出的是裁剪坐标形式的坐标，即它是四维空间下表示的 **NDC** 坐标
- 即它还要经过 **透视除法** 这一步的转换，才是三维空间下的 **NDC** 坐标

> 标准化设备坐标：x, y, z 取值范围为\[-1, 1] 的坐标
> NDC 坐标就是裁剪空间下的坐标

这个流程总共需要经过五个不同的坐标系：
1. 局部空间
2. 世界空间
3. 观察空间
4. 裁剪空间
5. 屏幕空间

# 概述
---

## 过程综述

将坐标从一个坐标系，变换到另一个坐标系，我们需要使用到变换矩阵：
1. 局部空间 -> 世界空间：模型变换(Model)
2. 世界空间 -> 观察空间：观察变换(View)
3. 观察空间 -> 裁剪空间：投影变换(Projection)
	- 包含了正交变换，即我们不考虑 2D 下的情况，只考虑 3D 下的情况，即一定有投影变换的过程
4. 裁剪空间 -> 屏幕空间(自动进行)：视口变换(Viewport)

## 细节概况

- 模型变换：相当于对每个物体单独的仿射变换
- 观察变换：相当于对所有物体共同做仿射变换
- 投影变换：相当于对所有物体做透视变换
	1. 确定物体是否在裁剪范围内
		- 如果有跨越，就对物体做裁剪(猜测)
	2. 对物体做透视变换
	3. 将物体化作裁剪空间的 NDC 坐标
- 视口变换(自动进行)：将裁剪空间下的 NDC 坐标化作屏幕坐标(根据屏幕大小)
	- 变换出来的坐标会被送到光栅器，转化为片段

# 局部空间
---

局部空间是指以物体所在的坐标空间，对应的坐标即 localPosition

## 目的

局部空间的目的：描述物体内部之间的关系

## 模型变换

模型变换矩阵：局部空间 -> 世界空间

重点：找到局部空间和世界空间基向量之间的关系(变换到什么空间，用什么空间的单位表示，即关键是找到用世界空间的基向量表示局部空间的基向量)

线性变换：一个空间的基向量，可以由另一个空间的基向量的线性组合来表示(倍数和相加)

# 世界空间
---

世界空间：指顶点相对于游戏世界的坐标

## 目的

世界空间的目的：描述物体之间的关系

## 观察变换

观察变换矩阵：世界空间 -> 观察空间

这个变换是对全部物体整体作变换

即摄像机的模型变换的逆变换

# 观察空间
---

观察空间：也称为摄像机空间，即摄像机物体的局部空间(头顶为 +y，右手为 +x，看向 -z)

## 目的

观察空间的目的：描述从摄像机视角所观察到的空间

## 投影变换(它实际是两个矩阵)

投影变换矩阵：观察空间 -> 裁剪空间
- 透视投影(可选)
- 正交投影(必须有)

# 裁剪空间
---

裁剪空间：我们只希望观察一个特定范围内的坐标，任何在这个范围之外的点都应该被裁剪掉，在这个范围内的坐标才会被显示在屏幕上

## 目的

裁剪空间的目的：描述场景中的物体，排除出场景中无法看见的物体

## 步骤：

1. 将观察范围化为长方体
2. 以这个长方体的中心为裁剪空间的原点
3. 以长方体的三条边的边长的倒数为放缩比例，放缩这个长方体，使他变为一个边长为 2 的立方体

# 把它们都组合到一起
---

v' = P * V * M * v

即一个局部空间的位移向量，经过 model，view，projection 变换，得到裁剪空间下的位移向量

# 透视除法
---

透视除法：当变换到透视空间之后，会先进行透视除法。它会在每一个顶点着色器运行后自动执行。

## 目的

透视除法的目的：将坐标都化为 **NDC** 坐标，即 4D -> 3D

## 做法

这个过程中，我们将位置向量的 x，y，z 分量分别除以向量的齐次 w 分量

# 进入 3D
---

## 开始 3D 绘图

1. 我们创建一个模型矩阵，它会被应用到这个物体的所有顶点上，以将其变换到全局的世界空间
2. 我们创建一个观察矩阵，我们想要在场景里面向后移动一些以使得物体变得可见(相当于操作全部物体)
3. 我们创建一个投影矩阵，我们希望在场景中使用透视投影，即近大远小
	- `glm::perspective`：透视投影矩阵
		- 它已经包含了变换为标准立方体，即它等于 正交投影矩阵 * 透视变换矩阵
		- 它不用设置屏幕的大小，因为有了角度和距离，就已经确定了屏幕的大小(近平面，但是越远看的范围就越大)
	- `glm::ortho`：正交投影矩阵(变换为标准立方体的作用)
		- 变换为标准立方体即变换为裁剪空间

# 更加 3D
---

如果我们绘制一个立方体，我们会发现有些应该被遮挡的面绘制在了其他面之上

OpenGL 存储深度在一个叫做 Z 缓冲的地方，它允许 OpenGL 决定何时覆盖一个像素，何时不覆盖。

通过使用 Z 缓冲，我们可以配置 OpenGL 来进行深度测试

## Z 缓冲

OpenGL 存储它的所有深度信息于一个 Z 缓冲中，也被称为深度缓冲

GLFW 会自动生成一块缓冲用以存放深度信息(就如同它自动生成的颜色缓冲来存储图像颜色一样)

深度值存储在每个片段内部(作为片段的 z 值)，当片段想要输出它的颜色时，OpenGL 会将它的深度值和 z 缓冲进行比较，如果当前的片段在其他片段之后，它将会被舍弃，否则将会覆盖。这个过程就叫做 **深度测试**

### 启动深度测试

它默认是关闭的

```
glEnable(GL_DEPTH_TEST); //启动深度测试
glDisable(GL_DEPTH_TEST); //禁用深度测试
```

我们需要在每一帧渲染前清除深度缓冲，就如同颜色缓冲一样

```
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```

## 更多的立方体

我们可以用一个数组记录 model transform

然后我们可以利用 for 循环，多次调用 `glDrawArrays` 生成立方体


