# 变换
---

目前我们渲染出来的都是静态的物体

矩阵方便我们对物体进行变换

如果我们只能每一帧都改变物体的顶点，并重置配置的 VBO 缓冲区，就太繁琐了

# 向量
---

向量：最基本的定义就是一个方向(更正式的话可以加上一个大小)

二维中的向量，可以理解为 z 为 0 的三维向量，它仅仅表示一个方向，和它处在什么位置无关。

## 位置向量

如果我们固定这个方向的原点是 (0,0,0) ，那么它就指定了一个点，这个向量就是位置向量

# 向量与标量运算
---

标量只是一个数字，它仅仅表示大小而不表示方向。

加减乘除(仅图形学库中支持)：简单的把标量和向量的每一个分量进行对应的加减乘除运算即可

# 向量取反
---

对一个向量取反，会使其方向逆转。

取反：使用标量 -1 乘以向量即可

# 向量加减
---

向量的加法：对应分量相加即可
它表示了两个向量共同作用后的方向

向量的减法：对应分量相减即可
它表示了两个向量表示方向的差，即减数向量方向指向被减数向量方向

# 长度
---

长度：向量各分量平方之和的开方

单位向量：即长度是 1 的向量，它是向量的标准化。即它只关心方向而不关心长度。

# 向量相乘
---

普通乘法在向量上是没有定义的

## 点乘

几何：两个向量点乘，得到的是两个向量长度的积再乘以它们之间夹角的余弦值

数值：两个向量点乘，其对应分量相乘，然后相加即可

用途：可以用来判断两个方向之间的夹角(用两个单位向量点乘即可)

理解：以一个向量为一维基向量的空间，点积即另一个向量变换到这个一维空间后的结果(再用我们默认的基向量表示)

## 叉乘

前提：叉乘只在三维空间下有定义

定义：它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量(如果两个输入向量正交，那么就得到了三个互相正交的向量)

第三个向量的大小，是两个输入向量围成的平行四边形的面积

# 矩阵
---

矩阵是由一些同维度的向量组成的数组，用来表示向量的变换

> 行向量也是矩阵，可以理解为它是由一些 1 维向量组成的数组

变换：如果我们把向量的变换理解为坐标系的变换，即向量保持不变，但是在不同的坐标系下就有不同的方向和大小了。我们默认是以标准坐标系来进行的，如果我变换到另一个坐标系，即让它乘以这个矩阵，矩阵的向量成员就是这个新坐标系的基向量，即新坐标系就用这些向量来表示的

矩阵的向量个数决定了它输入空间的维度数，矩阵向量的维度数决定了它输出空间的维度数

在矩阵中：向量个数即线性无关的向量个数
1. 向量维度数 < 向量个数：即有多余的向量，它一定能表示出向量维度数这个空间
	- 可以理解为降维了，它表示了某个高维空间(旧空间)的向量变成了某个低维子空间(新空间)的向量
1. 向量维度数 = 向量个数：即正好合适，它正好能表示出向量维度数这个空间
2. 向量维度数 > 向量个数：即缺少了一些基向量，它只能表示出部分向量维度数这个空间
	- 可以理解为升维了，它表示了高维空间(新空间)的某个低维子空间(旧空间)的向量

# 矩阵的加减
---

## 矩阵与标量的加减(仅图形学库中支持)

矩阵每个向量的每个分量都与标量进行加减操作

## 矩阵的数乘

矩阵的每个向量与该标量进行乘法运算

把标量理解为缩放因子即可，即标量与矩阵相乘即缩放了它所有的元素(向量)

# 矩阵相乘
---

可以理解为多个向量与矩阵相乘后的结果，重新组成了矩阵

重点：理解矩阵与向量相乘

# 矩阵与向量相乘
---

之前我们已经用向量来表示了位置，颜色，甚至是纹理坐标

## 单位矩阵

即我们默认的空间基向量，它在某个分量上为 1，其他分量上为 0

即基向量之间是互相垂直的，即基向量之间正交

正是因为单位矩阵内都是我们默认的空间基向量，所以任何向量乘以单位矩阵都保持不变(只要他们对应)

## 缩放

对一个向量进行缩放，就是对向量的长度进行缩放，而保持它的长度不变

如果对向量的每一个分量的缩放因子都是相同的，那么是均匀缩放
如果对向量的每一个分量的缩放因子存在不同的，那么是不均匀缩放

## 位移

在同维度空间下无法表示位移

因为向量表示方向和大小，旋转改变方向，缩放改变大小，它在同维度下只能进行旋转和缩放，无法表示位移。

我们可以给向量和变换矩阵升高一个维度，并设置向量的高维度分量为 1，那么变换矩阵的新增维度的前三个分量就表示了向量的位移(在最后将结果向量的第四维分量舍去即可)

> 向量的 w 分量被称为齐次坐标。想要从齐次坐标得到 3D 向量，我们可以把 x，y 和 z 坐标分别除以 w 坐标即可(如果 w 分量是 0，那么它就不能位移，即它表示的就是方向向量，而非位移向量)

## 旋转

可以利用旋转矩阵，把任意位置向量沿一个单位旋转轴进行旋转

> 一般我们旋转的角度都用弧度

但是这会导致一个严重的问题：万向节死锁

所以一个更好的模型：沿任意一个轴旋转，而非对一系列旋转矩阵进行复合(可以利用旋转矩阵)

> 这只能极大地避免万向节死锁。真正解决万向节死锁的方案是使用四元数

# 矩阵的组合
---

使用矩阵变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中

1. 矩阵的运算的几何意义是从右向左进行的，即先进行右边的变换，再进行左边的变换
2. 如果要按照矩阵分量的几何意义(如第四列的前三个分量表示位移)来分解矩阵，那么要先进行线性变换再进行仿射变换

# 实践
---

OpenGL 没有自带任何的矩阵和向量的知识，所以我们必须定义自己的数学类和函数

GLM：专门为 OpenGL 量身定做的数学库

# GLM
---

即 OpenGL Mathematics 的缩写，它是一个只有头文件的库，无需提前编译链接

> GLM 库从 0.9.9 版本开始，默认将矩阵初始化一个零矩阵，而非单位矩阵

```
#include <glm/glm.hpp> // 包含所有基本数学功能，包含向量，矩阵，四元数等类型和函数
#include <glm/gtc/matrix_transform.hpp> // 包含一些常用的变换，如平移，旋转，缩放等
#include <glm/gtc/type_ptr.hpp> // 包含一些帮助将矩阵和向量数据传递给着色器的函数
```

## 一些例子

```
glm::mat4 trans = glm::mat4(1.0f); // 初始化矩阵，并初始化为单位矩阵
trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f)); // 为矩阵添加一个位移
trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0)); // 为矩阵添加一个旋转(注：在我的电脑上第二个参数是角度，即直接使用 90.0f)
trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5)); // 为矩阵添加一个缩放
```
## 将矩阵传递给着色器

1. 在顶点着色器中声明 uniform 的 mat4 类型的矩阵变量
	- 可以用这个类型的矩阵变量执行矩阵操作
2. 在 CPU 程序中传递变换矩阵给 GPU 程序的 mat4 类型变量
	- `glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));`
	- 即传递 trans 的首元素指针即可，因为 OpenGL 和 GLM 都是列优先的

# GLFW 时间函数
---

获取 GLFW 运行的时间：
```
double time = glfwGetTime();
```















