# 纹理
---

我们可以利用纹理，给每个顶点数据增加额外的顶点属性。

只需要每个顶点数据中都有位置和纹理坐标这两个顶点属性即可。
1. 位置：确定是哪一个顶点
2. 纹理坐标：确定是纹理的哪个部分

纹理坐标在 x 轴和 y 轴上，范围在 \[0,1] 之内，纹理图的左下角为(0,0)坐标。

使用纹理坐标获取纹理颜色的过程叫做采样。

因为可能无法做到一一对应的效果(我们采样点和纹理点无法重合)，所以我们可以采用几种不同的插值方式来进行纹理采样。

# 纹理环绕方式
---

纹理环绕方式解决的是纹理坐标在范围之外时，该如何处理。

## 纹理环绕方式：

|环绕方式|描述|
|---|---|
|GL_REPEAT|重复纹理图像(默认)|
|GL_MIRRORED_REPEAT|镜像重复纹理图像|
|GL_CLAMP_TO_EDGE|重复纹理图像边缘|
|GL_CLAMP_TO_BORDER|指定颜色填充|

## 设置纹理环绕方式

上述的每个选项，都是针对一个坐标轴的，如：
```
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT)
```
纹理的坐标轴为：s、t、r

# 纹理过滤
---

纹理坐标不依赖于分辨率，它可以是任意浮点值。所以我们需要知道如何将一个纹理坐标映射到一个纹理像素上。

可以理解为像素的大小都是相同的，即当物体和纹理的分辨率相同时(如都是 512\*512)，它们的像素一定是一一对应的关系，否则将无法对应上去。

可以分为纹理过滤和一个纹理图像优化
需要纹理过滤的两种情况：
1. 纹理放大：即纹理大小小于物体大小，纹理像素会被拉伸
2. 纹理缩小：即纹理大小大于物体大小，纹理像素会被压缩
	- 纹理图像优化：多级渐远纹理：Miama

## 纹理放大

即我们有一个 40\* 40 的纹理，却要贴到 256 \* 256 的画布上去，相当于一个纹理像素需要对应多个画布像素，即相当于把 40 \* 40 的纹理放大到 256 \* 256。这被称为纹理放大。

### 处理方式：线性过滤

一般采用线性过滤的方式比较好，以避免出现马赛克的情况。

总结：即提升纹理细节，在一个像素内，进行更加细化的区分

## 纹理缩小

将高分辨率的纹理贴到低分辨率的物体上，即一个 pixel 覆盖了 多个 texel，即相当于把高分辨率的纹理进行压缩，压缩为低分辨率的纹理。这被称为纹理缩小

### 处理方式：邻近过滤，Mipmap

#### 邻近过滤

默认的处理方式(包括纹理放大)，即在一个像素内，无论采样点是否和像素中心重合，都用这个像素代替

#### Mipmap

建立一系列不同尺寸的多级纹理，然后在使用时使用正确的纹理图像：
1. 通过线性插值，找到和物体相同大小的纹理(需要用到两次线性插值)
2. 通过邻近过滤，找到最接近物体大小的纹理(纹理大小仍小于物体大小)，然后通过纹理放大的方式(线性过滤)进行处理

总结：即降低纹理细节，即在一个像素内部不再进行区分，无论你选择了像素内部的什么坐标，即使和像素中心不重合，也都使用同一个值


|过滤方式|描述|
|---|---|
|GL_NEAREST_MIPMAP_NEAREST|多级渐远纹理之间邻近插值，纹理内部邻近插值|
|GL_LINEAR_MIPMAP_NEAREST|多级渐远纹理之间邻近插值，纹理内部线性插值|
|GL_NEAREST_MIPMAP_LINEAR|多级渐远纹理之间线性插值，纹理内部邻近插值|
|GL_LINEAR_MIPMAP_LINEAR|多级渐远纹理之间线性插值，纹理内部线性插值|

# 加载与创建纹理
---

## 使用 stb_image.h 库来进行图像的加载

1. 提前进行宏定义 `#define STB_IMAGE_IMPLEMENTATION`
2. 包含头文件：`#include "stb_image.h"
3. 加载图像：
```
int width, height, nrChannels;
unsigned char* data = stbi_load("container.jpg", &width, &height, &nrChannels, 0);
```

# 生成纹理
---
1. 创建纹理对象
2. 绑定纹理状态
3. 设置纹理处理方式
4. 加载图片资源
5. 生成纹理图像(CPU -> GPU)
6. 创建 Mipmap
7. 释放图片资源

# 应用纹理
---

1. 添加纹理坐标
2. 传递纹理对象
	- 创建采样器：`uniform sampler2D ourTexture`
		- GLSL 有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀
		- 使用 `glBindTexture` 绑定纹理，它就会自动把纹理赋值给片段着色器
	- 加载纹理图像中对应的数据：`texture(ourTexture, TexCoord);`
		- 这是 GLSL 内建的 texture 函数，用以对指定纹理进行采样并获取颜色

# 纹理单元
---

## sampler2D

sampler2D 变量是一个 uniform 类型，但是它很特殊。不用我们手动 glUniform 给它赋值。

## 纹理单元

纹理的位置值通常被称为是一个纹理单元。如果只有一个纹理，那么它的默认纹理单元是 0，它是默认激活的纹理。

纹理单元的目的：让我们在着色器中可以使用多于一个的纹理，并可以自动把纹理单元赋值给采样器。

步骤：
1. 激活对应的纹理单元
2. 绑定指定的纹理单元
3. 设置纹理单元和采样器的对应关系(索引从 0 开始)
 > 可以使用 GLSL 的内置函数 mix 来进行颜色的线性插值混合

就好像是有一个数组，按序存储着所有的纹理图像资源，默认情况下只有 0 位置是激活的。

在 sampler2D 找纹理时，它根据 uniform 设置的索引值，自动去这个纹理数组中获取对应的纹理资源。

我们在为纹理资源赋值时，需要激活纹理单元。

可以理解为 GL_TEXTURE_2D 是总开关，默认下面 0 是开着的，即如果默认的话给 GL_TEXTURE_2D 赋值时，自动给 GL_TEXTURE0 赋值。 使用时，如果没有用 uniform 给 sampler2D 赋值，那么它默认值是 0

当我们显式的激活下面的纹理单元时，给 GL_TEXTURE_2D 赋值时，就会给对应的纹理单元赋值。当然在使用前，还要给对应的 sampler2D 赋索引值，以便它可以在纹理数组中找到对应的纹理。




