# 2.1 综述

什么是流水线？
- 即整个过程中，每一步只考虑自己。自己完成后，就可以进行下一个输入了，而无需关注后续是如何处理自己的输出的

什么是渲染流水线？
- 应用阶段
	- 通常由 CPU 实现，在这个阶段，我们拥有绝对的控制权
	- 它有三个主要任务：
		1. 准备好场景数据(摄像机位置，视锥体，模型，光源等)
		2. 为了提高性能，进行一次粗粒度剔除工作，将不可见的物体剔除
		3. 设置好每个模型的渲染状态(材质，纹理，Shader等)
- 几何阶段
	- 处理和我们绘制的几何相关的事情
	- 通常由 GPU 实现
	- 它将输出屏幕空间的二维坐标，以及每个顶点对应的深度值，着色等相关信息
- 光栅化阶段
	- 产生屏幕上的像素，并渲染出最终的图像
	- 也是由 GPU 实现的
	- 它决定了每个渲染图元中哪些像素应该被绘制在屏幕上

上面说的只是一个整体的概念

# 2.2 CPU 和 GPU 之间的通信

渲染流水线的起始点是 CPU，即应用阶段
- 把数据加载到显存中
- 设置渲染状态
- 调用 Draw Call

## 加载数据

数据的流向：硬盘->RAM->显存

## 设置渲染状态

渲染状态：定义了场景中的网格是怎样被渲染的

## 调用 Draw Call

实际上，Draw Call 就是一个命令，它的发起方是 CPU，接收方是 GPU

这个命令会指向一个需要被渲染的图元列表。使用的渲染状态是在上一个阶段设置的。

然后 GPU 就开始渲染了，即 GPU 渲染流水线开始了

# 2.3 GPU 流水线

几何阶段：
1. 顶点着色器
	- 每个顶点都会调用一次顶点着色器
	- 主要的工作：坐标变换(到齐次裁剪空间)，逐顶点光照，为后续阶段提供数据
2. 曲面细分着色器
3. 几何着色器
4. 裁剪
	- 一个图元和摄像机视野有三种关系：
		- 完全在视野内：继续传递
		- 部分在视野内：裁剪
		- 完全在视野外：不再传递
	- 针对部分在视野内的，使用新顶点来代替在视野外的顶点，新顶点就在这条线段和视野边界的交点处
	- 此时是在标准立方体下，所以裁剪变的很容易了(硬件实现)
5. 屏幕映射
	- 它的任务是将图元的 x 和 y 坐标转换到屏幕坐标系下(不会对 z 坐标做任何处理)
	- 注意：OpenGL 是左下角为原点，DirectX 是左上角为原点

光栅化阶段：两个大任务，计算图元覆盖的像素，为像素计算他们的颜色
1. 三角形设置
	- 光栅化一个三角网格所需的信息
	- 上一个阶段输出的都是顶点，在这里我们需要将顶点连接成面(得到三角形边界的表示方式)
2. 三角形遍历
	- 检查每个像素是否被一个三角网格所覆盖，如果被覆盖的话，就会生成一个片元
	- 会根据上一个阶段的计算结果，判断一个三角网格覆盖了哪些像素，并进行插值
	- 这一步输出的是片元序列，它不等于像素，而是包含了很多状态的集合
3. 片元着色器
	- 它的输入是上一个阶段的插值的结果
	- 它可以完成很多渲染技术(如纹理采样等)
4. 逐片元操作
	- 决定每个片元的可见性，通过深度测试，模板测试等
		- 模板测试：通过设置该位置的模板值，和指定的参考值作比较
		- 深度测试
		- 大多数 GPU 会尽可能在执行片元着色器之前就进行这些测试(如Unity的深度测试就是在前面的)
	- 如果一个片元通过了所有测试，就需要把它的颜色值和颜色缓冲区中的颜色进行混合
		- 不透明的物体，我们可以关闭混合，即直接覆盖就可以了
	- 这一步才是真正对像素进行操作

# 2.4 一些容易困惑的地方

什么是 Draw Call？

即 OpenGL 中的 glDrawElements 命令，即命令 GPU 进行渲染的操作，造成 Draw Call 的性能问题元凶是 GPU，但其实是 CPU

CPU 和 GPU 如何实现并行工作？

命令缓冲区：
- 命令队列

CPU 向命令缓冲区内添加命令，GPU 从中读取命令，添加和读取的过程是互相独立的。命令缓冲区可以使得 CPU 和 GPU 相互独立工作

Draw Call 就是命令缓冲区中的一种命令，其他还有改变渲染状态等命令

为什么 Draw Call 多了影响帧率？
每次调用 Draw Call 之前，CPU 都会向 GPU 发送很多内容，如数据、状态等，还会进行检查渲染状态等操作，而 GPU 的渲染能力是很强的。所以可能会出现 GPU 完成了所有操作，而 CPU 还没有向命令缓冲区补充命令的情况。

即每次 Draw Call，CPU 很慢，而 GPU 很快。提交大量很小的 Draw Call 会造成 CPU 的性能瓶颈，即 CPU 把大部分时间都花费在准备 Draw Call 上了

如何减少 Draw Call？

1. 批处理：将很多小的 Draw Call 合并为一个大的 Draw Call。前提是这些网格都只能使用一种渲染状态
2. 避免使用大量很小的网格
3. 避免使用过多的材质