### 定位瓶颈

Drawcall是影响渲染性能的很大一部分因素：
- Drawcall是CPU向GPU发送一条渲染指令
	- 附带了顶点信息
	- 材质信息
- CPU和GPU的交互是很浪费时间的
- 所以，我们要尽量减少Drawcall

查看状态：stata
- Batches：批次
- SetPass calls：渲染状态切换数

### UI的选择

NGUI：
- 全部代码基于C#开发，会有GC问题

UGUI：
- 部分代码基于原生C++开发，性能较高
- 基于Canvas，优化层面做的更好

尽量选择UGUI

### Canvas优化要点

Unity在绘制的时候是基于Canvas进行合并绘制的
- Unity为了性能优化，会合并Canvas下所有的元素，即一个Canvas就是一个批次
- Canvas下的任何一个游戏对象发生变化，都会造成重绘(Redraw)
	- 当Canvas过大时，重绘会造成较大的性能下降
	- 因为一个Canvas就是一个Mesh

>王者荣耀中，左下角的控制移动窗口有个箭头，会经常进行移动。如果我们把它和主界面放在一起，那么每次玩家通过控制窗口移动时都会引起包括主界面在内的重绘，会极大的增加性能开销

##### 动静分离

动静分离：将Canvas进行细分
- 不变的放在一个Canvas上
- 经常变化的放在一个Canvas上

这样在某个UI元素发生变化的时候，只会引起当前Canvas的重绘，不会引起其他Canvas的重绘

##### 图集

每次使用图片的时候，都会将包含这个图片本身的整个图集加载到内存中，之后再使用时，就直接从内存中的图集中寻找相应的图片，而不用重新加载图集

我们应该将同一个面板上的图片打到同一个图集里面：
- 它们一般是同时使用的，所以我们可以一次性将它们全部加载到内存中去，提升性能
- 如果打到不同的图集中，会在内存中同时存在很多的图集，但是其他的图片又不使用，引起了内存损耗，并降低了性能
- 注：背景大图不要和小图放在一起

### Overdraw

我们希望在绘制屏幕上的像素的时候，只绘制一次：如果绘制了多次，就说明发生了Overdraw
- 绘制到帧缓冲区是很昂贵的，所以我们希望尽量减少Overdraw
- 当前面的是不透明的物体时，如果Overdraw，它会将后面的物体遮挡，效果完全等价
- 但是对于透明的物体，我们似乎只能进行Overdraw了，因为我们不仅要绘制后面的物体，还要绘制前面的物体

可以在Unity的窗口中查看Overdraw窗口，颜色越深说明该处绘制的越多

Unity会尽量由近及远的绘制不透明物体，以便剔除掉被遮挡物体的像素
- 但是由于某些复杂的物体，会导致渲染队列的混乱，从而引起Overdraw
- 应该就是画家算法的弊端

##### 解决办法

减少不透明的Overdraw：
- 从根源的角度去避免
	- 将对象拆分成较小的子对象，以便Unity更好的排序
	- 用精灵制作紧密的网格(Mesh Type: Tight)
		- 如果用Full Rect：仅支持全四方渲染，将可绘制的UI元素彼此堆叠非常容易
- 从预防的角度去避免
	- 禁用不可见的UI：当一个UI被完全遮挡时，直接禁用它
		- 一个UI，即使是它的Alpha为0，也会参与绘制的，即增加了Overdraw
	- 不要使用空的Image

### 其他

- 不点击的物体不要挂：GraphicsRaycaster
- 少用LayoutGroup和Content Size Fitter
	- Layout：遍历SetDirty对象会消耗性能