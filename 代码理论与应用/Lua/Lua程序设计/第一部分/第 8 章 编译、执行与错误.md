# 引言
---

尽管 Lua 是一种解释型语言，但是它在运行源代码之前：
- 先将源代码预编译为一种中间形式

区别解释型语言的主要特征并不在于是否能编译它们：
- 而是在于编译器是否是语言运行时库的一部分
- 即是否有能力执行动态生成的代码
- 正是因为存在了诸如 dofile 这样的函数，才可以将 Lua 称为是一种解释型的语言

# 8.1 编译
---

两个内置操作：
- loadfile 函数：从一个文件中加载 Lua 代码块
	- 但它不会运行代码，只是编译代码
	- 然后将编译结果作为一个函数返回
	- 它不会引发错误，只是会返回错误值，且不会处理错误
- dofile 函数：运行 Lua 代码块
```
function dofile(filename)
	local f = assert(loadfile(filename))
	return f()
end
```

对于简单的任务，dofile 非常便捷，然而 loadfile 更加灵活，因为它会返回 nil 及错误消息：
- 如果要多次运行一个文件，那么在运行一次 loadfile 后，多次调用它的返回结果就可以了
- 这样只用编译一次，不像 dofile

还有 loadstring 函数：
- 它只是从一个字符串中读取代码，而非文件
- 它的功能非常强大，但也应该谨慎使用，因为它的开销也较大
- 它总是在全局环境中编译这个字符串
- 它最典型的用途就是执行外部代码

Lua 将所有独立的程序块视为一个匿名函数的函数体，且该函数具有可变长的实参

在 Lua 中，函数定义是一种赋值操作：
- loadfile 只是进行了编译，返回了一个执行函数的入口
- 只有执行了这个返回值，才把这个文件执行了一次

# 8.2 C 代码
---

C 代码在使用前需要先链接入一个应用程序：
- 动态链接机制
- 通过 package.loadlib 函数

# 8.3 错误
---

有一个内建函数 assert 来完成此类处理工作：
- 首先检查第一个参数是否为 true，否则就引发了错误
- 第二个参数是一个可选的信息字符串

# 8.4 错误处理与异常
---

如果需要 Lua 中处理错误，则必须使用函数 pcall 来包装需要执行的代码

# 8.5 错误消息与追溯
---

