# 4.1 赋值
---

Lua 允许多重赋值：
- 即一下子将多个值赋予多个变量
- 每个变量和每个值之间用逗号分隔
- 它先对等号右边的所有元素求值，再执行赋值
	- 这样就可以用一个多重赋值语句来交互两个变量了
- 如果有多余的值，会被舍弃；如果有缺少的值，会用 nil 进行赋值

# 4.2 局部变量与块(block)
---

局部变量：
- local
- 它的作用域仅限声明的它的那个块

显式界定一个块：
```
do
	<content>
end
```

尽可能使用局部变量：
- 这是一种良好的编程风格
- 访问局部变量快，且可以进行 GC
- 避免将无用的名称引入全局变量

一些使用方法：
- `local foo = foo`
	- 它用全局变量初始化局部变量
	- 这样在改变全局变量时，可以先在局部变量存储
	- 可以加速当前作用域中对 foo 的访问

# 4.3 控制结构
---

## 4.3.1 if then else

如果使用嵌套的话：elseif

由于 Lua 不支持 switch，所以这种一连串的 if-elseif 还是很常见的

## 4.3.2 while

```
while <condition> do
	<content>
end
```

## 4.3.3 repeat

```
repeat
	<content>
until <condition>
```

与其他语言不同的是，在 \<condition> 中，仍然可以访问到 \<content> 中的局部变量

## 4.3.4 数字for

```
for var=exp1,exp2,exp3 do
	<content>
end
```

如不指定 exp3，则默认步长是 1

可以通过 break 跳出循环

for 循环的一些特点：
- 这三个表达式是在循环开始就一次性求值了
- 控制变量会被自动声明为 for 语句的局部变量，并仅在循环体内可见
- 不能在循环中改变控制变量的值，否则会导致不可预知的效果
	- 如果希望提前终止，使用 break

## 4.3.5 泛型for

它通过一个迭代器函数来遍历所有的值

标准库提供的几种迭代器：
- 迭代文件中每行：io.lines
- 迭代 table 元素：pairs
	- 如果是纯字符串的话，它按照插入的顺序排序的
	- 如果是数组 + 字符串，就很奇怪了
- 迭代数组元素：ipairs
- 迭代字符串中单词：string.gmatch
- 等等 - 甚至可以编写自己的迭代器

语法：
```
for key,value in {迭代器}(迭代器对应类型) do
	<content>
end
```

特点：
- 可以省略不写 value
- 循环变量是循环体的局部变量
- 绝不应该对循环变量做任何赋值

## 4.3.6 break 与 return

break：结束一个循环
- for 循环
- repeat 循环
- while 循环

return：从一个函数中返回结果
- 它可以是隐式的

注意：
- break 和 return 只能是一个块的最后一条语句
- 即如果我们希望提前终止操作，不能简单的在前面直接使用 break 或 return
	- 只能是 end, else, until 的前一条语句
	- 因为这些是一个块的终止符号
	- 如果希望提前终止，可以在前面使用 do end 来终止
		- 如：`do return end`