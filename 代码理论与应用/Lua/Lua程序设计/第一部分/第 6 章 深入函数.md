# 引言
---

函数作为第一类值函数：
- Lua 中的函数与其他传统类型的值具有相同的权利
- 即可以存储到变量中，table 中，作为实参传参， 作为函数返回值等

且函数具有特定的语法域：
- 即一个函数可以嵌套在另一个函数内
- 内部函数可以访问外部函数中的变量

函数名：实际上是一个持有函数的变量
- 个人理解，它是一个指向函数的指针
- 即改变该函数变量无法改变函数

```
function foo(x) return 2*x end

foo = function(x) return 2*x end
```

这两种声明方式完全相同，第一种方式好像就是一种语法糖，是第二种的简化写法：
- 因此一个函数定义，实际上就是一个赋值语句
- 上面的代码，就相当于创建了一个函数类型的对象，并将其赋值给一个变量罢了

匿名函数：在参数传递中很好用

高阶函数：即参数中函数的参数

# 6.1 closure(闭合函数)
---

closure：就是一个函数加上该函数所需访问的所有"非局部变量"
- 其实 Lua 中只有 closure，没有函数；函数本身就是一种特殊的 closure
- closure 就是闭包

可以使用同样的技术来创建一个安全的运行环境，即"沙盒"：
- 当执行一些未受信任的代码时
- 比如当需要限制一个程序访问文件的话，使用 closure 重定义 io.open 即可

# 6.2 非全局函数
---

可以用：
```
Lib.foo = function(x,y) return x+y end

function Lib.foo(x,y) return x+y end
```

对于程序包(package)而言，这种函数非常有用：
- 因为 Lua 是将每个程序块作为一个函数来处理的
- 所以在一个程序块中声明的函数就是局部函数

局部函数递归常出现的问题：
```
local fact = function(n)
	if n == 0 then return 1
	else return n * fact(n-1)* -- 错误，此时 fact 还未声明，访问的是全局的 fact
	end
ene
```

需要在前面加上声明 `local fact` 即可

# 6.3 正确的尾调用
---

Lua 函数有一个有趣的特征：Lua 支持尾调用消除
- 尾调用：类似 goto 的函数调用
- 当一个函数调用的是另一个函数的最后一个动作时，该调用才算是一条"尾调用"
```
function f(x) return g(x) end
```

尾调用的好处：
- 正常函数调用，都会再拉栈；而尾调用告诉了解释器这是最后一步，即没有什么栈空间需要保存了，即可以用当前栈继续执行，不用拉栈了
- 使用尾调用，永远不会造成栈溢出

注意：一定是完成另一个函数后可以立即返回，才是尾调用
- `return g(x) + 1`：等这种实现，都不是尾调用