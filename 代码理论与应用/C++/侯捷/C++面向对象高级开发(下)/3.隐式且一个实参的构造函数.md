# non-explicit-one-argument ctor
---

这种只有一个实参的构造函数，且没有用关键字 explicit 修饰：
- 它有一个额外的功能
- 即将其他类型转换为这个类类型
	- 正好就和转换函数相反了
- 如果那个类型和这个实参类型相同的话，就可以构建这个对象了

转出去：转换函数
转回来：构造函数

注意：有可能造成二义的错误
- 即同时定义了构造函数和转换函数
- 又定义了运算符重载函数
- 此时，可能会出现一个式子中，编译器无法知道要将一个转出去，还是将一个转回来
	- 此时就报错了

# explicit-now-argument ctor
---

此时，这个构造函数就是显式的了，如：`explicit Fraction(int num);`

这时，就不会用这个构造函数做转换了：
- 即必须标准的通过构造函数调用的形式，才可以使用它

注意：如果定义了运算符重载函数，就会优先使用运算符重载
- 如果运算符重载用不了就会报错
- 即使它可以通过转换函数转换为其他类型，也不会调用的