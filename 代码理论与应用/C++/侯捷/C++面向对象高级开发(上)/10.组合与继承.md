在之前，我们一直学的是基于对象的编程：
- 即编写单一的类
- 整个类不会和其他类产生关联

现在，我们要学习基于面向对象的编程：
- 即类与类之间是有关系的
- 类与类之间的三大关系
	- 继承
	- 组合
	- 委托

### 组合

has a 的关系

- 即一个类中有其他类的类型成员
- 说明这个类，可以完全使用它包含类的全部功能
	- 但是它可以不对外开发，即表现甚至为收缩了功能

构造的关系：先内后外
- 外部的类，应该先执行内部类类型的成员的构造函数，然后再执行自己的
- 这是一种由内而外的思想

析构的关系：由外而内
- 先执行自身的析构函数，再执行内部的析构函数

这个顺序编译器会自动管理的，我们不用显式的写出来：
- 注意：编译器调用的被包含的类成员的默认构造函数
- 如果我们不希望它调用默认构造函数，就显式的写出来调用的构造函数
	- 即 func() : func2()

## 委托

一个类拥有另一个类成员的指针：
- 注意，它只是拥有指针，并没有直接拥有它的对象

在需要你的时候，我才会把任务委托给你：
- 它们的生命周期并不一致

好处：只是把任务委托给这个类成员
- 这个类成员怎么实现的，我们可以完全不管
- 即它可以有任何的实现类，或者之后的任何更改
- 我们这个对外的接口都可以不变

一种经典的设计模式：
- 手柄/体系结构：Handle/Body
- 指向实现：Pimpl
	- Pointer to Implementation

一个 Handle 类仅包含一个指向实现其所有细节的私有指针
- Handle 类充当公共接口
- 实际的实现细节都隐藏在私有实现类 Body 中

这样可以实现可不多代码与实现细节解耦(通过 Handle 类)：
- 可以减少编译时依赖和提高代码的模块化性

## 继承

is a 的关系

表示它是其的一种：
- 父类的数据被完全的继承下来

它和组合一样，都是一个类包含着另一个类

构造函数的执行顺序：由内而外
- 先调用父类的构造函数
- 再调用子类的构造函数

析构函数的执行顺序：由外而内
- 先执行子类的析构函数
- 再调用父类的析构函数
	- 注意：父类的析构函数一定是 virtual
	- 否则会出现 undefined behavior

当然，这也是编译器自动完成的：
- 记着如果构造函数不想调默认，就需要显式自己调用了

继承：一定要搭配虚函数