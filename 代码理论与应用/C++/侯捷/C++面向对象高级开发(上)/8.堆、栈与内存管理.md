Stack：
- 即栈空间
- 是处在作用域内的内存空间
- 如：函数
- 栈对象在离开作用域后，会被自动清理掉

Heap：
- 即堆空间
- 它是一块全局的内存空间
- 可以在程序的任何地方分配其内存
	- 也有责任去释放它

Static：
- 即静态空间
- 静态对象在离开作用域后，仍然存在，直到整个程序结束
- 因为静态对象是在静态空间中存储的
Global：
- 即全局空间
- 即作用域之外的地方
- 它的生命周期也是直到整个程序结束后

### new分配内存的过程

过程：
```
void* mem = operator new(sizeof(Complex));
pc = static_cast<Complex*>(mem);
pc->Complex::Complex(1,2);
```
- 先申请内存空间
	- operator new 是一个特别的函数
	- 它在内部也是调用 malloc 来进行申请内存
- 然后进行指针的类型转换
- 再执行构造函数

### delete释放内存的过程

过程：
```
Complex::~Complex(pc);
operator delete(pc);
```
- 即先执行析构函数
- 再释放内存
	- operator delete 是一个特殊的函数
	- 内部调用的 free 函数来释放内存


### 动态分配内存的内存块

基于 VC 下：

new 分配的内存块：
- 第一部分(开头)
	- cookie 内存
	- 一个字，4个字节
	- 记录整个内存的大小
	- 最后一位用于标记是否被分配，1 表示分配，0 表示已收回
- 第二部分(调试模式才有)
	- 8 字 ，32 个字节(4 \* 8)
	- 每块是 4 个字节(个人猜测：是因为 32 程序的缘故)
	- 最后紧邻数据的是4个0xfd
- 第三部分(数据)
	- 数据真正的内存大小
	- 数据是连续存储的
- 第四部分(调试模式才有)
	- 1 字，4 个字节
	- 4 个 0xfd
- 第五部分(填充)
	- 填充字节
	- 如果总字节数不足 16 的倍数，填充至 16 的倍数
	- 为了保证开头和末尾的字节的最后一位是 0
- 第六部分(结尾)
	- cookie 内存
	- 一个字，4个字节
	- 记录整个内存的大小
	- 最后一位用于标记是否被分配，1 表示分配，0 表示已收回


new 动态分配的数组：
- 第一部分：同上
- 第二部分：同上
- 附加部分：
	- 一个字节，存储了数组的大小
- 第三部分：
	- 即存储的数组数据
	- 连续存储的
- 第四部分：同上
- 第五部分：同上
- 第六部分：同上

如果delete时不使用\[]会造成内存泄漏：
- 但不是一般意义上的内存泄露，因为毕竟开头和结尾的cookie都记录了整个内存的大小
- 但是如果不使用\[]，就只会调用一次析构函数
	- 导致如果其他成员也是指针，就造成了内存泄漏
- 如果使用了\[]，就会根据附加部分记录的大小，依次对其调用析构函数
	- 从而可以正确的释放所有内存