# 3.1 符号表

符号表的目的：将一个键和一个值联系起来

符号表就是键值对：
1. 支持插入操作
2. 支持查找操作

## 3.1.1 API

符号表是抽象数据类型，需要一些 API 定义这些操作：
1. 创建
2. 存储键值对
3. 获取 key 对应的值
4. 删除 key 和对应的值
5. 判断 key 是否有对应的值
6. 表是否为空
7. 表中的键值对数量
8. 表中的所有键的集合

## 3.1.1.1 泛型

## 3.1.1.2 重复的键

我们的规则：
1. 每个键只对应一个值
2. 当存储发生冲突时，新的值会替代旧的值

### 3.1.1.3 空键

键不能为空

### 3.1.1.4 空值

不允许有空值

### 3.1.1.5 删除操作

删除有两种操作方式：
1. 延时删除：先将值置空，在某个时间段统一删除空的键
2. 即时删除：立即删除指定的键位

### 3.1.1.7 迭代

### 3.1.1.8 键的等价性

## 3.1.2 有序符号表

### 3.1.2.1 最大键和最小键

### 3.1.2.2 向上取整和向下取整

### 3.1.2.3 排名和选择

### 3.1.2.4 范围查找

### 3.1.2.5 例外情况

### 3.1.2.6 便捷方法

## 3.1.4 无序链表中的顺序查找

符号表的一个实现：链表

它只能进行顺序查找，即按顺序一个一个进行比较(效率低下)

## 3.1.5 有序数组中的二分查找

它使用的是一个平行数组：
1. 一个存储键
2. 一个存储值

#### 3.1.5.1 二分查找

1. 递归实现
2. 非递归实现

## 3.1.6 对二分查找的分析

二分查找很快，但是仍然存在问题：
1. 在键是随即排列的情况下，构造一个基于有序数组的符号表所需要访问数组的次数是数组长度的平方级别
2. 因为它需要随机访问，所以它是基于有序数组的，如果是链表或其他不支持随机访问的就比较困难了

## 3.1.7 预览

一般情况下，二分查找都比顺序查找要快的多。也是众多应用程序的最佳选择。

但是它对插入不友好：它需要随机存储，插入友好的是非随机存储

# 3.2 二叉查找树

我们需要一个能快速查找的，也能快速插入的(就需要链式结构了)

BST：二叉查找树(Binary search Tree)

左子树都比根结点小，右子树都比根结点大

## 3.2.1 基本实现

重点：1.查找 2.插入

### 3.2.1.1 数据表示

结点：
1. 键
2. 值
3. 左指针
4. 右指针
5. 结点计数器

### 3.2.1.2 查找

查找一个键有两种情况：
1. 键在表中，查找命中然后返回值
2. 未命中，返回 null

### 3.2.1.3 插入

#### 3.2.1.4 递归

## 3.2.2 分析

二叉查找树的运行时间取决于树的形状，平衡状态下达到最好的情况

如果输入均匀的话，它和快速排序就非常相似了

## 3.2.3 有序性相关的方法与删除操作

### 3.2.3.1 最大键和最小键

### 3.2.3.2 向上取整和向下取整

### 3.2.3.3 选择操作

### 3.2.3.4 排名

### 3.2.3.5 删除最大键和删除最小键

### 3.2.3.6 删除操作

用后继结点替换它的位置

### 3.2.3.7 范围查找

### 3.2.3.8 性能分析

它也依赖键的随机分布，以消除长路径

# 3.3 平衡查找树

前面说的算法在最坏情况下性能还是很糟糕，而平衡查找树可以保证无论如何构造它，它的运行时间都是对数级别的

即我们希望在一颗含有 $N$ 个结点的树中，树高为 $log_2{n}$，此时它的效率就和二分查找一样了

## 3.3.1 2-3 查找树

2-结点：两条链接+一个键
3-结点：三条链接+两个键

2-3 查找树：既有 2-结点，也有 3-结点

### 3.3.1.1 查找

判断键是否在树中：
1. 键和结点中的其中一个相等：查找命中
2. 根据比较键和结点的比较结果，递归到相应子树中寻找

### 3.3.1.2 向 2- 结点中插入新键

如果查到了一个 2- 结点，它后续没有了且结点中没有。就插入到 2- 结点中，使其变为 3- 结点

### 3.3.1.3 向一颗只含有 3- 结点的树中插入新键

因为此时结点中已经有两个键了，所以要进行两步操作：
1. 将新键插入该结点中，使其成为一个 4- 结点
2. 再将其转换为 3 个 2- 结点组成的小树即可

### 3.3.1.4 向一个父结点为 2- 结点的 3- 结点中插入新键

为了保持平衡：
1. 同上，将新键插入成为 4- 结点
2. 中间的不再被分解为 2- 结点，而是插入到父结点中使其成为 3- 结点

这样可以保证平衡性不被破坏

### 3.3.1.5 向一个父结点为 3- 结点的 3- 结点中插入新键

同上，只是需要递归了。因为父结点被插入后也变为 4- 结点了，此时需要再向上插入了。

### 3.3.1.6 分解根结点

如果从插入结点到根结点的路径都是 3- 结点，那么最终根结点就会被变为一个临时的 4- 结点。

此时，我们可以按照之前的方法，将其分解为 3 个 2- 结点即可

### 3.3.1.7 局部变换

将一个 4- 结点分解有 6 种情况：
1. 无父(一种)
2. 父为 2- 结点(两种)
3. 父为 3- 结点(三种)

它的特点就是变换都是在局部发生，不影响树的其他部分

### 3.3.1.8 全局性质

所有局部变换都不会影响到树的有序性和平衡性

它是从下向上构建和，这和二叉搜索树正好相反

## 3.3.2 红黑二叉查找树

### 3.3.2.1 替换 3- 结点

红黑二叉查找树的基本思想：用一些额外信息来替换 3- 结点，以保证树中的结点都是 2- 结点

我们将树中的链接分为两种类型：
1. 红链接：将两个 2- 结点连接起来构成一个 3- 结点
2. 黑链接：2-3 树中的普通链接

相当于是将 3- 结点拆分开了，其中多出的链接就是红链接

### 3.3.2.2 一种等价的定义

红黑树的另一种定义：
1. 红链接均为左链接
2. 没有任何一个结点同时与两条红链接相连
3. 该树是完美的黑色平衡，即空链接到根结点的路径上的黑链接数量相同

### 3.3.2.3 一一对应

无论我们如何理解，红黑树都既是二叉查找树，也是 2-3 树

我们可以结合两个算法的优势：
1. 二叉查找树的高效查找方法
2. 2-3 树中的高效平衡插入算法

### 3.3.2.4 颜色表示

因为每个结点都只有一个父链接，所以我们可以将链接的颜色保存在结点中

### 3.3.2.5 旋转

在实际操作中，可能会出现红色右链接和两条连续的红链接，当碰见这种情况我们会通过旋转修复它

红色右链接转化为左链接：左旋转

### 3.3.2.6 在旋转后重置父结点的链接

旋转可以保持红黑树的两个重要性质：
1. 有序性
2. 完美平衡性

### 3.3.2.7 向单个 2- 结点中插入新键

当插入一个新键后，要马上进行选择：
1. 新键小于老键：新增一个红色左链接
2. 新建大于老键：新增一个红色右链接，然后左旋转修正

### 3.3.2.8 向树底部的 2- 结点插入新键

### 3.3.2.9 向一个 3- 结点中插入新键

1. 新键大于原树中的两个键：3- 结点化为 3 个 2- 结点，然后两个红链接变为黑色
2. 新建小于原树中的两个键：上层红链接右旋转，然后再将两个红链接变为黑色
3. 新建位于原树中的两个键之间：下层红链接左旋转，即得到了 2 中的情况

### 3.3.2.10 颜色转换

### 3.3.2.11 根结点总是黑色

### 3.3.2.12 向树底部的 3- 结点中插入新键

可能需要递归的向上处理，参照 2-3 树

### 3.3.2.13 将红链接在树中向上传递

1. 右红左黑：左旋转
2. 左红连续：右旋转
3. 左右皆红：颜色转换

## 3.3.3 实现

## 3.3.4 删除操作

插入已经够复杂了，删除操作更加复杂

### 3.3.4.1 自顶向下的 2-3-4 树

自上而下查找 4- 结点：
1. 根结点：分解成三个 2- 结点
2. 父结点为 2- 结点：分解为两个 2- 结点
3. 父结点为 3- 结点：分解为两个 2- 结点，并传递给父结点

和 2-3 树分解 4- 结点的操作相同

### 3.3.4.2 删除最小键

从 3- 结点中删除是很简单的，反而是 2- 结点比较困难，因为删除后 2- 结点会出现一个空结点

做法：沿着左链接向下进行变换，确保当前结点不是 2- 结点
1. 根节点是 2- 结点，且两个子结点都是 2- 结点：合并为 4- 结点
2. 左结点不是 2- 结点：完成
3. 左结点是 2- 结点，但是右结点不是 2- 结点：右结点中的一个键移动到左结点中
4. 左右都是 2- 结点：左结点和右结点合并为一个 4- 结点，使得父结点由 3- 结点 变为 2- 结点或者由 4- 结点变为 3- 结点

### 3.3.4.3 删除操作

## 3.3.5 红黑树的性质

研究红黑树的性质 = 对对应的 2-3 树的分析过程

### 3.3.5.1 性能分析

### 3.3.5.2 有序符号表 API

它复杂的代码仅限于 put() 和 删除函数，其他的和二叉查找树相同

# 3.4 散列表