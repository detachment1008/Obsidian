## 语法

### 声明

#### 无默认参数的声明

```cpp
template <typename T>
T foo(T a, T b)
```

#### 有默认参数的声明

```cpp
template <typename T = std::string>
T foo(T a, T b)
```

#### 返回值为模板参数的

##### 通过推断用调用参数的类型

推断调用参数的类型 T 的时候，也就得到了返回值的类型 T

```cpp
template <typename T>
T foo(T a)
```

##### 显式指出返回值类型

此时，必须在调用的时候显式的指出返回值的类型；由于模板函数如果不使用推断，必须全部显式指定，所以同时也必须指定调用参数的类型

```cpp
template <typename T, typename U>
U foo(T a)

foo<int, double>(3);
```

#### 返回值类型推断

##### 使用 `auto` 类型

`auto` 会自动退化推断出来的类型

```cpp
template <typename T>
auto foo(T a)
```

##### 尾置返回类型

```cpp
template <typename T>
auto foo(T a) -> decltype(a)
```

###### 退化推断的类型

```cpp
template <typename T>
auto foo(T a) -> typename std::decay<decltype(a)>::type
```

##### 使用公共类型

```cpp
template <typename T, typename U>
typename std::common_type<T, U> foo(T a, U b);
```

#### 函数模板的重载

##### 非模板函数和模板函数

在不进行隐式类型转换的前提下，优先调用非模板函数

```cpp
void foo(int a)

template <typename T>
void foo(T a)
```

### 调用

#### 推断调用

```cpp
foo(3, 4);
```

#### 显式调用

##### 指明模板参数的类型

可只显式的指出模板函数中的部分类型：

```cpp
foo<int>(3, 4);
```

##### 调用模板函数而不是非模板函数

```cpp
foo<>(3, 4);
```

## 实现方式

### 模板参数推断

#### 值传递

以退化(`decay`)的方式进行类型转换：
1. `const` 和 `volatile` 被忽略
2. 引用被转换为非引用类型
3. 数组类型被转换为相应的指针类型
4. 函数类型被转换为相应的指针类型

#### 引用传递

不允许任何形式的类型转换