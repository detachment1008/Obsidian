# 语法

## 声明

```cpp
template <typename T>
class foo
```

类的内部：
1. T 可以像普通类型一样使用
2. 在类内部，可以直接使用类名 `foo`

类的外部：
1. 如果要用到类类型，需要使用 `foo<T>`
2. 在使用 `foo<T>` 之前，需要加上 `template <typename T>`

## 调用

在 C++17 前，必须显式的指出所有模板参数类型；C++17 后，可以根据构造函数推断(必须调用包含所有模板参数的构造函数)

```cpp
foo<int> a;

foo a{2};
```

## 友元函数

### 函数模板

```cpp
template <typename T>
class foo
{
	template <typename U>
	frient void bar(foo<U> a);
}
```

### 提前声明

```cpp
template <typename T>
class foo;

template <typename T>
void bar(foo<T> a);

template <typename T>
class foo
{
	frind bar<T>(foo a);
};
```

## 特例化

### 全特化

内部所有使用到类名的地方，都要用 `foo<int>` 替换

```cpp
template <>
class foo<int>
{
};
```

### 部分特化

#### 限制类型

不完全特化某个具体类型，只是限制这个类型

同样，类内所有使用到类名的地方都必须使用 `foo<T *>` 代替

```cpp
template <typename T>
class foo<T *>
{
};
```

#### 特化类型关系

```cpp
template <typename T, typename U>
class foo

template <typename T>
class foo<T, T>
{
};
```

## 限制模板类型

### 利用 `static_asset` 和 `type_traits`

```cpp
template <typename T>
class foo
{
	static_assert(std::is_default_constructible<T>::value);
};
```

## 推断指引

只有在 C++17 后，使用模板类型的类型推导才需要使用

通过修改编译器的默认类型匹配规则，给某个类型添加一条新的类型匹配规则

```cpp
foo(const char *) -> foo<std::string>;
```

## 聚合类的推断指引

尽管它没有构造函数，但是可以当成它有一个按顺序传递所有数据成员的构造函数来进行推断指引

没有推断指引，就无法对聚合类进行默认的类型推断

```cpp
foo(const char*, int) -> foo<double>;
```

# 实现方式

## 模板类的实例化时机

只有在被调用的时候，才会实例化；同时实例化出类中的所有非模板成员

```cpp
foo<int> a;
```

## 模板类中的模板函数实例化时机

实例模板类时不会实例化内部的模板函数，只有在调用时才会实例化
- 模板函数也可能是用的模板类的模板参数

```cpp
foo<int> a;

a.bar();
```