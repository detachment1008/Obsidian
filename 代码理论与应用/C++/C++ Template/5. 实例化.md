# 部分实例化

## 模板类

如果只需要使用类的指针或引用，不需要类的完整定义，只需要一行声明即可：
```cpp
template <typename T>
class foo
{}

foo<int>* p = 0;
```

## 模板函数

如果调用模板函数，只是需要其返回值类型，就不需要完整定义，只需要声明：
```cpp
template <typename T>
T f(T p)
{
	return 2 * p;
}

decltype(f(2)) x = 2;
```

## 模板变量

如果只需要变量的类型，同样可以不定义它：
```cpp
template <typename T>
T v = T::default_value();

decltype(v<int>) s;
```

# 完整实例化

## 模板类

1. 实例化所有成员的声明(包括声明中的类型)，但不实例化定义(即部分实例化成员)
	- 例外1：类成员有匿名联合体
	- 例外2：虚函数(g++会实例化)
2. 如果模板参数有默认参数，如果使用了这个默认参数，会实例化它

# 实例化模型

## 两阶段查找

### 第一阶段

进行一般性的查找，如果某个地方出现了查找不到名称的地方，就先记录，带 POI 结束后，如果仍找不到才报错

查找非依赖型名称(非模板参数)
- 并不作为最终结果，而是等到第二阶段完成才获得最终结果

1. 当遇到一个 `<` 时，判断左边是否是一个已知的模板名称，如果是就启用尖括号解析，如果不是就用小于号来解析

### 第二阶段

查找依赖型名称(模板参数)

只是在对应位置实例化 + ADL

## 查找方式

### 一般查找

即在当前文件中，在前面查找非依赖的类型

### ADL

`Argument-Dependent Lookup`：参数相关的查找

触发条件：参数类型是一个自定义类型

作用：如果当前函数没有查找到，就在参数的命名空间中再次查找

## POI

`Point of Instantion`：实例化点，即实例化代码的位置

1. 如果在函数中产生了 `POI`，就在这个函数结束的后面定义
2. 定义后，可以通过 `ADL` 再次查找
3. 如果仍有未识别的名称，就会报错