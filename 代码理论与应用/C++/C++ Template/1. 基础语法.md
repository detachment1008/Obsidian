# 函数模板

## 类型推导

允许退化的方式进行类型隐式转换：
1. `const` , `volatile` , 引用：原始类型
2. `array` , 函数：对应的指针

## 在返回值中使用模板参数

如果它没有在调用参数中出现：引入第三个模板参数，并显式指明类型

## 返回值类型推断

1. 只使用 `auto` 关键字(`C++14`)
2. 使用 `auto` + 尾置返回类型(`C++11 的 decltype`)

## 萃取：使用原类型而非引用类型

通过萃取功能实现：
```
#include <type_traits>
template <typename T1, typename T2>
auto max(T1 a, T2 b) -> typename std::decay<decltype(true ? a : b)>::type
{
	return b < a ？ a : b;
}
```

但是 `auto` 作变量的时候，其类型总是退化了的结果

## 萃取：使用公共类型

```
#include <typename T1, typename T2>
std::common_type_t<T1, T2> max(T1 a, T2 b)
{
	return b < a ? a : b;
}
```

 这里，也会做类型的退化的(`decay`)

## 模板函数重载

即函数名相同的函数

非模板函数和模板函数重载
1. 优先选择非模板函数
2. 可以通过在调用时显式的添加 `<>` 来使用模板函数

模板函数和模板函数重载：
1. 必须保证只有一个模板函数可以匹配(不考虑退化的情况下)，否则报错

## 需要考虑的三个问题：

### 1.按值传递还是引用传递

建议：
1. 简单类型：值传递
2. 复杂类型：引用传递

### 2.为什么不适用 `inline`

不需要，因为一般 `inline` 的出现说明要多处定义了；而模板本来定义就很多(个人猜测)

### 3.为什么不用 `constexpr`

如果需要编译时执行：建议使用

## `auto` 作为函数返回类型

C++14 开始允许

# 类模板

## `volatile` 用法

修饰变量，告诉编译器不要对它进行优化，即每次都从内存获取，不要依赖于寄存器内保存的副本：
```
volatile int v;
```

作用：
1. 多线程
2. 中断处理程序

## `concept` 用法

C++20 引入，为了约束模板参数；之前的版本只能通过萃取和 `static_assert` 技术来进行判断：
```
template <typename T>
concept Integral = std::is_integral<T>::value;

template <Integral T>
void printNumber(T number) {
    std::cout << number << std::endl;
}
```

## 友元函数

如果类内部的友元函数也需要用到模板参数，不要使用类声明的参数，建议的做法：
1. 自己定义一个额外的模板参数
2. 先声明这个友元函数，再将其声明为友元(在类内部，显式的指定它为特例化的友元函数)

## 特例化

1. 需要特例化内部所有相关的函数
2. 将特例化的类型参数，从声明上去掉；声明的只是未实例化的参数

## 部分特例化

可以进行限制，如只针对指针的特例化：
```
template <typename T>
class Stack<T *>
{
}
```

多个参数的模板特例化：
1. 注意：参数的名字无所谓，重要的是个数；即该类还需要识别出多少种类型
2. 被特化的参数，前面的也必须特化(即使不做任何改变)

## 别名

1. C++11 后，允许使用 `using` 来起类型别名
2. 类型别名可以是实例话后的类型
3. 在类内部，也可以起类型别名；就是它的作用域被类和访问修饰符限制；使用的时候和静态变量一样，但是要通过 `typename` 显式的指定出来，否则就认为是静态变量了
4. C++14 后，可以通过给使用的某个 `::` 后面的东西加 `_t` 来标识它是类型，不是静态变量(它自己提前用了 `typename` )

## 类型推导

1. C++17 之前，类类型必须显式指出；但是之后如果可以从构造函数中推断出，就不用指明了

## 对字符串常量的推断

如果基于引用传递参数，就不会 `delay` ，所以字符串常量就是字符数组类型；但是如果是值传递，就会退化为字符指针类型

所以如果需要，构造函数中使用值传递

## 推断指引

改变模板参数的推断规则：
```
Stack(char const *) -> Stack<std::string>;
```
- 用于构造函数

## 聚合类的模板化

聚合类：没有定义任何构造函数、静态成员、虚函数、私有和保护成员

可以通过推断指引，也为它进行类型推断(会认为它有一个构造函数)：
```
ValuewithComment(char const *, char const *) -> ValueWithComment<std::string>
```

# 非类型模板参数

 甚至可以使用 `auto` 了

非类型模板参数有一些限制：允许的类型
1. 整型、枚举
2. 指针
3. 左值引用
4. `std::nummptr_t`

即禁止使用浮点类型和 `class` 类型

## `auto` 作为非模板类型参数的类型

C++17 开始允许

且允许了字符串常量数组作为非类型模板参数