# 第 0 章 什么是渲染
---

图形学一般分为三个方向：
- 渲染
	- 实时渲染(OpenGL)
	- 离线渲染
	- 平面 UI
- 几何处理
	- 三角网格
	- 隐平面
	- NURBS
- 物理仿真
	- 流体仿真
	- 软体仿真
	- 粒子仿真
	- 刚体仿真
	- 拓扑优化

## 什么是渲染

根据三维模型数据，生成二维的画面

## 一切皆三角形

所有复杂图形，都可以由三角形构成的

## 计算机图形学：画皮

我们都是只表示物体的表面，不管它内部是否是实心的

## 高模 vs 低模

它们指的是三角形的密集程度：
- 高模：三角形密集程度高，当然效果也好

一般建模师都会先在低模上操作，然后使用网格细分算法把低模自动转换为平滑的高模，然后再由雕刻师在高模上完成细节刻画

## 如何用一系列坐标表示一个方块

通过顶点坐标+顶点之间的连接关系

## 实时渲染 vs 离线渲染

- 实时渲染：1/60 秒内完成整个画面的绘制
	- 光栅化
		- 它只能计算光线的第一次反射
		- 为了实时性，不得不牺牲了渲染结果的准确性
		- 然后用了很多其他技术来模拟第一次以后的反射效果
	- GPU 加速
- 离线渲染：不注重实时性和速度，但非常重视画面的质量
	- 路径追踪
	- 蒙特卡罗积分
		- 需要降噪

## 着色：使物体明暗分明

## CPU vs GPU

CPU：适合处理通用任务，有很多逻辑控制的模块
GPU：适合处理互相不依赖，且大量的任务，有很多数学运算的模块

## GPU 渲染物体流程

# 初识OpenGL
---

## OpenGL ES

OpenGL 设计出来的接口规范对硬件要求较高：
- 所以它多用于电脑端
- 当然，只要 GPU 支持就可以

OpenGL ES 相当于 OpenGL 的阉割版本：
- 它多用于移动端，即低性能平台
- 它是为了服务手机芯片上，嵌入式的 GPU

## Windows 安装 OpenGL

- 安装 DirectX 的同时就会安装 OpenGL：
	- 它在 C:\Windows\System32 中会有一个动态库，opengl32.dll
	- 在运行 OpenGL 时，就会加载这个动态库
		- 它是调用的硬件驱动
		- 硬件驱动才是调用了硬件去工作
	- 当然，同时还需要物理显卡驱动才能运行

## Linux 安装 OpenGL

Ubuntu：`sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev`

# OpenGL 头文件
---

- 古代OpenGL都需要包括系统自带的头文件
	- `#include <GL/gl.h>`
- 现代OpenGL没有头文件，而是必须用 `LoadLibraryA` 去手动加载 opengl32.dll 里的函数，太痛苦了
	- 所以我们使用 glad 或 glew 这样的第三方库
		- `#include<glad/glad.h>`
		- 它必须在 glfw 头文件之前
	- 它们会在启动的时候加载所有的 OpenGL 函数，并放到全局函数指针当中
	- 这样在使用的时候，就好像在调用一个普通的函数一样了

# glfw 跨平台的 OpenGL 窗体管理库
---

- 它可以跨平台，且支持OpenGL上下文
- 同时支持了键盘，鼠标，手柄输入的功能

# glm 仿 glsl 语法的数学矢量库
---

glm和glsl的语法如出一辙

# OpenGL样板代码
---

- glfwInit()
- glfwMakeContextCurrent(window)
- gladLoadGL()
- while(!glfwWindowShouldClose(window)){ 画图  glfwSwapBuffers(window); glfwPollEvents();}

# 空间坐标系
---

## 屏幕空间坐标系(二维)

计算机图形学一般采用了笛卡尔坐标系：x, y 轴是两条相互垂直的直线
- OpenGL 的原点在中心，右为x正方向，上为y正方向
- DirectX 的原点在左上角，右为x正方向，下为y正方向

## 屏幕空间取值范围

不同图形API对屏幕空间的x,y取值范围也不同：
- OpenGl的x,y取值范围都是\[-1.0,1.0]

注意关注当屏幕不为正方形的情况

# 空间中的离散化

## 屏幕分辨率 - 空间离散化

如我们的显示器是1920\*1080：
- x 方向上有1920个像素点
- y 方向上有1080个像素点

OpenGL在绘制一个点的时候，会把提供的浮点坐标转换成像素的坐标：
- 通过 `round` 函数，即取整函数，求最接近的整数

## RGB 组合 - 颜色离散化

每个像素的颜色都由RGB三个颜色组成：
- 这三个灯的亮度都有 256 个挡位可以调节
- 刚好对应了 8 位无符号整数 unsigned char 的表示范围 \[0, 255]
- 因此，会有说颜色就是RGB，RGB就是三个uchar的说法

# 屏幕也有 z 方向？
---

OpenGL 规定朝向屏幕里面为 z 轴正方向：
- 即z坐标越小越靠前
- 它仅仅是为了服务于深度测试的

## 深度测试

为了模拟现实中的遮挡效果

## 深度图

即所有像素点深度组成的一副新的图像，称为深度图

# 屏幕空间的裁剪
---

- 如果 x 或 y 坐标超出了 \[-1,1] 区间的点，OpenGL 则会认为它已经不可能显示到屏幕上了
- 所以它会把这个点裁剪掉，即不进行任何显示上的计算了

## z 方向也会被裁剪

即太远或太近都不会显示：
	- 这是因为深度缓冲是有精度的，如果范围太大，定量化的深度缓冲就容纳不下了

# 世界坐标系
---

同样采用笛卡尔坐标系

# 绘制各种图形
---

立即绘制模式：
glBegin(GL_形状)
绘制顶点的颜色
绘制的顶点
CHECK_GL(glEnd())