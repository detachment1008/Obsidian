### C++思想

封装：
- 将逻辑上相关的变量包装成一个类
- 不变性：当一个成员需要修改，其他成员也需要修改时，可以将其封装为一个成员函数
	- getter setter 模式
	- 只有当修改一个成员，还有其他成员需要更改时才需要封装

RAII：Resource Acquisition ls Initialization
- 资源获取视为初始化
- 反之，资源释放视为销毁
- 可以自动资源获取与释放，避免犯错误
	- 不要用 new delete 了
- 它和面向垃圾回收的语言有所不同
	- C++的析构函数是显式的，离开作用域立即销毁
		- 对于高性能的话，利大于弊
	- 其他垃圾回收的语言，可能离开作用域后不会立即销毁，会过一段时间通过GC销毁

### 构造函数

自定义构造函数：
- 无参数：
	- 可以使用初始化表达式进行初始化
	- 它高效(只初始化了一遍，否则就是先初始，再赋值的操作)
	- const 只能通过初始化表达式进行初始化
- 多个参数：
	- 使用时，后面就需要加括号了
	- 相当于函数来使用，因为它调用了构造函数
	- 如果没有参数，可以省略括号
	- 可以在前面加 explicit 关键字，将其声明为显式的构造函数，使用时就必须使用括号了
		- 否则一个数的参数时，可以用等号直接赋值
	- 尽量使用 {} 代替 () 进行初始化：可以避免变窄转换
		- 谷歌也明确提出，不允许使用 () 调用构造函数了
	- 列表初始化的强大之处：它会按照顺序，赋值给对象的每一个成员
		- 相当于自动生成了一个构造函数
		- 不需要程序员手写冗长的构造函数了
		- 还可以在函数返回值中使用，这样它就会根据接收返回值的类型，然后用这个列表初始化进行构造了

默认无参构造函数：
- 它不会初始化 POD 类型
	- POD：plain-old-data
- 即这些类型占的位置原先在内存是什么内容，它就是什么内容
- 当然，也可以通过 {value}，进行初始化

拷贝构造函数：除非是智能指针，否则都是深拷贝
- 利用同类型的另一个对象来初始化这个对象
- =default 与 =delete
	- 可以指定编译器是否生成默认的构造函数

拷贝赋值函数：
- 它和拷贝构造函数类似，只是它在初始化后，再动态的用另一个对象进行赋值操作

移动构造函数：
移动赋值函数：

注意：
- 默认的拷贝构造和拷贝赋值都是浅拷贝
- 如果定义了析构函数(释放内存)，一定要手动定义这两个函数，从而实现深拷贝
	- 因为不定义就使用默认的，释放内存会出问题

移动：非拷贝，只是移动(原先的删去了)
- 如果有移动赋值函数，就可以删除拷贝赋值函数了