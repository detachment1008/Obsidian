# 为什么需要模板函数
---

- 避免重复写代码
- 如：利用重载实现"将一个数乘以2"的功能

它可以避免功能相同，但操作数类型不同的代码重复编写问题

## 模板函数定义

函数的上面加上：`template<class/typename T>`
- 这样就可以在函数中，把T当作是一种类型来使用了
- T可以被转换为任何类型
- 调用时，需要在函数名后面用 `<类型>` 去显式的指定类型
	- 不写也可以，它会根据后面的立即数类型自动推导出来

## 模板函数：特化的重载

重载和模板函数混编的形式：
- 当用到非模板类型时，它就会去调用非模板定义的函数
- 只有用到没有提前定义的类型，它才会去使用模板定义的函数
- 注意："字符串" 这种形式会被认为是C风格字符串，即char\*类型

## 模板函数：默认参数类型

可以通过：`template<class T=int>` 来定义默认的参数类型
- 即如果没有用 <> 显式的指定类型，它就会用默认的参数类型

## 模板函数：整数也可以作为参数

语法：
```
template<int N>
```

- 这样来声明一个整数 N 作为模板参数
- 使用时可以 `fun<3>()` 这样使用
- 目前只支持int类型(包括enum类型)
	- 错了。。好像都可以
	- 浮点数或其他编译期间无法确定的类型，就不可以

## 模板函数：多个模板参数

int N 和 class T 可以一起使用：
- 且它会自动根据类型来判断的，不用给出全部的值
- 默认值：int N = 1

## 模板参数：参数部分特化

在内部把T完全当成一种类型使用就可以了

## 为什么要支持整数作为模板参数：因为是编译期常量

两种写法：
```
template <int N> void func();

void func(int N);
```

- 对于 `template <int N>` ，N 是一个编译器常量，每个不同的 N 编译器都会单独生成一份代码，从而实现对他的单独优化
- `func(int N)`，N 是一个运行期常量，编译器无法自动优化
- 当然也有坏处，因为优化它会编译很多次，导致编译时间长，代码量大
- 而且非常特别 `template <int N>` 不能声明和定义分离，它们必须在同一个文件中完成
	- 当然我们指的都是 cpp 文件(hpp文件只是引入而已)
	- 即非类型模板参数，无法分离声明和定义
	- 因为编译是针对单个文件编译的，它需要将其转换为常量，如果是多个文件就无法获取这个值了

注意：
- <>内部一定是一个编译时期就确定的值

## 模板的应用：编译期的优化实例

当某些值，是非运行状态下确定的，就可以写成模板参数：
- 如是否是Debug模式
- 更进一步，可以用 constexpr(值) 来进一步保证其是编译器确定的值
- 当然这是c++风格的，c风格的宏也可以
- 记着传参时使用立即数，这才是编译状态下能确定的值
	- 或者用 constexpr 定义
	- 函数前也可以用 constexpr 来定义，如果能保证函数内的值都是可以在编译期间求值的话
	- constexpr 当然也就是内敛的，constexpr 函数也不能实现分离声明定义

## 模板的难题：无法移动到另一个文件中定义

- 因为模板函数都是编译器在用到这个函数的时候，模板函数才会去定义
- 建议：模板函数直接写在头文件里即可

## 模板的惰性：延迟编译

即只有用到模板函数的时候，才会去编译它

可以利用这一点，用一个假模板来实现延迟编译的技术，从而加快编译的速度，用于代理模式等

## 模板函数：可以配合运算符重载使用

# 为什么需要自动类型推导
---

## auto自动推导：一些局限性

在使用时，必须初始化：
- 不然它就不知道你是什么类型的
- 类类型无法定义为 auto

## 自动类型推导：函数返回值

auto作为函数返回值的注意事项：
- 当函数有多条返回语句时，所有语句的返回类型必须一致
- 当函数没有return语句时，auto自动推导为void
- 同样不能进行声明和实现分离：
	- 即 auto func(); 这样就是错误的

# C++ 特性：引用
---

引用的本质无非是指针：
- 当我们修改一个引用时，实际上是修改了原来的对象

也可以用 auto 来表示引用

引用是没有空指向的，即它必须初始化

# C++ 特性：常引用
---

const存在的意义：
- 使得更安全，即不能修改它的值了
- 编译器可以放心大胆的做优化了

# 理解右值
---

右值：即将消失，不时间存在于内存中的值
- 左值：长时间存在内存中的值

个人理解：放在寄存器中的值，它没有放入内存，即没有地址

右值可以自动退化为 auto const 类型：
- 即在左值的地方也可以使用右值
- 注意一定要有const，不然就无法编译通过

# 获取变量的类型：decltype
---

- decltype(变量名)
- decltype(表达式)
	- 注意，此时得到值是一个右值
	- 可以通过decltype((变量名))来强制编译器使用后者

# 自动类型推导：万能推导
---

即 `decltype(auto)`：

# using：创建类型别名
---

# 函数也是对象：函数式编程
---

函数也可以作为另一个函数的参数
- 这个作为参数的函数也可以有参数

# lambda 表达式
---

如果它作为返回值，必须使用 auto 类型接收：
- 因为 lambda 表达式必须是匿名的
- 注意：如果使用了引用捕获，lambda 对象的生命周期不能超过它捕获的所有引用的生命周期

# 类型擦除技术
---

std::function
- 利用了虚函数

std:any

# lambda + 模板
---

即 lambda 的参数声明为 auto 类型即可

# 常用容器：tuple
---

## 结构化绑定

# 常用容器：optional
---

- value_or()
- value()
- operator*()
- operator bool() 和 has_value() 等价

# 常用容器：variant
---

安全的 unicon，存储多个不同类型的值