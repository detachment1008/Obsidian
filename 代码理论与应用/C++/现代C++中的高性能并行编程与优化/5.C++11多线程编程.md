# C语言如何处理时间
---

long t0 = time(NULL)：
- 获取从1970年1月1日到现在的秒数

sleep(3)：程序睡眠3s
usleep(3000000)：程序睡眠0.3s

# C++11引入时间的标准库：std::chrono
---

# 第 1 章 线程
---

- 进程：就是一个应用程序被拉起到内存，到结束的一个过程
	- 就是一个 exe 文件
- 线程：共享进程的同一个内存空间

## 为什么需要多线程

目的：无阻塞多任务
- 我们的程序常常需要同时处理多个任务

## C++中的多线程：std::thread

它的构造函数可以是任意的lambda表达式

当线程启动后，就会执行这个lambda表达式中的内容

使用前提：
- 它的实现是基于pthread的
- 在CMakeLists中进行链接
```
find_package(Threads REQUIRED)
target_link_libraries(cpptest PUBLIC Threads::Threads)
```

可以使用 join 等待线程完成

可以使用 detach 分离该线程：
- 意味着线程的生命周期不再由当前的 std::thread 对象管理
- 而是在线程退出后，自动销毁自己

可以创建一个全局变量(线程表)用于存储所有线程：
- 然后在它的析构函数中，为每个线程加上 join
- 因为当main函数执行完毕后，会销毁全局变量
- 这样就可以在 main 函数执行完毕后，通过析构函数卡住进程，从而让线程执行完

即 std::jthread 类
- C++20特性

# 第 2 章 异步
---

## 异步的好帮手：std::async

底层实现：std::promise

等待一段时间：wait_for()

另一种用法：std::launch::deferred 做参数

# 第 3 章 互斥量
---

经典多线程打架案例：两个线程向同一个数组推送数据
- 这样就崩溃了
- 数据竞争现象

std::mutex：上锁，防止多个线程同时进入某一段代码
- 调用lock，会检测是否已上锁
- 如果上锁，就会等待，直到解锁它才上锁，然后继续执行
- 记着最后调用 unlock 进行解锁操作
- 这样就可以保证 lock 和 unlock 之间的代码同时之间只有一个线程在执行，从而避免数据竞争

同样可以使用RAII思想：将锁视为一种资源
- 上锁意味锁的获取
- 解锁意味锁的释放

即 std::lock_guard 类
- 可以用一个空的花括号括住

std::unique_lock：也符合 RAII 思想，但是自由度更高
- 用 std::defer_lock 作为参数
- 指定了这个参数就不会自动上锁了
- 还有好多参数...

上锁失败，不要等待：try_lock()
只等待一段时间：try_lock_for()

# 第 4 章 死锁
---

同时锁住多个 mutex，双方都在等待对方释放锁

## 解决办法

- 永远不要同时持有两个锁
- 保证双方上锁顺序一致
- 用 std::lock 给多个锁上锁
	- RAII 版本：std::scoped_lock

注意：同一个线程重复调用 lock() 也会造成死锁

## 解决办法

- 不要在锁中调用锁函数
- std::recursive_mutex

# 第 5 章 数据结构
---

可以封装一个线程安全的 vector

为什么需要读写锁：
- 读可以共享，写必须独占，且写和读不能共存
- shared_mutex
- shared_lock：符合RAII思想

访问者模式

# 第 6 章 条件变量
---

条件变量：
- 等待被唤醒
- 等待某一条件成真
- 多个等待者

案例：生产者-消费者模式
