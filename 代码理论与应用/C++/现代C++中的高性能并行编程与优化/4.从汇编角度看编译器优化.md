# 编译器
---

即将源代码生成汇编语言的过程：
- 所以为了了解编译器的优化，我们就从汇编的角度来看编译器的优化

# 第 0 章 什么是汇编语言
---

GNU架构

通用寄存器 32 位时代：
- 8 个寄存器

通用寄存器 64 位时代：

汇编语言分位两种：
- 英特尔汇编：从右向左，直接写寄存器名，直接写立即数，直接写地址
- ATT汇编：从左向右，寄存器前加%，立即数前加$，在表示地址的立即数或寄存器前加\*

返回值：通过 eax 传出
前六个参数：分别通过 edi,esi,edx,ecx,r8d,r9d 传入

开启优化：-O3

32 位乘法运算：imul
64 位乘法运算：imulq
整数加法：被优化为了 leal

浮点数的参数和返回：xmm 系列寄存器
- xmm 寄存器有 128 位宽
- 可以容纳 4 个float，或 2 个 double
- addss：可以拆成三个部分，add, s, s
	- add 表示执行加法操作
	- 第一个 s 表示标量，只对 xmm 的最低位进行运算(如果是 p 就表示矢量，对所有位运算)
	- 第二个 s 表示单精度浮点数，即 float 类型(也可以是 d ，即双精度浮点数)

# 为什么需要 SIMD

SIMD：single-instruction multiple-data，即单个指令处理多个数据的技术

比如：将 4 个 float 打包到一个 xmm 寄存器里同时运算，很像数学中矢量的逐元素加法
- 因此 SIMD 又被称为矢量，而原始一次只能处理一个 float 的称为标量
- 它可以让 float 计算指令加速 4 倍

# 第 1 章 化简
---

编译器优化：
- 代数化简
- 常量折叠

但是编译器不是万能的：
- 应该避免代码复杂化，避免使用会造成new/delete的容器

存储在栈上的：
- 固定大小
- 利于优化

存储在堆上的：
- 动态大小
- 妨碍优化

# 第 2 章 内联函数
---

外部函数：
- 该文件内只有一个声明，实现在另一个文件
- 调用外部函数：call 指令
	- 它会根据函数链接表中进行搜索，通过一个符号
	- 如果链接到了，就将地址替换到这个符号
	- 如果链接器没有链接这个函数，那么它就会报错
- 外部函数编译器无法优化

编译器优化：call 变 jump

内部函数：函数的声明和定义在同一个文件内
- 如果这个符号定义在同一个文件中，编译器就会直接调用

编译器优化：内联化

局部可见函数：static
- 因为 static 声明不会暴露这个函数给其他文件

# 第 3 章 指针
---

指针别名现象：会导致编译器不敢优化
- 告诉编译器别怕指针别名：\_\_restrict 关键字
- 只需在非 const 加即可

禁止优化：volatile

编译器优化：合并写入

数组清零：自动调用标准库 memset

# 第 5 章 循环
---

冷热优化

循环中的矢量化