# 引言

类的基本思想是数据抽象和封装：
- 数据抽象：依赖于接口和实现相分离的技术
	- 接口：用户执行的操作
	- 实现：数据成员，实现接口的函数体，其他私有函数
- 封装：用户只能访问接口，无法访问实现部分

抽象数据类型指的是不允许用户自定义操作，只能用给定的操作
非抽象数据类型指的是用户可以直接访问数据成员，然后可以自定义操作

抽象数据类型一般用 class 声明
非抽象数据类型一般用 struct 声明

对于每个类来说，它们的函数都是共享的，每个类只存储它们自己的数据

当调用函数时，它们通过隐式的把自己的指针当作第一个参数传递进去，如果要操作数据就通过传入的对象来进行操作，这个参数就是 this 指针

const成员函数：它的作用是针对this指针的，它是一个底层指针，即禁止修改this指向的数据成员
- 写在成员函数的参数列表后面即可
- 它属于函数签名中的一种

编译器分两步处理类：
1. 编译成员的声明
2. 如果有的话，处理成员的函数体

因此成员函数体可以随意使用类中的其他成员，而无需在意成员的出现顺序

我们可以在外部定义成员函数，但是要求函数签名+返回类型必须和声明保持一致：
- 我们把类名看作是一种命名空间
- 因此定义成员函数时，记着前面需要指明它所属的命名空间

当我们定义一些辅助函数时：建议定义在同文件中，即在类中直接定义。这样用户在使用接口时，只需要再引入一个文件即可，即接口的定义文件
- 即从操作上讲它属于接口的一部分，但是实际上它并不属于类本身
- 被声明为private的函数

# 普通构造函数

不能被声明为const：因为它存在的目的就是为了改变数据

默认构造函数：
- 如果此类型是没有初始化的内置类型或非内置类型，不进行初始化
	- 注意：此时它们的值是未定义的

当存在构造函数时，就没有默认构造函数了，无论这个构造函数有没有参数

我们可以用显示的=default来定义使用默认的构造函数：
- 这样就可以不用写定义了

类内的初始值应该是初始化时就在上面的，它比构造函数执行的还要早：
- 即如果构造函数不修改，变量的初始值就是类内初始值

初始值列表：
- 一般用于构造函数值的初始化
- 它比括号内的函数定义执行的更早
- 建议使用
- 它是在函数执行时生效的，即它无法写在声明处，但是需要写在定义处

# 访问控制与封装

访问说明符加强封装性：
- public：可以通过对象访问，一般用于定义类的接口
- private：只能被类命名空间内的成员函数访问，即隐藏了实现细节，一般用于定义类的数据成员与辅助函数

struct的默认访问权限是public，class是private，这是它们的唯一区别

有一个办法让其他类或函数访问这个类的private成员：友元
- 即在类中用friend修饰的声明，即为友元
- 它可以是类，也可以是函数
- 它的位置没有限制

它并不是代替了函数声明，它只是标记了它作为这个类的友元。外部还是需要声明的。

注意：友元是类型声明，即对于这个类型或函数我开放
- 友元不具有传递性

类内部定义定义的函数是默认内联的

可变的数据类型：mutable
- 它用于不会是const，即使身处const对象或函数

注意：const函数仅仅是不能改变类内成员的值，它可以改变非类成员的其他值

注意：类内直接初始值只能使用=或{}，不能使用其他符号

令成员函数作为友元函数：需要加上命名空间指定该函数

友元的声明并非真的声明，即没有这个函数时或这个类型时，也可以进行友元声明

# 类的作用域

我们通常意义上认为作用域是一层一层查找的：
- 即在当前作用域中查找名字
- 找不到就再去上一层，一层一层查找

我们可以把类也看作是一种作用域

# 构造函数再探

如果类成员有const变量，引用类型等，那么它就必须被初始化，因为这是它唯一初始化的机会：此时，只能用构造函数初始值列表了

无论初始值列表的顺序是如何的，类内部初始化值的顺序始终是从上到下的：
- 即在上面的成员永远是先初始化的

委托构造函数：即通过初始值列表，调用其他构造函数
- 它只能调用构造函数
- 它只能通过初始值列表的形式，不支持在函数体内调用
- 它先执行委托的函数的初始值列表，然后执行它的函数体，最后再执行自己的函数体

隐式的类型转换：构造函数只接收一个参数的情况下
- 它被成为转换构造函数

即如果有其他变量被当成这个类使用时，可以通过这个构造函数进行转换
- 注意，最多只能进行一步转换操作
- 即这个类型必须完美的符合构造函数的这个参数

我们可以通过 explicit ，禁止构造函数进行转换

构造函数的调用方式：
- 无参：不需要括号
- 有参：
	- 括号+参数
	- 大括号+参数
	- 等于号

explicit将其限制在只能通过括号+参数和大括号+参数这两种方式，而且不会发生隐式转换

聚合类：
- 所有成员都是public
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类和虚函数

此时，可以用初始化列表进行初始化：
- 可以有类内初始值
- 但是不能有私有成员

# 字面值常量类

字面值常量类：
- 数据成员都是字面值类型
- 至少含有一个 constexpr 构造函数
- 如果一个数据成员含有类内初始值，则内置的类型成员初始值必须是一条常量表达式
	- 如果是类类型，就必须使用自己的 constexpr 构造函数
- 必须使用析构函数的默认定义

