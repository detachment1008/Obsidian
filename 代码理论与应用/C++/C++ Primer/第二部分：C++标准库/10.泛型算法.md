# 10.1 概述
---

容器的操作实际很少，是因为标准库提供了一组算法，独立且通用于任何容器

大多数算法都定义在 algorithm 文件中，标准库还在头文件 numeric 定义了一组数值泛型算法

一般情况下，这些算法不直接操作容器，而是遍历由两个迭代器指定的元素范围
- 算法遍历范围，对其中一些元素进行处理
	- 当然，它不是一个一个挨着这样低效的遍历的
- 它不依赖于容器所保存的元素类型

算法如何工作：
- 迭代器令算法不依赖于容器
- 但算法依赖于元素类型的操作
	- 如：find 函数，依赖于 == 运算符
	- 当然，大多数算法允许我们使用自定义的操作符

算法永远不会执行容器的操作：
- 它可能会改变值，也可能会移动元素
- 但是它一定不会增加或删除元素，即也不会改变底层容器的大小

# 10.2 初始泛型算法
---

标准库提供了 100 多个算法，幸运的是它和容器一样，有一致的结构
- 比起死记硬背，我们应该理解此结构

除了少数例外，标准库算法都对一个范围内的元素进行操作，它被称为"输入范围"
- 接受输入范围的算法总是用前两个参数来表示此范围
- 这两个参数分别是指向第一个元素，和最后一个元素之后位置的迭代器

理解算法的基本方法：
- 是否读取元素(输入到算法)
- 是否改变元素(从算法输出)
- 是否重排元素顺序

## 10.2.1 只读算法

不改变元素的算法：
- find
- count
- accumulate
	- 定义在 numeric 文件
- equal
	- 它操作了两个序列

## 10.2.2 写容器元素的算法

一些算法将新值赋予序列中的元素：
- fill
- fill_n

算法不会检查写操作

插入迭代器：保证算法有足够空间来容纳输出数据
- 它是一种向容器中添加元素的迭代器
- back_inserter 函数，返回一个与该容器绑定的插入迭代器
	- 通过此迭代器赋值，就会调用 push_back 来进行赋值

拷贝算法：
- copy

## 10.2.3 重排容器元素的算法

某些算法会重排容器中元素的顺序：
- sort
- unique
	- 它将不重复的元素放在开始
	- 返回重复元素的第一个位置的迭代器

# 10.3 定制操作
---

我们可以自定义操作符来代替默认运算符

## 10.3.1 向算法传递函数

我们称这个函数为谓词：谓词是一个可调用的表达式，其返回结果是一个能用作条件的值
- 一元谓词：即只接受单一参数
- 二元谓词：即有两个参数

当然，元素类型必须能转换为谓词的参数类型

排序算法：
- stable_sort
	- 稳定的排序算法
	- 它还会按照字符串的长度来进行排序

## 10.3.2 lambda 表达式

介绍 lambda

我们可以向一个算法传递任何类别的可调用对象
- 即可以对其使用调用运算符

目前我们知道的有两种：
- 函数
- 函数指针

还有其他两种可调用对象：
- 重载了函数调用运算符的类
- **lambda 表达式**

一个 lambda 表达式表示一个可调用的代码单元
- 我们可以将其理解为一个未命名的内联函数
- 它与函数不同点在于，它可以定义在函数内部

lambda 表达式的形式：
```
[capture list] (parameter list) -> return type { function body}
```
- *capture list*：捕获列表，指一个lambda 所在函数中定义的局部变量的列表(通常为空)
	- 如果为空，表示不适用任何它所在函数中的任何局部变量
	- 好像就是闭包
- *parameter list, return type, function body*：与任何普通函数一样，分别表示返回类型、参数列表和函数体
- 与普通函数不同的是，lambda 必须使用尾置返回来指定返回类型
- 参数列表和返回类型可以忽略，但是必须永远包含捕获列表和函数体
	- 中间的箭头都可以省略
- `auto f = [] {return 42;};`
	- 此时，f 就是一个可调用对象
	- f() 返回的值为 42

for_each 算法：对输入序列中每个元素调用传递的可调用对象

## 10.3.3 lambda 捕获和返回

当定义一个 lambda 时，编译器就会生成一个与 lambda 对应的新的类类型
- 相当于定义了一个新类型和该类型的一个对象

值捕获：只是拷贝
引用捕获：能改变它的值

隐式捕获：
- &：引用捕获方式
- =：值捕获方式

混合捕获方式：
- 捕获列表的第一个元素必须是一个 & 或 =，指定了默认捕获方式
- 显示捕获的变量必须使用与隐式捕获不同的方式

可变 lambda：
- 即我们希望改变值类型的被捕获的变量的值
	- 即它还是拷贝进了 lambda 表达式
	- 只是当我们执行完 lambda 表达式后，会通过 return 返回出去，从而改变这个变量的值
	- 参数列表之后，返回类型之前(-> 之前)，加上 mutable 关键字
		- 当然，参数列表和返回类型(包括->)都可以省略

指定 lambda 的返回类型：
- 编译器可以根据 return 后的值来判断返回类型
	- 可以是操作符，包括三目运算符
	- 不能是条件判断语句，这种情况下必须显式的指定返回类型，即尾置返回类型

## 10.3.4 参数绑定

如果多处用到相同的 lambda 表达式，我们应该用函数来代替它
- 但是如果它有捕获列表呢

标准库 bind 函数
- 定义在头文件 functional 中
- 可以把它看作是一个通用的函数适配器
- 它接受一个可调用对象，生成一个新的可调用对象来"适应"原对象的参数列表

调用 bind 的一般形式：
```
auto newCallable = bind(callable, arg_list);
```

使用 placeholders 名字：
- *-n*：定义在一个名为 placeholders 的命名空间中，而这个命名空间本身又定义在 std 命名空间中

bind 的参数：
```
auto g = bind(f, a, b, _2, c, _1);
```
- 它有两个参数，分别用占位符 -2 和 -1 表示
	- g(\_1, \_2) 被映射为 f(a, b, \_2, c, \_1)
- 新的可调用对象将它自己的参数作为第三个和第五个参数传递给 f
- f 的第一个，第二个，第四个参数分别被绑定到给定的值 a，b 和 c 上

绑定引用参数：
- 与 lambda 相同，有些类型是无法拷贝的，就只能用引用的方式传递了
- 函数 ref 返回一个对象，包含给定的引用
- cref 函数，生成一个保存 const 引用的类
- 这两个函数定义在头文件 functional 中

# 10.4 再探迭代器

除了每个容器特定的迭代器，标准库在头文件 iterator 中还定义了额外几种迭代器：
- 插入迭代器：用于插入
- 流迭代器：用于遍历关联的 IO 流
- 反向迭代器：它反向移动(forward_list 没有这种迭代器)
- 移动迭代器：它不是拷贝其中元素，而是移动它们

## 10.4.1 插入迭代器

三种类型：
- back_inserter
- front_inserter
- inserter

## 10.4.2 iostream 迭代器

两种迭代器：
- istream_iterator
	- 允许使用惰性求值
	- 具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取
- ostream_iterator

## 10.4.3 反向迭代器

它的递增会向前移动，它的递减反而会向后移动

# 10.5 泛型算法结构
---

五种迭代器：
- 输入迭代器
- 输出迭代器
- 前向迭代器
- 双向迭代器
- 随机访问迭代器

算法分类的第一种方式：
- 按照使用的迭代器类型来分类

算法分类的第二种方式：
- 按照是否读、写或是重新排序来分类

## 10.5.1 5 类迭代器

## 10.5.2 算法形参模式

参数的四种形式：
- alg(beg, end, other args)
- alg(beg, end, dest, other args)
- alg(beg, end, beg2 other args)
- alg(beg, end, beg2, end2, other args)

## 10.5.2 算法命名规范

一些算法使用重载形式传递一个谓词

\_if 版本的算法

区分拷贝元素的版本和不拷贝的版本

# 10.6 特定容器算法

即链表类型：list 和 forward_list 
- sort
- merge
- remove
- reverse
- unique

链表独有的操作会改变容器
