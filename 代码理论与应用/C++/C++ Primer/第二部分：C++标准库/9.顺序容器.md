# 介绍
---

容器：一种特定类型对象的集合

顺序容器：元素在容器中的位置与加入容器的顺序相对应
- 为程序员提供了控制元素存储和访问顺序的能力

# 9.1 顺序容器概述
---

所有顺序容器都提供了快速访问元素的能力，但它们以下方面的性能不同：
- 向容器添加或删除元素的代价(数组)
- 非顺序访问容器中元素的代价(链表)

其实顺序容器，包含的就是 1 对 1 的数据结构，即数组和链表

顺序容器的类型：
1. 数组
	 - vector：数组
	 - array：固定大小数组
	 - string：针对字符的数组
	 - deque：双端队列
2. 链表
	- list：双向链表
	- forward_list：单向链表

选择容器的基本原则：
- 除非有更好的理由，否则使用 vector
- 如果额外开销很重要，不要使用 list 和 forward_list
- 如果需要随机访问元素，使用 vector 和 deque
- 如果要求在中间插入数据，使用 list 和 forward_list
- 如果需要头尾插入，但不会在中间插入，使用 deque
- 如果只有在读取输入时才在中间插入，之后需要随机访问：
	- 在 vector 中追加数据，然后 sort 函数排序
	- 输入时使用 list，然后将 list 中的内容拷贝到 vector 中

# 9.2 容器库概览
---

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同
- 即容器均定义为模板类
- 即对于大多数容器，我们都需要额外提供元素类型信息

顺序容器可以保存任意类型的元素，甚至是另一个容器

1. 类型别名：即容器中除了定义的容器类型，还定义了其他类型
	- iterator：迭代器
	- const_iterator：只读的迭代器
	- size_type：无符号整数类型，足以保存此容器类型最大容量
	- difference_type：有符号整数类型，足够保存两个迭代器之间的距离
	- value_type：元素类型
	- reference：元素的左值类型，与 value_type& 含义相同
	- const_reference：元素的 const 左值类型，与 const value_type& 含义相同
2. 构造函数
	- C c：构造空容器
	- C c1(c2)：构造 c1，其为 c2 的拷贝
	- C c(b, e)：构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c(array不支持)
	- C c{a, b, c...}：构造 c，并列表初始化
3. 赋值与 swap
	- c1 = c2：将 c1 中的所有元素都替换为 c2 中的元素
	- c1 = {a, b, c...}：将 c1 中的元素都替换为列表中的元素(array不支持)
	- a.swap(b)：交换 a 与 b 的元素
	- swap(a, b)：与 a.swap(b) 等价
4. 大小函数
	- c.size()：c 中元素的数目
	- c.max_size()：c 可保存的最大元素数目
	- c.empty()：若 c 存储了元素，返回 false，否则返回 true
5. 添加/删除元素(不同容器接口不同)
	- c.insert(args)：将 args 中的元素拷贝进 c
	- c.emplace(inits)：使用 inits 构造 c 中的一个元素
	- c.erase(args)：删除 args 指定的元素
	- c.clear()：删除 c 中的所有元素，并返回 void
6. 获取迭代器
	- c.begin()：首元素位置
	- c.end()：尾元素之后的位置
	- c.cbegin()：const 版本
	- c.cend()：const 版本
7. 反向容器的额外成员(不支持 forward_list)
	- reverse_iterator：按逆序寻址元素的迭代器
	- const_reverse_iterator：不能修改元素的逆序迭代器
	- c.rbegin()：尾元素位置
	- c.rend()：首元素之前的位置
	- c.crbegin()：const 版本
	- c.crent()：const 版本

## 9.2.1 迭代器

迭代器通过解引用运算符访问元素，并定义了递增运算符

迭代器的范围：
- 由一对迭代器表示
- 分别指向了同一个容器中的首元素和尾元素之后的位置
- 这个范围被称为左闭合区间：\[begin, end]

左闭合区间的性质：
- 如果 begin 和 end 相等，则范围为空
- 如果 begin 和 end 不等，则范围至少包含一个元素，且 begin 指向该范围中的元素
- 我们可以对 begin 递增若干次，使得 begin == end

## 9.2.2 容器类型成员

类型别名：通过类型别名，我们可以在不了解容器中元素类型的情况下使用它
- value_type：元素的类型
- reference：元素的引用类型

## 9.2.3 begin 和 end 成员

最常用的用途是形成一个包含容器中所有元素的迭代器范围

## 9.2.4 容器定义和初始化

将一个容器初始化为另一个容器的拷贝：
- 直接拷贝整个容器
	- 两个容器的类型和元素类型必须匹配
- 拷贝由一对迭代器指定的元素范围(这些范围都是左闭右开的)
	- 容器类型不必相同
	- 元素类型不必相同，只要能将拷贝的元素转换即可

列表初始化：
- 可以显式的指定容器中每个元素的值
- 对于除 array 之外的容器类型，初始化列表还隐含指定了容器的大小

与顺序容器大小相关的构造函数：只有顺序容器才有
- 一个参数：表示初始化的元素个数，每个元素都是 0 或 空
- 两个参数：第一个参数表示元素个数，第二个参数表示元素的值

标准库 array 具有固定大小：
- 它在初始化的时候，不仅要指定元素类型，还要指定容器大小
- 在使用 array 的其他类型时，也要显式的指定元素类型和大小
- 它可以进行拷贝或对象赋值的操作
	- 内置数组类型不可以

## 9.2.5 赋值和 swap

除了直接赋值和 swap 函数，顺序容器也提供了其特有的赋值操作：
- seq.assign(b, e)：将 seq 中的元素替换为迭代器 b 和 e 所表示范围中的元素；b 和 e 不能指向 seq 自己中的元素
- seq.assign(il)：将 seq 中的元素替换为初始化列表 il 中的元素
- seq.assign(n, t)：将 seq 中的元素替换为 n 个值为 t 的元素

使用 swap 会交换两个相同类型容器的内容：
- 它们只是交换了两个容器的内部数据结构，元素本身并没有被交换
- 除了 string 外，指向容器的迭代器、引用和指针在 swap 操作之后都不会失效，但是这些元素已经属于不同的容器了
	- 元素变了
	- 元素值不变
- 但是对于 array，swap 真的会交换它们的元素，因此它们所需的时间可能会很长，即与 array 中元素的数目成正比
	- 指针、引用、迭代器绑定的元素保持不变，但是元素值被改变了
	- 元素不变
	- 元素值变了

## 9.2.6 容器大小操作

除了一个例外，每个容器类型都提供了三个与大小相关的操作：例外是 forward_list

## 9.2.7 关系运算符

关系运算符的左右运算对象必须是相同类型的容器，且必须保存相同类型的元素：
- 如果两个容器大小相同，且元素两两对应，则这两个容器相等
- 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
- 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果
- 容器的关系运算符是使用元素的关系运算符来完成比较的

# 9.3 顺序容器的操作
---

## 9.3.1 向顺序容器添加元素

1. push_back
	- 将一个元素追加到尾部
	- 除了 array 和 forward_list 都支持
	- 它放入的是一个对象的拷贝，而不是对象本身；即对它操作不会改变原对象本身
2. push_front
	- 将元素插入到容器头部
	- 只有 forward_list 和 deque 支持
3. insert
	- 它将指定元素插入到迭代器之前的位置
	- 如果使用三个参数的重载，可以一次性插入多个元素
		- 同理，第一个是int的话，就表示数量，即该数量相同元素
		- 如果两个都是迭代器，就是迭代器之间的元素
	- 它的返回值是插入的新元素位置的迭代器
		- 通过该返回值可以在同一个位置反复插入
4. emplace
	- 引入了三个成员：emplace_front，emplace 和 emplace_back
		- 分别对应：push_front，insert 和 push_back
	- 它们的操作不是拷贝元素，而是构造
	- 在使用 emplace 的时候，会调用元素类型的构造函数，在容器的内存空间直接构造
	- 所以它传递的参数，实际上就是这个元素类型构造函数的参数

## 9.3.2 访问元素

访问元素的操作：前提需保证容器 c 非空，否则行为未定义
- c.back()：尾元素引用
- c.front()：首元素引用
- c\[n]：下标为 n 的元素引用
- c.at(n)：下标为 n 的元素引用，可以检测越界

## 9.3.3 删除元素

删除元素操作：
- c.pop_back()：删除尾元素
- c.pop_front()：删除首元素
- c.erase()：
	- 一个参数：即迭代器指定的元素
	- 两个参数：即迭代器之间的元素
- c.clear()：删除所有元素

## 9.3.4 特殊的 forward_list 操作

因为它是单向链表，所以我们只能访问到迭代器后面的元素的位置，而无法访问前面

## 9.3.5 改变容器大小

即通过 resize 函数来改变容器大小：
- 缩小时，容器后面的元素会被删除
- 放大时，会将新元素添加到容器后面

## 9.3.6 容器操作可能使迭代器失效

失效的情况：
- 向容器添加元素：
	- vector 或 string 进行了存储空间重新分配
	- deque 的插入
		- 如果只是首尾插入，那么只是迭代器失效，元素的引用和指针不会失效
	- 插入操作，后面的元素的迭代器失效
- 向容器删除元素：
	- deque 同插入
	- vector 和 string 删除元素以及后面的元素失效

# 9.4 vector 对象是如何增长的
---

操作：
1. c.shrink_to_fit()：将 capacity() 减小为与 size() 相同大小
2. c.capacity()：不重新分配的话，c 可以保存多少元素
3. c.reserve(n)：分配至少能容纳 n 个元素的内存空间

# 9.5 额外的 string 操作
---

## 9.5.1 构造 string 的其他方法

即可以用其他字符串中的部分进行构造，或用一个字符重复来进行构造

substr 操作：返回 string 的一部分或全部拷贝
- 参数：一个开始位置和计数值
- 开始位置默认为 0

## 9.5.2 改变 string 的其他方法

- assign
- insert
- erase

append 和 replace 函数

改变 string 的函数都有多种重载

## 9.5.3 string 搜索操作

string 类提供了 6 个不同的搜索函数，每个都有 4 个重载版本，都返回下标值：
- find
- rfind
- find_first_of
- find_last_of
- find_first_not_of
- find_last_not_of

可以指定从哪里开始搜索，或逆向搜索

## 9.5.4 compare 函数

它用于字符串比较

## 9.5.5 数值转换

字符串中常常包含需要表示的数值

数值转 string：
- to_string(i)

string 转数值：最后一个表示的类型，当然这种函数有很多
- stod(s)
- 它是通过调用 find_first_of 来获取第一个可能是数值的一部分的字符的位置

# 9.6 容器适配器
---

标准库定义了三个顺序容器的适配器：stack, queue 和 priority_queue
- 适配器：似乎是装饰模式

栈适配器

队列适配器


