# 引言
---

我们目前使用的对象都有严格定义的生存期：
- 全局对象：程序启动时分配，结束时销毁
- 局部自动对象：进入程序块时创建，离开块时销毁
- 局部 static 对象：第一次使用前分配，程序结束时销毁

但是动态分配的对象生存期与它们在哪里创建是无关的
- 只有显示地被释放时，这些对象才会销毁
- 动态对象的正确释放是程序中极容易出错的地方，标准库定义了两个智能指针来帮助管理
	- 即当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它

我们目前使用的内存：
- 静态内存
- 栈内存

每个程序还拥有一个内存池，它被称为自由空间或堆
- 程序用堆来存储动态分配的对象

# 12.1 动态内存与智能指针
---

动态内存的管理通过一对运算符来完成：
- new
- delete

两种智能指针：
- shared_ptr：允许多个指针指向同一个对象
- unique_ptr："独占"所指向的对象

伴随类：weak_ptr
- 它是一个弱引用，指向 shared_ptr 所管理的对象

它们都定义在 memory 头文件中

## 12.1.1 shared_ptr 类

shared_ptr 都有一个关联的计数器，通常被称为引用计数
- 当我们拷贝一个 shared_ptr，计数器会递增
- 一旦一个 shared_ptr 的计数器变为 0，它就会自动释放自己所管理的对象

程序使用动态内存的三种原因：
1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象间共享数据

## 12.1.2 直接管理内存

- new：在自由空间构造一个对象，并返回其指针
	- 可以分配 const 对象
	- 内存耗尽：虽然内存很大，但是自由空间被耗尽的情况还是有可能发生的
- delete：释放动态内存
	- 销毁给定指针指向的对象
	- 释放对应的内存
	- 记着 delete 后重置指针
		- 因为 delete 后，这个指针就是空悬指针了

容易出错的点：
1. 忘记 delete 内存
2. 使用已经释放掉的对象
3. 同一块内存释放两次

## 12.1.3 shared_ptr 和 new 结合使用

使用 shared_ptr 构造的时候，需要在它的构造函数内 new
- shared_ptr\<int> p2(new int(1024))
- 推荐使用 make_shared 而不是 new

不要混合使用普通指针和智能指针

也不要使用 get 初始化另一个智能指针，或为智能指针赋值

## 12.1.4 智能指针和异常

在默认情况下，shared_ptr 假定它们指向的是动态内存
- 因此当一个 shared_ptr 被销毁时，它默认地对它管理的指针进行 delete 操作

使用我们自己的释放操作：
- 定义一个函数来代替 delete，它被称为删除器函数

使用智能指针的规范：
- 不适用相同的内置指针初始化多个智能指针
- 不 delete get() 返回的指针
- 不使用 get() 初始化或 reset 另一个智能指针
- 如果使用 get() 返回的指针，记住当最后一个对应的智能指针销毁时，指针就变的无效了
- 如果使用智能指针管理的资源不是 new 分配的内存，记住传递给它一个删除器

## 12.1.5 unique_ptr

初始化 unique_ptr 必须采用直接初始化形式
- 它不支持拷贝
- 它不支持赋值

不要使用 auto_ptr ，它已经被 unique_ptr 取代了

但它可以调用 release 或 reset 将指针的所有权从一个 unique_ptr(非const) 转移给另一个 unique

不能拷贝 unique_ptr 的规则有一个例外：
- 我们可以拷贝或赋值一个将要被销毁的 unique_ptr
- 最常见的例子是从函数返回一个 unique_ptr
- 此时编译器知道该对象即将被销毁，它会执行一种特殊的拷贝

也可以向 unique_ptr 传递删除器

## 12.1.6 weak_ptr

它是一种不控制所指向对象生存期的智能指针：
- 它指向由一个 shared_ptr 管理的对象，且不会改变 shared_ptr 的引用计数

# 12.2 动态数组
---

C++ 和标准库提供了两种一次分配一个对象数组的方法：
- C++：new 类型\[数量]()
- 标准库： allocator 的类，允许我们将分配和初始化分离

## 12.2.1 new 和数组

方括号中的大小必须是整型，但不必是常量
- 甚至可以是 0，返回一个合法的非空指针

分配一个数组会得到一个元素类型的指针

释放动态数组：
- delete \[] p

智能指针和动态数组：
- 标准库提供了一个可以管理 new 分配的数组的 unique_ptr 版本

## 12.2.2 allocator 类

new 和 delete 把内存分配和对象构造/对象析构和内存释放结合在一起了
- 但是我们通常希望将内存分配和对象初始化组合在一起

allocator 类：
- 定义在头文件 memory 中
- 帮助我们将内存分配和对象构造分离开来
- 它提供一种类型感知的内存分配方式，它分配的内存是原始的、未构造的
- 可以用 construct 函数再进行构造

# 12.3 使用标准库：文本查询程序
---

## 12.3.1 文本查询程序设计

## 12.3.2 文本查询程序类的定义

