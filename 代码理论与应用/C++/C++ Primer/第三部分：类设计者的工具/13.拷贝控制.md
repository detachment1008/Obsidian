# 13.1 拷贝、赋值与销毁
---

当定义一个类的时候，我们需要显式或隐式地指定此类型的行为：
- 对象拷贝
- 对象移动
- 对象赋值
- 对象销毁

我们通过五个特殊的成员函数来控制这些操作：
- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

如果一个类缺失了上述的某些成员：
- 编译器会自动为它定义缺失的操作
- 因此，很多类都会忽略这些拷贝控制
- 但是编译器定义的版本可能并不适合

## 13.1.1 拷贝构造函数

拷贝构造函数：
- 第一个参数是自身类类型的引用
- 任何额外参数都有默认值

合成拷贝构造函数：
- 如果我们没有定义这样一个函数，编译器会生成合成拷贝构造函数
- 它会将其参数的成员逐个拷贝到正在创建的对象中
	- 对于某些类来说，合成拷贝构造函数阻止了拷贝该类类型的对象

初始化有两种方式：
- 直接初始化：通过构造函数
- 拷贝初始化：通过赋值，即它会调用拷贝构造函数

## 13.1.2 拷贝赋值运算符

重载赋值运算符：
- 重载运算符本质上是函数

合成拷贝赋值运算符：

## 13.1.3 析构函数

析构函数执行与构造函数相反的操作：
- 析构函数释放对象的资源，并销毁对象的非 static 数据成员

合成析构函数

## 13.1.4 三/五法则

三个基本控制类拷贝的操作：
- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数

新标准下：
- 移动构造函数
- 移动赋值运算符

需要析构函数的类也需要拷贝和赋值操作

需要拷贝操作的类也需要赋值操作，反之依然

## 13.1.5 使用=default

我们可以通过将拷贝控制成员定义为=default：
- 这样可以显式地要求编译器生成合成的版本

## 13.1.6 阻止拷贝

定义删除的函数：
- =delete

析构函数不能是删除的成员

合成的拷贝控制成员可能是删除的

private 拷贝控制：
- 在新标准发布之前，类通过将其拷贝构造函数和拷贝赋值运算符声明为 private 来阻止拷贝

# 13.2 拷贝控制和资源管理

管理类外资源的类，必须定义拷贝控制成员

## 13.2.1 行为像值的类

HasPtr 需要：
- 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针
- 定义一个析构函数来释放 string
- 定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝 string

类值拷贝赋值运算符

## 13.2.2 定义行为像指针的类

引用计数

# 13.3 交换操作
---

如果一个类定义了自己的 swap，那么算法将使用类自定义的版本，否则算法将使用标准库定义的 swap

swap 函数应该调用 swap，而不是 std::swap

在赋值运算符中使用 swap
- 定义 swap 的类通常用 swap 来定义它们的运算符
- 这些运算符使用了一种名为拷贝并交换的技术

# 13.4 拷贝控制示例
---

# 13.5 动态内存管理类
---

# 13.6 对象移动
---

## 13.6.1 右值引用

这是一种新的引用类型
- 即必须绑定到右值的引用
- 我们通过 && 而不是 & 来获得右值引用

常规引用就是左值引用

左值持久
右值短暂

标准库 move 函数：
- 获得绑定到左值上的右值引用
- 定义在头文件 utility 中

## 13.6.2 移动构造函数和移动赋值运算符

移动操作、标准库容器和异常

移动赋值运算符

移后源对象必须可析构

合成的移动操作

移动右值，拷贝左值...

...但如果没有移动构造函数，右值也将被拷贝

拷贝并交换赋值运算符和移动操作

移动迭代器

重载和引用函数
