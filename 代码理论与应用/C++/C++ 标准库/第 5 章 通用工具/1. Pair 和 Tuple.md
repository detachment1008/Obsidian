# Pair

内部有两个数据成员, 作用：将两个 `value` 视为一个单元
头文件：`utility`

## 构造函数

```
默认构造：    std::pair<int, float> p;
普通构造函数： std::pair<int, float> p(1, 2.2);
```

- 同时它还有一个拷贝构造函数的另一个版本：它的成员逐个可以隐式转换为自己的成员
- `std::piecewise_construct` 做第一个参数的构造函数，格式：
```
std::pair<A, B>(std::piecewise_construct, std::tuple, std::tuple);
```
正常来说第一个数初始化 A，第二个数初始化 B；但是假如说我们希望有复杂的构造函数，就可以用这个，第一个 `tuple` 内所有的元素调用 A 的构造函数，第二个 `tuple` 调用 B 的构造函数

## 便捷函数

自动推导类型的构造 `pair`：
```
std::make_pair(42, '@');
```

## 元素访问

它的数据成员是 `public` 的，即可以直接访问：
```
p.first
p.second
get<0>(p)
get<1>(p)
```

# Tuple

头文件：`tuple`

它相当与是 `pair` 的扩展，它作为一个单元表示任意数量的元素

当然，它一定使用了不定参数的模板参数(不定参数一定需要模板)

## 构造函数

可以传递各种类型参数：
```
std::tuple<int, string, int> t;
std::tuple<int, string, int> t(1, "hello", 222);
```

## 便捷函数

创建 `tuple`:
```
std::make_tuple()
```

由元素的引用创建 `tuple`:
```
std::tie()
相当与：
std::make_tuple(std::ref(a), std::ref(b), ...)
```
作用：
1. 同时给多个元素赋值
2. 可以在中间忽略元素的同时，利用 `tuple` 给多个元素赋值：`std::ignore`

## 元素访问

`get` 函数可以访问：
```
std::get<2>(t);
```
- 注意：`get` 函数传递的模板参数必须是常量，不能是变量
- `get` 获取的是引用，所以可以改里面的值

## 其他 Tuple 的特性

```
tuple_size<Type>::value // 元素个数
tuple_element<index, Type>::type // 第 index 个元素的类型
tuple_cat(t1, t2, ...) // 将多个 tuple 串接成一个 tuple
```

## 输入与输出

它不支持直接用 `ostream` 输出，但是可以利用模板超编程来输出：
- 编译期间递归调用自己的所有元素，每次都只打印一个元素；直到全部打印完为止

# Tuple 和 Pair 的转换

可以用 `pair` 初始化或赋值双元素的 `tuple`