它们都定义在 `memory` 中

# 共享式智能指针

默认情况下使用 `delete` 清理，如果希望使用 `delete[]` 或其他操作，就需要自己定义了

## 构造函数

```
std::shared_ptr<std::string> str_ptr(new std::string("hello")); // 使用 new 操作符构造
```

## 便捷函数

构建：
```
std::shared_ptr<std::string> str_ptr = std::make_shared<std::string>("hello");
```

重新设置：
```
std::shared_ptr<std::string> str_prt;
str_ptr.reset(new string("hello"));
```

## 定义 Deleter
```
std::shared_ptr<std::string> str_ptr(new std::string("hello"), [](std::string *p){ delete p;});
```
- 注意：必须接受一个原类型的指针参数
- 必须使用构造函数才能定义，`make_shared` 不能定义 `Deleter`

## 获取原始指针

使用 `get()` 函数：
```
std::shared_ptr<int> p = std::make_shared<int>(3);
std::cout << *p.get() << std::endl;
```

# 独占式智能指针

## 转移方式

可以利用 `std::move` 转移 `unique_ptr`

## 默认析构函数

它可以指定第二个参数的类型：
```
std::unique_ptr<int, void(*)(int *)> up(new int[10], [](int *p){delete[] p;});
```

# weak_ptr

如果两个 `shared_ptr` 互相指向，则两者都无法释放了

可以利用 `weak_ptr`，它可以获取 `shared_ptr` 的对象，但是不增加引用计数，可以用它检测 `shared_ptr` 是否有效

检测：
```
std::shared_ptr<int> t = std::make_shared<int>(3);
std::weak_ptr<int> weakPtr(t);
bool b = weakPtr.lock(); // 该 shared_ptr 是否有效
t.reset(); // 释放
```

# 防止误用 shared_ptr

1. 不要将原始指针传递两次给 `shared_ptr`
2. 如果需要多次使用 `this` 给 `shared_ptr`
使用：`enable_shared_from_this`
```
class P: public std::enable_shared_from_this<P>
{
	void foo()
	{
		std::shared_ptr<P> a(shared_from_this());
		std::shared_ptr<P> b(shared_from_this());
	}
}
```
- 即使用该函数：`shared_from_this()`