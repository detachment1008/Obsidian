# Type Trait

目的：提供一种处理类型属性的办法
相当于面对泛型，萃取出该类型的相关信息；且都是在编译期产生的，不影响效率

作用：
1. 模板编程：针对部分类型的重载
2. 处理多个类型中的共通类型

头文件：`type_trait`

## 单参的类型判断式

返回的是一个类型：
1. 是：`std::true_type`
2. 否：`std::false_type`

### 基础类型相关

```
is_void<T>            是否为 void 类型
is_integral<T>        是否为整数类型
is_floating_point<T>  是否为浮点类型
is_arithmetic<T>      是否为整数或浮点数类型
is_signed<T>          是否为有符号类型
.
.
.
```

### class 相关

```
is_empty<T>       是否不带有任何成员
is_polymorphic<T> 是否带有一个 virtual 成员函数
is_abstract<T>    是否为 Abstract class(即至少有一个纯虚函数)
.
.
.
```

### 类型关系相关

```
is_same<T1, T2>   是否为相同类型
is_base_of<T, D>  T 是否是 D 的基类
.
.
.
```

### 改变类型相关

```
remove_const<T>    移除 const 限制
remove_volatile<T> 移除 volatile 限制
.
.
.
```

## 其他特殊属性的判断

```
rank<T>        Array 的维度
extent<T, I=0> 维度 I 的宽度
.
.
.
```

# Reference Wrapper

即用引用的方式传递参数：
```
std::ref()
std::cref()
std::reference_wrapper<int> ref = std::ref(value);
```

# Function Type Wrapper

```
std::function<void(int, int)> fun;
```

这两种外覆器都是为了将低级类型转换为高级类型，但是以达到相同的效果：加了 `&` 这些符号就相当与加了额外限制，变成了更低级的类型，但是泛型需要高级类型才可以，所以需要转换