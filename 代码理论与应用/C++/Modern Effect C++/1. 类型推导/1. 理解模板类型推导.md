# 模板类型推导

声明：
```cpp
template <typename T>
void f(ParamType param);
```

调用：
```cpp
f(expr);
```

首先，移除掉 `expr` 类型中和 ParamType 重复的部分

## 值方式传递

忽略一切限制

## 引用方式传递

添加 ParamType 以外的一切限制

## 指针方式传递

添加对底层指针的一切限制
忽略对顶层指针的一切限制

## 对数组类型的考虑

数组类型就好像一个底层 const + 顶层 const 的指针一样

- 如果 ParamType 中有引用，就说明是引用传递，添加一切限制：数组类型
- 如果 ParamType 中是值或指针，就说明是指针传递，忽略顶层，添加底层：`const int *` 类型

## 对函数类型的考虑

- 如果 ParamType 中有引用：函数类型
- 如果 ParamType 中是值或指针：函数指针类型

## ParamType：万能引用

1. `expr` 若是个左值，T 和 ParamType 就会被推导为`expr`限制符下的左值引用
2. `expr` 若是个右值，按照情况 1 中的规则 2

# 总结，如何推导 T

首先，如果 `expr` 是引用类型，先将其引用忽略

## ParamType 是引用传递

```cpp
template <typename T>
void foo(const T &a);
```

1. 保留 ParamType 中的所有修饰符
2. `expr` 中的类型修饰符
	- 若和 ParamType 重复，忽略
	- 若和 ParamType 不同，保留

## ParamType 是指针传递

```cpp
template <typename T>
void foo(const T *a);

template <typename T>
void foo(const T a);

int a = 3;
const int *b = &a;
foo(b);
```

两种情况会进行指针传递：
1. ParamType 中有指针
2. `expr` 中有指针

### ParamType 中有指针(`expr` 中一定要有指针)

1. 判断 `expr` 中的指针符号个数
	- 若比 ParamType 中的少，报错
	- 若比 ParamType 中的多，保留多出的部分
2. `expr` 中的类型修饰符
	- 对顶层指针的修饰符，忽略
	- 对底层指针的修饰符，且和 ParamType 中的不重复的，保留

### ParamType 中没有指针，`expr` 中有指针

1. 保留 `expr` 中的指针符号
2. 同上述的步骤 2，针对顶层和底层的修饰进行处理

## ParamType 是万能引用

参考之前的即可(区分 `expr` 是左值还是右值)