# 变量
```
let foo = "bar"        " foo 是一个变量

" 选项变量"
let &textwidth = 10    " textwidth 是一个选项

" 本地选项变量(当前缓冲区)
let &l:number=1        " 选项前面加l, 表示本地选项

" 寄存器变量"
let @a="hello"         " 表示直接设置寄存器a，中的值"
echo @/                " 输出刚刚搜索的值

" 本地变量
let b:hello="world"    " 如果变量名字前以b:开头，就说明它是当前缓冲区的局部变量
```
- 注意：和选项区分开，如果是选项，需要前面加&取值
- 将选项也视为一种变量，只是在使用它们之前，前面要加&
- 如果是布尔类型，0假1真；如果是字符串，需要加双引号(奇怪，statusline 就不用加双引号)

- `g`：全局变量
- `w`：窗口变量
- `b`：缓冲区变量
- `l`：函数变量，如果没有函数就是缓冲区变量
- `a`：参数变量

# 条件
```
if <条件>
	<语句>
elseif <条件2>
	<语句>
else
	<语句>
endif
```
- 条件：字符串的开头如果是数字，就转换为数字；否则就视为 0（即 false）

# 比较

可以直接比较，且区分大小写，除非：
```
set ignorecase        " 不区分大小写
set noignorecase      " 区分大小写"
```

特殊的比较操作：
```
==?           " 一定不区分大小写
==#           " 一定区分大小写
```

# 函数
```
function <函数名>()
	<语句>
endfunction

" 调用
call <函数名>() " 这种情况下会丢掉返回值，如果在表达式中直接使用返回值，可以用<函数名>()
```
- 注意：如果函数没有范围，必须以大写字母开头
- 如果函数没有返回值，就隐式的返回 0

# 函数参数
```
...         " 表示变长参数
```
- `a:0`：变长参数个数
- `a:1`：变长参数的第一个
- `a:000`：包含所有变长参数的列表

# 数字

有两种数字，整数和浮点数

# 字符串

连接字符串：`.`
字面值字符串：`'` 括起来的值

# 字符串内置函数
```
strlen()      " 字符串长度
len()         " 字符串长度
split()       " 以空格分割，将字符串拆为列表
join()        " 第一个是列表，第二个是字符串；将字符串插入到列表的每一项之间，并返回一个字符串
tolower()     " 小写
toupper()     " 大写
```

# 执行与普通模式命令
```
execute "字符串"            " 执行字符串的指令
normal <命令>               " 执行普通模式下的命令
normal! <命令>              " 不考虑映射，执行普通模式下的命令
```
- 注意：`normal` 无法解析特殊符号，如：`normal /foo<cr>`；只能使用 `execute` 并配合 `\` 转义来进行实现

# 表
```
[1, 2, 3, 'bar']      " 它的索引是从 0 开始的
[1, 2, 3][1, 2]       " 范围选择，无需担心后面的数超过范围，它会用最大值代替；如果是负数，就是倒序；可以省略
[1, 2, 3][-2:]        " 第一个或最后一个，以表示头或尾(-2 表示倒数第二个，即 2)
[1, 2]+[3, 4]         " 可以用+将两个表连接"
```

# 表内置函数
```
add()                                 " 连接两个表
len()                                 " 输出表的长度
get(foo, 0, 'default')                " 获取指定位置的值，如果没有就返回默认值"
index(foo, 'b')                       " 获取给定值的索引，如果没有就返回 -1
reverse(foo)                          " 翻转
```