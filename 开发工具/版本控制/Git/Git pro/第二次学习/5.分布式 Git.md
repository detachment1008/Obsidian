# 引言
---

现在已经有了一个远程 Git 仓库，能为所有开发者共享代码提供服务

在本章要学习作为贡献者或整合者，在一个分布式协作的环境中如何使用 Git

# 5.1 分布式工作流程
---

## 集中式工作流

即仓库可以接受代码，所有人将自己的工作与之同步；即后续如果开发者希望将数据推送回服务器，必须将第一个人的工作合并进来，才不会覆盖第一个人的修改

这种方式非常简单，只需要给每个人推送数据的权限就行了

## 集成管理者工作流

Git 允许多个远程仓库的存在：
- 每个开发者拥有自己仓库的写权限
- 每个开发者拥有其他所有人仓库的读权限

流程：
1. 项目维护者推送到主仓库
2. 贡献者克隆此仓库，作出修改
3. 贡献者将数据推送到自己的公开仓库
4. 贡献者给维护者发送邮件，请求拉取自己的更新
5. 维护者在自己本地仓库中，将贡献者的仓库加为远程仓库，并合并修改
6. 维护者将合并后的修改推送到主仓库

## 主管与副主管的工作流

副主管：分别管理集成项目中的特定部分
主管：负责统筹

流程：
1. 普通开发者在自己的主题分支上工作，并根据 `master` 分支进行变基
2. 副主管将普通开发者的主题分支合并到自己的 `master` 分支
3. 主管将所有副主管的 `master` 分支合并到自己的 `master` 分支
4. 最后，主管将集成后的 `master` 分支推送到参考仓库中，以便其他开发者以此为基础进行变基

这个并不常用，只有项目极为庞杂，才会体现出优势

# 5.2 向一个项目贡献
---

## 提交准则

准则：`Documentation/SubmittingPatches`
1. 提交不应该包含任何空白错误：`git diff --check`
2. 让每一个提交成为一个逻辑上的独立变更集，即尝试让改动可以理解
	- 不要在这个周末编码解决五个问题，然后周一时将它们提交为一个巨大的提交
	- 即使周末无法提交，也可以在周一使用暂存区将工作最少拆分为每个问题一个提交，并为每个提交附带一个有用的信息
	- 如果一些改动修改了同一份文件，使用 `git add --patch` 来暂存文件
3. 创建优质的提交信息：可以在 Git 项目中使用 `git log --no-merges` 参考漂亮的格式化项目提交历史
	- 信息应当少于 50 个字符(25 个汉字) 的单行开始：简要描述变更
	- 空白行
	- 更详细的解释

## 私有的小型团队

私有：即闭源，不可从外面的世界中访问到；只有你和其他开发者才有仓库的推送权限

---
首次：两个开发者克隆项目，并进行改动

A：John
```
git clone john@githost:simplegit.git
cd simplegit
// 某些修改
git commit -am "remove invalid default value"
```

B：Jessica
```
git clone jessica@githost:simplegit.git
cd simplegit
// 某些修改
git commit -am "add reset task"
```

---
然后，进行推送

B：Jessica
```
// 正常
git push origin master
```

A：John
```
// 有问题
git push origin master
error: failed to push some refs to 'john@githost:simplegit.git'
```

因为 Git 要求你必须在本地合并才能提交，即 `puth` 对远程仓库只能进行 `fast-forward` 的合并

---
John 需要的操作

```
git fetch origin
git merge origin/master
git push origin master
```

---
Jessica 的新主题开发分支：此时 Jessica 新建了一个 `issue54` 的主题开发分支，并提交了三次

Jessica 此时的操作：

希望看看服务器的更新
```
git fetch origin
```

想知道 John 工作的哪些合并到自己的工作中才能推送
```
git log --no-merges issue54..origin/master // 显示所有在后面分支，但是不在前面分支的提交
```

Jessica 希望合并 John 的工作
```
git checkout master
// 下面两条指令的顺序无关
git merge issue54
git merge origin/master
```

Jessica 推送自己的 `issue54` 分支的修改到服务器
```
git push origin master
```

---

这是一个最简单的工作流程，通常你会在一个主题分支上工作一会儿，当他准备整合时，就合并到你的 `master` 分支；当想要共享工作时，就抓取它，并合并到自己的 `master` 分支，之后再推送到服务器的 `master` 分支

## 私有管理团队

此时 John 和 Jessica 在一个 `featureA` 上工作，Jessica 和 Josie 在 `featureB` 上工作

我们跟随 Jessica 的工作流程：此时她已经克隆了项目仓库

---
首先，决定在 `featureA` 上工作：
```
git checkout -b featureA
// 某些修改
git commit -am "add limit to log function"
```

---
然后，她希望将工作同步给 John
```
git push -u origin featureA
```

---
然后，她决定于 Josie 开始在 `featureB` 上工作
```
git fetch origin
jgit checkout -b featureB origin/master
```

---
Jessica 在 `featureB` 上创建几次提交
```
// ...
git commit -am "made the ls-tree function recursive"
// ...
git commit -am "add ls-files"
```

---
此时 Jessica 收到了 Josie 的邮件，告知了一些初始的工作已经被推送到了服务器的 `featureBee` 上了，所以她需要先合并
```
git fetch origin
git merge origin/featureBee
```

---
此时，Jessica 希望将合并后的修改推送回服务器，但是因为已经有一个上游的 `featureBee` 分支了，所以推送到这个分支即可
```
git push -u origin featureB：featureBee
```

这是一个引用规范，`-u` 是 `--set-upstream` 的简写

---
此时，John 发送邮件给 Jessica 说他已经推送了一些改动到 `featureA` 分支，并要求她去验证它们
```
git fetch origin
git log featureA..origin/featureA
```

如果 Jessica 觉得可以，就可以合并了
```
git checkout featureA
git merge origin/featureA
```

---
最后，Jessica 可能想对合并后的内容再做一些小修改，于是她将这些修改提交到本地的 `featureA`，然后推送回去
```
git commit -am "small tweak"
git push
```

## 派生的公开项目

向公开的项目做贡献有一点不同，因为没有权限直接更新项目的分支，必须使用其他办法将工作给维护者；

一般有两种办法：
1. 简单的 Git 托管上使用派生
2. 通过邮件接受贡献补丁

---
首先，可能希望克隆主项目，并创建一个主题分支进行工作
```
git clone <url>
cd project
git checkout -b featureA
...work...
git commit
...work...
git commit
```

---
此时，已完成了工作，希望将此修改贡献回维护者：
1. 去原始项目中，点击 `Fork` 按钮：创建一份自己的可写项目派生仓库
2. 在本地仓库中将该仓库添加为一个新的远程仓库(名字为 `myfork`)
```
git remote add myfork <url>
```

---
然后，推送工作到上面；相对于合并到主分支再推送上去，可以直接推送当前分支上去
- 因为如果工作不被接受，就不必回退 `master` 分支了
```
git push -u myfork featureA
```

---
当工作被推送到派生仓库后，可以通知原项目的维护者你有想要他们合并的工作，这被称为一个 **拉取请求(Pull Request)**
- 可以在网站生成它
- 也可以运行 `git request-pull` 命令，然后将输出通过电子邮件手动发送给项目维护者
```
git request-pull <要拉取主题分支的基础分支> <拉取仓库的 url>
// 产生一个请求拉取的所有修改的摘要
```

通常有一个总是跟踪 `origin/master` 的 `master` 分支会很方便，因为在主题上工作时因为它们被拒绝时可以很容易被丢弃；如果同一时间主仓库移动了，也可以让主题分支更容易变基

如：立马开启第二个特性工作
```
git checkout -b featureB origin/master
...work...
git commit
git push myfork featureB
git request-pull origin/master myfork
git fetch origin
```

---
如果项目维护者已经拉取了一串其他的补丁，然后再尝试拉取你的第一个分支，但是没有干净的合并；你可以尝试变基那个分支到 `origin/master` 的顶部，为维护者解决冲突，然后重新提交你的改动
```
git checkout featureA
git rebase origin/master
git push -f myfork featureA
```

因为你将分支变基了，所以必须为推送命令指定 `-f` 选项，这样才能将有一个不是它后代的提交的 `featureA` 分支替换掉
- 或者你可以推送到另一个分支，如：`featureAv2`

---
此时，维护者很喜欢你第二个分支其中的概念，并希望你修改一下实现细节；此时，你可以利用此机会将工作基于项目现在的 `master` 分支
```
git checkout -b featureBv2 origin/master
git merge --squash featureB
... change implementation ...
git commit
git push myfork featureBv2
```
`--squash` 选项接受被合并的分支上的所有工作，并将其压缩为一个变更集，使仓库变成一个真正的合并发生的状态，而不会真的生成一个合并提交；这意味着你未来的提交将会只有一个父提交，并允许你引入另一个分支的所有改动，然后再记录一个新提交前做更多的改动

`--no-commit` 同样，这个选项也可以在默认合并的过程中，用来延迟生成合并提交

最后，就可以给维护者发消息，表示你已经做了要求的修改

## 通过邮件的公开项目

它的工作流程和之前的是类似的，区别只是如何提交它们到项目中：生成每一个提交序列的电子邮件，然后邮寄到它们开发者邮件列表，而不是派生项目然后推送到自己的可写版本

通过 `git format-patch`：生成电子邮件
也可以编辑这些补丁文件，为邮件列表添加更多不想要在提交信息中显示出来的信息；如果在 `---` 行与补丁开头(`diff --git`)之间添加文本，那么开发者就可以阅读它，但是应用补丁时会忽略它

然后就可以通过电子邮件客户端或命令行发送它了。Git 提供了一个工具帮助你通过 IMAP 发送正确格式化的补丁

---
首先，需要在 `~/.gitconfig` 文件中设置 imap 区块
```
[imap]
	folder = "[Gmail]/Drafts"
	host = imaps://imap.gmail.com
	user = user@gmail.com
	pass = YX]8g76G_2^sFbd
	port = 993
	sslverify = false
```

然后，通过 `git imap-send` 将补丁序列放在特定的 IMAP 服务器的 Drafts 文件夹中

此时，可以到 Drafts 文件夹中，... (后续不看了)

# 5.3 维护项目
---

也先不看了，主要是应用补丁之类的

# 5.4 总结
---

