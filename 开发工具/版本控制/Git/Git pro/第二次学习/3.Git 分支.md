# 引言
---

使用分支：可以把工作从开发主线上分离开来，以免影响开发主线

Git 鼓励在工作流程中频繁地使用分支与合并

# 3.1 分支简介
---

暂存操作：
1. 为每一个文件计算校验和(SHA-1)
2. 将当前版本的文件快照保存到 Git 仓库中( blob 对象)
3. 最终将校验和加入到暂存区等待提交

提交操作：
1. 先计算每一个子目录的校验和
2. 在 Git 仓库中将这些校验和保存为树对象
3. Git 创建一个提交对象，除了包含上面的信息外，还包含了指向该树对象的指针

示例：当空仓库中，新增三个文件并提交时，Git 仓库中有五个对象：
1. 三个 `blob` 对象：保存着文件快照
2. 一个 `tree` 对象：记录着目录结构和 `blob` 对象索引
3. 一个 `commit` 对象：包含着指向 `tree` 对象的指针和所有提交信息

Git 分支本质上就是指向提交对象的可变指针，在每次提交时，当前分支都会自动向前移动

## 分支创建

Git 的分支创建仅仅是创建了一个可以移动的新的指针

`git branch <branchname>`：创建一个新分支(它不会自动切换到新分支去)

Git 是如何知道当前在哪一个分支上的呢？有一个名为 `HEAD` 的特殊指针，它指向当前所在的本地分支，可以将 `HEAD` 理解为当前分支的别名

`git log --oneline --decorate`：查看各个分支当前指向的提交对象(`--decorate`)

## 分支切换

`git checkout <branchname>`  / `git switch <branchname>`：切换到一个已存在的分支

检出时，一共做了两件事情：
1. 使 `HEAD` 指向指定分支
2. 将工作目录恢复成该分支所指向的快照内容

`git log --oneline --decorate --graph --all`：查看分叉历史

`git checkout -b <newbranchname>`：切换分支的同时切换过去
`git checkout -b <newbranchname> <指定分支>`：在指定的分支上创建分支，并切换过去(不想切换过去就使用 `git branch <newbranchname> <指定分支>` )
 
# 3.2 分支的新建与合并
---

## 新建分支

下面是一个经典的工作流：

当在 master 工作时，出现了 #53 问题，需要新建一个分支过去解决：
`git checkout -b iss53`：它等于下面的两条命令
- `git branch iss53`
- `git checkout iss53`

此时，在这个 iss53 分支上工作，并做了一些提交
`git commit -a -m "add a new footer [issue 53]"`

此时，又有一个紧急的问题等待处理，需要做的仅仅是切回到 master 分支即可；注意工作目录和暂存区中那些还没有被提交的修改，它们可能和即将检出的分支产生冲突，建议最好在切换分支时保持一个干净的状态
`git checkout master`

然后修复这个问题，通过新建一个 hotfix 分支，然后在该分支上工作直到问题解决：
`git checkout -b hotfix`

现在工作完了，希望测试一下修改是否正确，即需要将 hotfix 分支的内容合并回 master 分支中，从而希望部署到线上：
`git checkout master`
`git merge hotfix`
fast-forward：当希望合并的分支所指向的提交就是当前提交的直接后继时，Git 会直接将当前指针移动，这种情况下一定没有要解决的分歧，这就叫做 **快进**

此时，你希望回到之前被打断的工作中，可以先删除 hotfix 分支，然后回到原先分支继续工作：
`git branch -d/--delete hotfix`
`git checkout iss53`

## 分支的合并

此时，你修正了 #53 问题，并打算将工作合并入 master 分支：
`git checkout master`
`git merge iss53`

此时，master 分支指向的提交并不是 iss53 分支 所在提交的直接祖先，Git 会做一个 **三路合并**：
- 两个分支的末端所指的快照
- 两个分支的共同祖先

和之前简单的移动分支指针不同，Git 这次将 **三路合并** 的结果做了一个新的快照，并且自动创建了一个新的提交指向它。这被成为一次合并提交，它的特别之处在于它不止有一个父提交

之后就可以删除 iss53 分支了：
`git branch -d iss53`

## 遇到冲突时的分支合并

如果两个分支中，在共图祖先后都对同一个文件的同一个地方进行了修改，Git 就无法干净的合并它，此时就会产生合并冲突

此时 Git 会暂停下来，等待手动解决合并产生的冲突；可以在合并冲突后的任意时刻使用 `git status` 查看那些因包含合并冲突而处于未合并状态的文件

此时文件中冲突的地方都会被标记出来：
```
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
	please contact us at support@github.com
</div>
>>>>>>> iss53.index.html
```

`=======` 上半部分表示的是 HEAD 指向分支的版本，下半部分表示 iss53 分支的版本

解决冲突后，对冲突的文件使用 `git add` 命令，来将其标记为冲突已解决；一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。当全部解决后，`git commit` 即可

注意冲突解决工具：`git mergetool`

# 3.3 分支管理
---

`git branch`：查看当前所有分支列表

`git branch -v`：查看每个分支的最后一次提交

`git branch --merged`：查看已合并到当前分支的分支
- 一般已经合并的就可以删除了(`git branch -d <分支名>`)
- 如果尚未合并，是无法使用 `-d` 删除的，只能使用 `-D` 来进行强制删除

`git branch --no-merged`：查看尚未合并到当前分支的分支

# 3.4 分支开发工作流
---

## 长期分支

因为 Git 使用简单的三方合并，所以长时间反复将一个分支合并入另一个分支，也不是难事；即可以同时拥有多个开放的分支，然后定期将某些主题分支合并入其他分支中

如：
- `master`：保存完全稳定的代码
- `develop`：平行分支，用于后续的开发和测试稳定性；一旦稳定就可以合并入 `master` 了
- `proposed`：建议分支，包含一些不成熟的内容而不能进入 `develop` 或 `master`

## 主题分支

主题分支是一种短期分支，用以实现单一特性或其他相关工作

当完成后，合并入长期分支即可

# 3.5 远程分支
---

远程分支是对远程仓库的引用，包括分支、标签等等

`git ls-remote <remote>`：获得远程引用的完整列表(包含 `HEAD`，`分支名`，`标签`)

远程跟踪分支：远程分支状态的引用，是无法移动的本地引用；可以将它们理解为书签，记录了该分支在远程仓库中的位值

`git fetch <remote>`：与给定的远程仓库同步数据

`git remote add <remote> URL`：一个仓库可以有多个远程仓库，它们之间数据在本地是共用的

## 推送

`git push <remote> <branch>`：将本地的指定分支，推送到远程仓库的指定分支(分支名相同)

`git push <remote> <localbranch>:<remotebranch>`：将本地指定的分支，推送到远程仓库的另一个指定分支(分支名可以不同，如果远程仓库没有将创建)

之后别人再 `git fetch origin` 后再 `git checkout -b serverfix origin/serverfix` 即可在这个分支工作了

## 跟踪分支

从一个远程分支，检出一个本地分支会自动创建 "跟踪分支"，跟踪分支是与远程分支有直接关系的分支；如果在一个跟踪分支上输入 `git pull` ，Git 会自动识别去哪个服务器上抓取，合并到哪一个分支

当克隆一个仓库时，会自动创建一个跟踪 `origin/master` 的 `master` 分支

`git checkout --track origin/serverfix`：根据远程分支检出一个新分支，并设置跟踪

`git checkout serverfix`：如果 `serverfix` 分支不存在，且刚好有一个远程分支与之名字匹配，那么 Git 就会创建一个跟踪分支(同上)

`git branch -u origin/serverfix`：设置当前分支跟踪指定分支

`git branch -vv`：将本地所有分支列举出来，并包含更多信息

# 3.6 变基
---

# 3.7 总结
---

