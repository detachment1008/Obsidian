# 摄像机
---

OpenGL 本身并没有摄像机的概念

但摄像机的移动就等同于场景中其他所有物体作反向运动

注意：OpenGL 是观察 -z 方向的，即我们需要将摄像机变换到原点

# 摄像机/观察空间
---

观察空间，即摄像机的局部空间

为了创建一个摄像机，我们需要定义它在世界空间中的位置，观察的方向，右侧向量，上侧向量

根据这些，得到一个矩阵，即为 view transform

> 用哪个坐标系的单位描述，就是变换到哪个的坐标系(用逆矩阵就反过来了)

## 1. 摄像机位置

摄像机的位置：位置向量

## 2. 摄像机方向

摄像机的方向：方向向量(即需要单位化)

即摄像机局部空间的 z 轴负方向

## 3. 右轴

右轴：方向向量(即需要单位化)

即摄像机局部空间的 x 轴正方向

## 4. 上轴

上轴：方向向量(即需要单位化)

即摄像机局部空间的 y 轴正方向

小技巧：利用右轴 x 摄像机方向，即可得到已单位化的上轴

# Look At
---

## 矩阵的含义
有了上述观察空间的信息，我们就可以创建出一个仿射变换矩阵来使得世界空间中的物体变换到摄像机空间中。

就是用观察空间的基向量为基准，描述世界空间中的物体(model transform中，物体的位置已经确定)

我们先得到用世界空间基向量描述的摄像机局部空间的基向量，形成一个矩阵

然后取逆！！！逆矩阵才是我们真正的观察变换矩阵，逆矩阵是用摄像机的基向量描述世界空间的基向量

## 变换的本质

>矩阵变换只是描述了两个空间的基向量关系的信息，如果一个物体在一个空间有，另一个空间没有，我们希望在另一个空间创建出一个相同的，那就是物体的位置变换。如果说物体已经存在，我们只是希望换一个坐标系，那么就是物体的坐标变换

>A描述的矩阵 * 位置向量：
>1.表示 A 空间下的该位置向量的描述
>2.A 怎样描述的表示 A 空间下相同的位置向量经过这样的变换，得到的结果

>即如果你把这个位置向量看作是初始的坐标系，那么它的结果就是变换
>如果你把这个位置向量直接看作是矩阵的坐标系，那么它就是换一种描述

>A 描述的 B * 向量：
>1.表示用 A 描述 B 空间的该向量
>2.表示 A 空间的该向量变换到 B 空间

# 自由移动
---

现在我们希望自己移动摄像机，即动态改变 view 的位置向量

## GLFW 获取键盘输入

如下
```
glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS
```

# 移动速度
---

如果我们使用一个常量来表示速度，那么根据处理器能力的不同，帧数就不同，那么速度也就不同了

## 时间差

时间差是一个变量，它存储了渲染上一帧所需的时间，我们可以用速度乘以这个 deltaTime 变量

如果上一帧用了很长的时间，那意味着我们的速度变慢了，下一帧就需要加快，正好 deltaTime 记录了这个变化

可以利用 glfwGetTime 函数来计算每帧的时间

# 视角移动
---

即我们希望通过鼠标的输入改变 cameraFront 向量

# 欧拉角
---

一共有三种欧拉角：
1. 俯仰角：绕 x 轴旋转(pitch)
2. 偏航角：绕 y 轴旋转(yaw)
3. 翻滚角：绕 z 轴旋转(roll)

对于我们的摄像机系统来说，我们只关心俯仰角和偏航角

## 如何将俯仰角和偏航角转换为方向向量

只有转为方向向量，我们在可以在 view transform 中代替 -z 方向，从而更新观察变换矩阵

可以使用球形坐标系，即极坐标进行方向向量的计算

### 俯仰角

1. 绕 x 轴旋转，即 x 坐标保持不变
2. 旋转 pitch 弧度
3. y，z 的坐标
	- y：
	- z：

### 偏航角

1. 绕 y 轴旋转，即 y 坐标保持不变
2. 旋转 yaw 弧度
3. x，z 的坐标
	- x：
	- z：
	
# 鼠标输入
---

偏航角和俯仰角是通过鼠标移动获得的，水平移动影响偏航角，竖直移动影响俯仰角

原理：存储上一帧鼠标位置，在当前帧计算鼠标位置与上一帧相差多少

1. 当处于焦点时，隐藏光标并捕捉它：`glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED)`
2. 监听鼠标移动事件
3. 处理鼠标输入
	- 计算鼠标距上一帧的偏移量
	- 把偏移量添加到摄像机的俯仰角和偏航角中
	- 对偏航角和俯仰角进行最大和最小的限制
	- 计算方向向量

# 缩放
---

控制鼠标滑轮，来改变 fov，即透视矩阵
